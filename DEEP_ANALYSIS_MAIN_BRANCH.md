# Глубокий анализ состояния репозитория и «ветки main»

> Дата аудита: 2026-02-22  
> Анализ выполнялся на текущей ветке `work` (см. раздел 1).

## 1) Важный факт про ветку `main`

В локальном git-репозитории **нет отдельной ветки `main`** (только `work`).
Это означает, что технически сравнить `work` vs `main` невозможно без remote-refs.

Практический вывод: текущий «mainline» проекта в этом окружении — фактически HEAD ветки `work`.

## 2) Что реально уже доказано (и что это НЕ означает)

### Доказано в коде

1. В активном дереве `pnp3/` нет глобальных `axiom`, `sorry`, `admit`.
2. `./scripts/check.sh` проходит.
3. Финальный активный результат в коде — **условный** `NP_not_subset_PpolyFormula`.

### Не доказано как безусловное утверждение

1. Безусловный `P ≠ NP` **не получен**: финальные теоремы требуют внешний мост
   `hFormulaToPpoly : NP_not_subset_PpolyFormula -> NP_not_subset_Ppoly`.
2. Default-провайдеры формально выражены через `Nonempty ...`, то есть это интерфейс
   доступности свидетеля, а не внутренне построенный канонический объект.

## 3) Точные узкие места (что нужно закрыть, чтобы «доказательство закончить»)

Ниже — ровно те блокеры, которые реально удерживают проект в условном статусе.

### Блокер A (I-5): мост из formula-separation в nonuniform-separation

Сейчас `P_ne_NP_final*` зависят от аргумента `hFormulaToPpoly`.
Пока этот мост не внутренний, финальное `P ≠ NP` остаётся условным.

**Что именно нужно:**
- Теорема (или эквивалентный пакет), убирающая внешний параметр
  `hFormulaToPpoly` из `P_ne_NP_final*`.

### Блокер B (I-4): реальные witness/provider для multi-switching/shrinkage

Несмотря на отсутствие `axiom`, pipeline по-прежнему питается внешней доступностью
свидетелей на уровне интерфейсов (provider-style).

**Что именно нужно:**
- Для целевых семейств решателей построить внутренние (в Lean-коде) экземпляры
  multi-switching/shrinkage, используемые конечной цепочкой, а не только обёртками.

### Блокер C (I-2): дефолтный structured provider должен следовать из внутренних конструкций

Сейчас флаги default availability устроены через `Nonempty ...`.
Это корректно логически, но не является «внутренне закрытым» источником
конструктивных данных по умолчанию.

**Что именно нужно:**
- Замкнуть `hasDefaultStructuredLocalityProviderPartial` от внутренних
  certificate/multi-switching construction без внешнего допущения существования.

## 4) Ключевые места, где условность «протекает» в финальные теоремы

1. `P_ne_NP_final*` семейство — явная зависимость от `hFormulaToPpoly`.
2. `NP_not_subset_PpolyFormula_final` требует
   `hasDefaultStructuredLocalityProviderPartial` + асимптотическую гипотезу.
3. `hasDefaultStructuredLocalityProviderPartial` определён как `Nonempty ...`.

Иными словами: формально цепочка корректна, но её «источник данных» остаётся
внешним (интерфейсно-предикатным), а не полностью внутренне-синтезированным.

## 5) Найденные потенциально ложные/устаревшие формулировки

### 5.1 Устаревший комментарий про аксиомы

В `pnp3/ThirdPartyFacts/Facts_Switching.lean` в верхнем комментарии есть фраза,
что факты «оформлены как Lean-аксиомы».

Это уже **не соответствует текущему состоянию** (активных `axiom` в `pnp3/` = 0).
Нужно исправить комментарий, чтобы не вводить в заблуждение аудиторов.

### 5.2 Архивные документы могут противоречить актуальному статусу

Часть документов помечена как archived/deprecated; использовать их как source-of-truth
для текущего состояния нельзя.

## 6) Самопроверка на «скрытые дыры»

Проверено, что:

1. Нет прямых `axiom`/`sorry`/`admit` в активном `pnp3/`.
2. Но есть зависимость ключевых теорем от `Classical.choice` и др. логических аксиом
   фундамента (обычно допустимо в Lean-математике и не равно «глобальным project axioms»).
3. Unconditional gate (`UNCONDITIONAL=1 ./scripts/check.sh`) проходит, но сама проверка
   keyword-based и не может математически доказать закрытие I-2/I-4/I-5.

Вывод: CI-gate полезен как регресс, но не как окончательный научный критерий завершения.

## 7) Практический план завершения (приоритет)

1. **Сначала I-5**: убрать `hFormulaToPpoly` из `P_ne_NP_final*`.
   Это моментально превращает финальный wrapper из условного в внутренний.
2. **Параллельно I-4**: закрыть depth>2 multi-switching depth induction и сборку
   provider-grade witness (см. `pnp3/Docs/MultiSwitching_DepthInduction_TODO.md`).
3. **Затем I-2**: склеить default provider из результатов I-4 и убрать зависимость
   от голого `Nonempty`-флага как внешней точки входа.
4. Обновить документацию/формулировки после каждого закрытого блока,
   особенно комментарии в `Facts_Switching.lean`.

## 8) Итоговый вердикт

Текущий репозиторий находится в хорошем формально-проверяемом состоянии:
- код собирается,
- нет project-level `axiom/sorry/admit`,
- активная цель `NP_not_subset_PpolyFormula` корректно оформлена.

Но доказательство «до конца» (`P ≠ NP` без внешних крючков) ещё не завершено.
Не хватает:
1) внутреннего formula→P/poly моста (I-5),
2) полностью внутренних witness/provider construction для switching/shrinkage (I-4),
3) закрытой default constructive provider path без внешней `Nonempty`-входной точки (I-2).
