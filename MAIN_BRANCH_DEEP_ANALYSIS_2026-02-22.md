# Глубокий анализ репозитория и текущего состояния доказательства

Дата: 2026-02-22  
Ветка в локальном репозитории: `work` (локальной ветки `main` в этом checkout нет).

## 1) Что реально доказано сейчас

1. Проект в текущем состоянии **собирается** и проходит основной check-скрипт (`./scripts/check.sh`).
2. В активном дереве `pnp3/` действительно нет `axiom`/`sorry` как деклараций.
3. Формально активный конечный результат — это **условная** формулировка на треке формул: `NP_not_subset_PpolyFormula`.
4. Финальные обёртки для `P ≠ NP` всё ещё требуют явный мост
   `NP_not_subset_PpolyFormula -> NP_not_subset_Ppoly`.

## 2) Точная точка, где доказательство «не закрыто до конца»

Критически важный факт: в `pnp3/Magnification/FinalResult.lean` теорема
`P_ne_NP_final` принимает дополнительный параметр `hFormulaToPpoly`.

Это означает:
- финальный шаг `NP ⊄ P/polyFormula  =>  NP ⊄ P/poly` **не доказан внутри** текущего дерева;
- следовательно, без внешнего моста утверждение `P ≠ NP` не замыкается.

Иными словами, главная математическая «дыра» №1 — это именно I-5.

## 3) Что ещё внешнее (не аксиомы, но внешние witness/провайдеры)

### 3.1 I-4: реальные multi-switching/shrinkage инстансы

В коде используется «провайдерная» архитектура через структуры/классы
(`...WitnessProvider`, `AllFunctionsAC0MultiSwitchingWitness` и т.д.).
Это корректно инженерно, но означает, что ключевые объекты пока
поставляются как входные данные (instances/Nonempty), а не выведены end-to-end
из внутренних конструкций для целевых семейств.

### 3.2 I-2: default structured provider

`NP_not_subset_PpolyFormula_final` требует `hasDefaultStructuredLocalityProviderPartial`.
Сейчас это `Nonempty ConstructiveLocalityEnginePartial`, то есть факт существования
движка должен быть дан (или получен из других внешних пакетов-свидетелей).

Да, есть удобные маршруты через `FormulaCertificateProviderPartial` и half-size route,
но в обоих случаях для «по умолчанию безусловного» пути всё ещё нужны
конструктивные данные, которые пока не внутренне выведены в полном объёме.

## 4) Есть ли ложные/слишком сильные утверждения в документации?

## 4.1 Сильных ложных claims про «уже безусловно P!=NP» в актуальных файлах не видно

`README.md`, `STATUS.md`, `TODO.md`, `AXIOMS_FINAL_LIST.md`, `BARRIER_AUDIT.md`
в целом согласованы: они маркируют финальные `P ≠ NP` результаты как условные
и перечисляют открытые I-2/I-4/I-5.

## 4.2 Но есть 2 источника потенциальной путаницы

1. Формулировка «0 axioms» может быть прочитана слишком широко.
   Корректно: нет **пользовательских `axiom`-деклараций**. Но многие конечные
   теоремы зависят от классических оснований (`Classical.choice`, `propext`, `Quot.sound`),
   что видно по `AxiomsAudit` инфо-выводу.

2. `UNCONDITIONAL=1 ./scripts/check.sh` сейчас проходит, хотя I-2/I-4/I-5 открыты.
   Значит, этот «unconditional gate» в текущем виде проверяет лишь отсутствие
   некоторых строковых паттернов, но не реальное закрытие математических блокеров.
   Это может создавать ложное ощущение «всё уже безусловно закрыто».

## 5) Локальная проверка «сам себе оппонент» (challenge)

Чтобы проверить, не является ли трек формул тривиальным/вакуумным, полезно смотреть:

1. В `Facts_Magnification_Partial` провайдер действительно используется для извлечения
   локального решателя, после чего вызывается антчекер-теорема
   `noSmallLocalCircuitSolver_partial_v2`.
2. `noSmallLocalCircuitSolver_partial_v2` действительно использует `solver.correct`
   и locality-свидетельство (не просто `False` из воздуха).

То есть current chain не выглядит чисто тавтологической. Проблема не в «внутренней
логической пустоте», а в том, что ключевые входы всё ещё поставляются извне
через интерфейсы-провайдеры и bridge-гипотезу.

## 6) Что конкретно нужно сделать, чтобы «дожать» доказательство

Минимальный реалистичный порядок:

1. Закрыть I-4: построить реальные семейства witness-ов для multi-switching,
   которые дают провайдерные инстансы без ручного внешнего ввода.
2. На базе I-4 закрыть I-2: внутренне получить default structured locality provider.
3. Закрыть I-5: доказать bridge
   `NP_not_subset_PpolyFormula -> NP_not_subset_Ppoly` в текущей модели интерфейсов.
4. После этого переписать final wrappers так, чтобы
   `P_ne_NP_final` не принимал `hFormulaToPpoly`.
5. Усилить CI-гейт: вместо grep-паттернов добавить проверку сигнатуры
   `P_ne_NP_final` (что у неё больше нет bridge-параметра) и проверку,
   что final theorem собирается из внутренних инстансов без extra hypotheses.

## 7) Итог в одном абзаце

Сильнее всего сейчас не хватает **математического и формального закрытия I-5**
(мост формульного разделения к `P/poly`) и полного внутреннего закрытия I-4/I-2
(реальные witness-провайдеры и default route). Поэтому текущая вершина — это
корректный, машинно-проверенный, но **условный** pipeline. Это не провал;
это аккуратно размеченная «почти финишная» стадия с чётко локализованными
остаточными блокерами.
