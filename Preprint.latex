\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath,amsthm,amssymb,mathtools}
\usepackage{microtype}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{margin=1in}
\hypersetup{colorlinks=true, linkcolor=blue, citecolor=blue, urlcolor=blue}

\title{%
A Blueprint for $P \neq NP$ via Switching--Atlas Lemma, Capacity Bounds, and Hardness Magnification\\[2mm]
\large (with fully formalized Steps A and B in Lean~4; Steps C and D conditional on standard results)}
\author{Author: \texttt{[Your Name]}\\
\small Artifacts repository: \texttt{[GitHub URL to pnp3]}
}
\date{\today}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

\newcommand{\AC}{\mathrm{AC^0}}
\newcommand{\NP}{\mathrm{NP}}
\newcommand{\PP}{\mathrm{P}}
\newcommand{\Ppoly}{\mathrm{P/poly}}
\newcommand{\GapMCSP}{\mathrm{GapMCSP}}
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\logtwo}{\log_2}
\newcommand{\eps}{\varepsilon}

\begin{document}
\maketitle

\begin{abstract}
We present a Lean-verified framework that derives lower bounds for \emph{GapMCSP} from a
\emph{switching-type} shrinkage certificate, and then upgrades these bounds to the nonuniform
separation $NP \not\subseteq P/\mathrm{poly}$ through modern \emph{hardness magnification}.
Two foundational layers are \textbf{Step~A}---the \emph{Switching--Atlas Lemma (SAL)}---and
\textbf{Step~B}---the \emph{Covering--Power (capacity) bound}. Both steps are fully formalized
and machine-checked in Lean~4. Our current formalization of \textbf{Step~A} uses a single
external axiom packaging the classical $\AC$ switching lemma. \textbf{Step~C} (the
\emph{anti-checker} lower bounds for \GapMCSP) and \textbf{Step~D} (OPS'20/CJW'22
\emph{magnification triggers}) are stated in detail and can be either imported from the
literature or formalized within the same framework. Under these standard assumptions, we
obtain $NP \not\subseteq P/\mathrm{poly}$; combined with $P \subseteq P/\mathrm{poly}$, this
yields $P \neq NP$.
\end{abstract}

\section{Introduction}
The $P$ vs.\ $NP$ problem is the central challenge in computational complexity. Recent
\emph{hardness magnification} results (e.g., Oliveira--Pich--Santhanam '20; Chen--Jin--Williams '22)
show that seemingly modest circuit/formula lower bounds for explicit problems can
\emph{trigger} the nonuniform separation $NP \not\subseteq P/\mathrm{poly}$. This paper
develops and formalizes a modular pipeline that produces such lower bounds for \GapMCSP,
bridging classical \emph{switching} phenomena with counting-based \emph{capacity} arguments,
and then applies magnification triggers to arrive at $P \neq NP$.

\paragraph{Contributions.}
\begin{itemize}[leftmargin=*,nosep]
  \item \textbf{Step A (SAL; Lean-verified).} From a \emph{shrinkage certificate}
  (a partial decision tree approximating each $f$ in a finite family $F$ with error $\eps$),
  we \emph{construct} an \emph{atlas} of subcubes that approximates $F$ with controlled parameters
  $(k,\eps)$. The construction and bounds are fully formalized in Lean~4.
  \item \textbf{Step B (Capacity; Lean-verified).} We prove a sharp upper bound on the
  \emph{capacity} of any $(k,\eps)$-atlas, implying that no such atlas can approximate more than
  $2^{H(\eps)\,\sum_j N_j}$ functions, where $N_j$ is the number of live variables on leaf $j$ and
  $H$ is the binary entropy. Formalized in Lean~4 as \texttt{family\_card\_le\_capacity}.
  \item \textbf{Step C (Anti-checker; detailed and conditional).} Assuming a \emph{small} solver for
  \GapMCSP\ (e.g.\ depth-2 formulas of size $N^{2+\delta}$ or $\polylog$-local circuits of size
  $N \cdot (\log N)^\kappa$), we build a \emph{rich} subfamily $Y$ and a test set $T$ that
  contradict capacity; hence super-quadratic (or near-linear) lower bounds follow.
  \item \textbf{Step D (Magnification; detailed and conditional).} Using OPS'20 and CJW'22
  triggers, these \GapMCSP\ lower bounds imply $NP \not\subseteq P/\mathrm{poly}$, and together with
  $P \subseteq P/\mathrm{poly}$ yield $P \neq NP$.
\end{itemize}

\paragraph{Formalization status.}
All constructions and proofs in Steps A and B are \emph{fully verified} in Lean~4. Step A uses a
single external axiom (the classical $\AC$ switching lemma) to package parameters into our SAL
interface; all remaining arguments are fully formal. Steps C and D are presented as detailed
theorems with proof strategies; they can be imported from the literature or fully formalized in
future versions.

\subsection*{Main (conditional) theorem}
Assuming (i) an $\AC$ switching lemma (including the derived shrinkage bounds used by SAL),
(ii) the anti-checker theorems stated in Section~\ref{sec:anti}, and
(iii) the OPS'20/CJW'22 magnification triggers in Section~\ref{sec:magnification},
we obtain $NP \not\subseteq P/\mathrm{poly}$, hence $P \neq NP$. Steps A and B are Lean-verified;
Steps C and D rely on well-known results.\medskip

\noindent\textbf{Lean artifacts.} The Lean code and build instructions (including a \#print axioms
log for Steps A--B modules) are available at: \texttt{[GitHub URL]}, commit \texttt{[hash]}.

\section{Technical setup}
We consider boolean functions $f:\{0,1\}^n \to \{0,1\}$ and families $F$ of such functions.
A \emph{subcube} $\beta \in \{0,1,*\}^n$ is a partial assignment; its \emph{live} variables are the
coordinates left as $*$. A (binary) \emph{decision tree} (DT) queries input bits; its depth is the
max path length. A \emph{partial decision tree} (PDT) consists of a \emph{trunk} (a DT) and a finite
set of \emph{tails} (DTs attached to leaves of the trunk).

\begin{definition}[Shrinkage certificate]
A \emph{shrinkage certificate} for a finite family $F$ on $n$ variables is a tuple
$(\ell,\mathcal{C})$, where $\ell\in \mathbb{N}$ and $\mathcal{C}$ packs:
(i) a PDT $W$ whose trunk depth is at most $t$ and whose number of tails is at most $2^\ell$;
(ii) for each $f\in F$ a list of subcubes $\mathrm{Sel}(f)$ among the trunk leaves; and
(iii) an error parameter $\eps \in [0,1]$ such that $err_U(f,\mathrm{Sel}(f))\le \eps$ for all $f\in F$.
\end{definition}

\section{Step A: Switching--Atlas Lemma (SAL)}
\label{sec:SAL}
The Lean development isolates the combinatorial conversion from shrinkage to atlases from the
analytic information supplied by switching lemmas. The core statement works for an abstract
shrinkage certificate.

\begin{theorem}[SAL core]\label{thm:SAL}
Let $S$ be a shrinkage certificate for a family $F$ on $n$ variables, with partial decision tree
depth $t$ and approximation error $\varepsilon$. Then the atlas obtained by listing the leaves of
$S$'s tree and reusing the shrinkage predictions \emph{works for}~$F$; moreover the dictionary size
and the selector budget produced by the Lean scenario satisfy $k,\,|\mathcal{A}| \le 2^{t}$ and the
error parameter remains $\varepsilon$.\footnote{Formally this is the combination of
\texttt{SAL\_from\_Shrinkage} and the leaf-count bounds in
\texttt{scenarioFromShrinkage\_k\_le\_pow} and
\texttt{scenarioFromShrinkage\_dictLen\_le\_pow}.}
\end{theorem}

\begin{proof}[Proof idea]
The Lean proof treats a shrinkage certificate as a \emph{common} partial decision tree whose leaves
carry selectors for each $f \in F$. Turning the tree into an atlas is a structural operation; the
selectors stay inside the leaf dictionary and the original error bounds remain valid. Leaf counts of
binary trees yield the $2^{t}$ upper bound on both $k$ and the dictionary length.
\end{proof}

\paragraph{Instantiation for $\AC^0$ and locality.} Interfaces in
\texttt{ThirdPartyFacts/Facts\_Switching.lean} and \texttt{Core/ShrinkageAC0.lean} package external
switching results into shrinkage witnesses with explicit bounds on depth, selector budget and error.
Instantiating Theorem~\ref{thm:SAL} with these witnesses produces a bounded-atlas scenario whose
parameters obey
\begin{equation*}
  k,\;|\mathcal{A}| \le 2^{\bigl(\log_2(M+2)\bigr)^{d+1}},\qquad
  0 \le \varepsilon \le \frac{1}{n+2}
\end{equation*}
for $\AC^0$ formulas of depth~$d$ and size~$M$, and analogous bounds in the local-circuit
setting.\footnote{See, e.g., \texttt{scenarioFromAC0\_completeBounds} and
\texttt{exists\_boundedAtlas\_from\_AC0}.}

\paragraph{Lean status.} The SAL core (Theorem~\ref{thm:SAL}) is proved entirely within Lean without
additional assumptions. The interfaces to $\AC^0$ and locality currently rely on the external
axioms \texttt{partial\_shrinkage\_for\_AC0}, \texttt{partial\_shrinkage\_with\_oracles}, and
\texttt{shrinkage\_for\_localCircuit}, which encapsulate the classical multi-switching lemmas needed
for Step~A.

\section{Step B: Covering--Power (Capacity) bound}
\label{sec:capacity}
Step~B translates the atlas data delivered by SAL into purely counting statements. The Lean
formalization introduces two combinatorial quantities:
\begin{itemize}[leftmargin=*,nosep]
  \item the \emph{union bound} $\mathrm{UnionBound}(D,k)=\sum_{i=0}^k \binom{D}{i}$, which limits how
  many unions of at most $k$ subcubes from a dictionary of length~$D$ can occur; and
  \item the \emph{Hamming-ball bound} $\mathrm{HammingBall}(N,\varepsilon)$, which counts the number of
  Boolean functions on $N$ inputs within distance $\varepsilon N$ of a fixed center.
\end{itemize}
Their product
\begin{equation*}
  \mathrm{capacityBound}(D,k,N,\varepsilon)
  = \mathrm{UnionBound}(D,k) \cdot \mathrm{HammingBall}(N,\varepsilon)
\end{equation*}
upper-bounds the size of every $\varepsilon$-approximation class supported by a dictionary of
length~$D$ with union budget~$k$.

\begin{theorem}[Covering--Power bound]\label{thm:capacity}
Let $\mathcal{A}$ be an atlas on $n$ variables with dictionary length $D$, selector budget $k$, and
error tolerance $\varepsilon \le \tfrac{1}{2}$. If a family $F$ is approximated by $\mathcal{A}$ (in
the sense supplied by Step~A), then
\begin{equation*}
  |F| \;\le\; \mathrm{capacityBound}(D,k,2^{n},\varepsilon).
\end{equation*}
Moreover, the Lean development records the explicit inequality
\begin{equation*}
  \mathrm{capacityBound}(D,k,2^{n},\varepsilon)
  \;\le\; (k+1) \cdot \bigl(\max\{1,D\}\bigr)^{k} \cdot 2^{2^{n}},
\end{equation*}
which is convenient for automated searches.
\end{theorem}

\begin{proof}[Proof idea]
Every function in $F$ agrees outside a small Hamming ball with a union of at most $k$ dictionary
subcubes. Enumerating the possible unions gives the $\mathrm{UnionBound}$ factor, while the error
budget contributes $\mathrm{HammingBall}$. Multiplying the two constraints yields the stated bound.
\end{proof}

\paragraph{Lean status.} Theorem~\ref{thm:capacity} is implemented as
\texttt{family\_card\_le\_capacity} together with its preparatory lemmas
\texttt{approxClass\_card\_le\_capacity} and
\texttt{approxClass\_card\_le\_explicit}. The entire Step~B directory builds with
\#print~\texttt{axioms} returning the empty set.

\section{Step C: Anti-checker lower bounds for \texorpdfstring{\GapMCSP}{GapMCSP}}
\label{sec:anti}
The classical Circuit--Input Game converts any sufficiently small solver for \GapMCSP\ into a family
of inputs that violates the covering bounds from Step~B. In the Lean project this reasoning is
captured by four explicit axioms in \texttt{LowerBounds/AntiChecker.lean}:
\begin{itemize}[leftmargin=*,nosep]
  \item \texttt{antiChecker\_exists\_large\_Y} --- from an $\AC^0$ solver we obtain a rich subfamily
  exceeding the scenario capacity;
  \item \texttt{antiChecker\_exists\_testset} --- the same construction with an explicit test set;
  \item \texttt{antiChecker\_exists\_large\_Y\_local} and \texttt{antiChecker\_exists\_testset\_local}
  --- analogous statements for local-circuit solvers.
\end{itemize}
Each axiom matches the hypotheses and conclusions used in the counting arguments of
\texttt{LB\_Formulas.lean} and \texttt{LB\_LocalCircuits.lean}. Eliminating these axioms requires a
formal treatment of the anti-checker game and the associated richness lemmas.

\section{Step D: Magnification triggers and the final separation}
\label{sec:magnification}
The final stage converts the Step~C lower bounds into complexity-class separations. In the Lean
project this is mediated by axioms in \texttt{Magnification/Facts\_Magnification.lean} and
\texttt{Magnification/LocalityLift.lean}:
\begin{itemize}[leftmargin=*,nosep]
  \item \texttt{OPS\_trigger\_general} and \texttt{OPS\_trigger\_formulas} formalize the OPS'20
  magnification implications for general and depth-2 circuit lower bounds;
  \item \texttt{Locality\_trigger} and \texttt{CJW\_sparse\_trigger} encode the JACM'22 locality and
  sparse-language triggers; and
  \item \texttt{locality\_lift} relates general circuits to local circuits.
\end{itemize}
To turn $NP \not\subseteq P/\mathrm{poly}$ into $P \neq NP$ the bridge additionally uses the interface
axioms \texttt{NP\_not\_subset\_Ppoly}, \texttt{P\_subset\_Ppoly}, and
\texttt{P\_ne\_NP\_of\_nonuniform\_separation} from \texttt{Complexity/Interfaces.lean}, which point
back to the fully formalized results in the legacy \texttt{pnp2} development. Under these assumptions
the Lean file \texttt{Magnification/FinalResult.lean} proves
\texttt{P\_ne\_NP\_final} and \texttt{P\_ne\_NP\_final\_general}, making the conditional nature of the
current pipeline completely explicit.

\section{External assumptions and current status}
\begin{itemize}[leftmargin=*,nosep]
  \item \textbf{Step A.} Three axioms encapsulate classical switching results:
  \texttt{partial\_shrinkage\_for\_AC0}, \texttt{partial\_shrinkage\_with\_oracles}, and
  \texttt{shrinkage\_for\_localCircuit}. The SAL core itself is fully proved.
  \item \textbf{Step B.} Completely formalized with no axioms or \textsc{sorry}.
  \item \textbf{Step C.} Four axioms describe the anti-checker output (rich subfamilies and optional
  test sets) for $\AC^0$ and local circuits; the counting consequences are fully checked.
  \item \textbf{Step D.} Ten axioms encode the magnification triggers, the locality lift, and the
  interface to the previously formalized complexity-class facts.
\end{itemize}
The consolidated audit in \texttt{docs/PNP\_Proof\_Audit\_2025-10-22.md} records these seventeen
axioms and the status of every Lean module.

\paragraph{Depth-2 constructive addendum.}
Independently, we develop constructive depth-2 switching for DNF/CNF; the DNF case is complete,
with CNF pending minor technicalities (three local lemmas). This addendum is optional for the main
pipeline but useful as a ground check.

\section{Reproducibility and Lean artifacts}
We provide a self-contained Lean~4 project with:
\begin{itemize}[leftmargin=*,nosep]
  \item Complete formal proofs for the SAL core and all counting lemmas.
  \item Structured interfaces for external results, each annotated as an axiom with source references.
  \item Unit tests and smoke tests for PDT/atlas infrastructure.
\end{itemize}
Artifacts: \texttt{[GitHub URL]}, commit \texttt{[hash]}, build: \texttt{lake build}. The file
\texttt{docs/PNP\_Proof\_Audit\_2025-10-22.md} summarizes the axiom inventory and verification
status of every module.

\section{Outlook}
To obtain a fully self-contained proof we must eliminate the remaining axioms:
\begin{enumerate}[leftmargin=*,nosep]
  \item formalize the multi-switching lemma for $\AC^0$ (including the oracle and locality
  extensions) to discharge the Step~A assumptions;
  \item mechanize the anti-checker game and richness arguments underlying Step~C; and
  \item import or formalize the OPS/CJW magnification triggers and the locality lift used in Step~D.
\end{enumerate}
Each task corresponds to a well-documented result in the literature; the Lean infrastructure in this
repository isolates the statements so that future work can replace every axiom with a proof.

\paragraph{Acknowledgments.} [Add collaborators, discussion partners, funding, etc.]

\begin{thebibliography}{99}
\bibitem{Hastad86}
J.~H{\aa}stad.
\newblock \emph{Computational Limitations of Small-Depth Circuits}.
\newblock MIT Press, 1986.

\bibitem{BeamePrimer}
P.~Beame.
\newblock \emph{A Switching Lemma Primer}.
\newblock Manuscript/notes, 1994+.

\bibitem{ServedioTan18}
R.~Servedio and L.-Y.~Tan.
\newblock Pseudorandom multi-switching lemmas.
\newblock FOCS 2018; journal versions 2019/2022.

\bibitem{OPS20}
I.~Oliveira, P.~Pich, and R.~Santhanam.
\newblock Hardness magnification near state-of-the-art lower bounds.
\newblock ITCS/CCC 2020 (various versions).

\bibitem{CJW22}
X.~Chen, Y.~Jin, and R.~Williams.
\newblock Hardness magnification for sparse languages.
\newblock J.~ACM, 2022.

\bibitem{AroraBarak}
S.~Arora and B.~Barak.
\newblock \emph{Computational Complexity: A Modern Approach}.
\newblock Cambridge University Press, 2009/2014.

\bibitem{Jukna}
S.~Jukna.
\newblock \emph{Boolean Function Complexity: Advances and Frontiers}.
\newblock Springer, 2012.
\end{thebibliography}

\end{document}
