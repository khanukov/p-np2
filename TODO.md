# To-Do / План завершения формализации (P≠NP pipeline)

> **Status (2025-12-26)**: `pnp3/` конвейер полностью формализован и **не содержит аксиом**.
> Единственная условность остаётся из-за **внешних свидетельств (witnesses)** в части A
> (shrinkage/switching). Временное условие `AC0SmallEnough` устранено: сильная
> граница `ac0DepthBound_strong` теперь определена как `max(M², polylog)`, что
> делает pipeline независимым от допущения «малости», но ещё не даёт чистую
> polylog‑оценку без `max`.
> Этот файл фиксирует **что именно осталось доделать и как**, с привязкой к модулям,
> теоремам и интерфейсам Lean.

---

## Краткий анализ текущего состояния (A → B → C → D)

**Часть A (Switching/Atlas, shrinkage)**
- Реализованы теоремы:
  - `partial_shrinkage_for_AC0` (теорема без доп. гипотез о малости).
  - `shrinkage_for_localCircuit` (теорема, но зависит от `FamilyIsLocalCircuit` witness).
- AC⁰ пока фактически реализуется как глубина 2 (DNF), с **слабой оценкой глубины** `M^2`.
- В интерфейсах уже подготовлены параметры глубины `d` и сильная цель `polylog`.
- Введены структуры:
  - `FamilyIsAC0` / `AC0CircuitWitness` — свидетельства принадлежности семьи AC⁰.
  - `FamilyIsLocalCircuit` / `LocalCircuitWitness` — свидетельства локальности.

**Часть B (Covering-Power, ёмкостные оценки)**
- Леммы мощности покрываемых атласом семей доказаны без аксиом.
- Ключевая лемма: `approxOnTestsetWitness_injective` и цепочка следствий — все in Lean.

**Часть C (Античекер)**
- Полностью доказано: существование большого `Y` и тест-набора, на котором малые схемы
  ошибаются. Теоремы: `antiChecker_exists_large_Y`, `antiChecker_exists_testset`.
- Не использует внешних допущений — лишь части A и B.

**Часть D (Magnification)**
- Все триггеры (OPS, CJW, локальность) формализованы как **теоремы**:
  - `OPS_trigger_general`, `OPS_trigger_formulas`, `locality_trigger`,
    `CJW_sparse_trigger` — все без аксиом.
- Мост к финальному выводу собран в `Bridge_to_Magnification.lean`.

**Финальный вывод (P ≠ NP)**
- В `Magnification/FinalResult.lean` есть `P_ne_NP_final` / `P_ne_NP_final_general`.
- Текущая условность: гипотеза `hF_all : ∀ loc, FamilyIsLocalCircuit ...`.
- Внешняя теорема `P ⊆ P/poly` импортируется из `Facts/PsubsetPpoly`.

---

## Что мешает безусловному доказательству

1. **Нет внутренних конструкций свидетелей shrinkage**
   - В `partial_shrinkage_for_AC0` требуется `FamilyIsAC0` (witness для AC⁰).
   - В `shrinkage_for_localCircuit` требуется `FamilyIsLocalCircuit` (witness для локальных схем).
   - Сейчас это **внешние входы**, а не автоматически построенные структуры.

2. **Слабая глубинная оценка (Stage‑1: `M^2`)**
   - Условие `AC0SmallEnough` удалено, но `ac0DepthBound_strong` теперь равна
     `max(M², polylog)`. Это сохраняет корректность, однако не даёт чистой
     polylog‑оценки без запаса.
   - Нужно заменить доказательство на полноценную multi-switching лемму и
     вернуть определение `ac0DepthBound_strong = polylog`.

3. **Финальная гипотеза `hF_all`**
   - Она исчезнет автоматически, как только будет предоставлен real witness
     через `ExternalLocalityWitnessProvider`.

---

## Обновлённый план (multi-switching + индукция по глубине AC⁰)

Ниже — актуализированный план работ, основанный на multi-switching лемме и
индукции по глубине схем AC⁰. Он заменяет прежний «Stage‑1» подход и детально
указывает, какие математические шаги и интерфейсы должны быть реализованы в Lean.

### 1) Теоретическая база — multi-switching lemma
**Цель:** заменить слабую оценку `M²` на реальную полилог‑оценку, построенную на
обобщении switching‑леммы Хастада к семействам формул.

**Ключевые идеи:**
- Одиночная switching‑лемма: при случайной `p`‑рестрикции `k`‑CNF/`k`‑DNF
  превращается в дерево решений глубины `t` с вероятностью
  `≥ 1 - (C·p·k)^t`.
- **Multi‑switching:** для семейства из `S` формул одной рестрикцией можно
  одновременно упростить их все. Вероятность неудачи оценивается как
  `S^{⌈t/ℓ⌉} · (C·p·k)^t`, где `ℓ` — длина ствола частичного дерева решений.

**Литературная база:**
Impagliazzo–Matthews–Paturi (2012), Servedio–Tan (2019), Håstad (1986).

---

### 2) Индукция по глубине `d` (AC⁰)
**Цель:** получить общий полилог‑сертификат глубины `t` для схем глубины `d`.

**База `d=2` (DNF/CNF):**
- Сразу применяем multi‑switching к множеству термов ширины `k`.
- При параметрах `p = Θ(1/k)` и `ℓ = Θ(log M)` получаем частичный сертификат
  глубины `O(log M)`; на листьях формула сводится к константе или литере.

**Переход `d → d+1`:**
- Рассматриваем нижний слой формул (CNF/DNF) и применяем multi‑switching
  ко всему семейству.
- Получаем общий ствол глубины `ℓ`, на листьях которого исходная схема
  превращается в подсхему глубины `d` размера `M' = M^{O(1)}`.
- По индукции строим хвостовые деревья и «склеиваем» со стволом.
- Итоговая глубина: `t = ℓ + t₂`, где `t₂` — полилог от `M'`.
  Следовательно, `t` остаётся полилогом от `M`.

---

### 3) Вероятностный аргумент → детерминированное существование
**Цель:** превратить «с высокой вероятностью» в «существует конкретная рестрикция».

**Инструмент:**
- Использовать `Classical.choose` для извлечения свидетеля из факта
  существования (следует из положительной вероятности).
- Дерандомизация не требуется, так как цель — существование сертификата.

---

### 4) Сертификаты shrinkage и оценка числа подкубов
**Цель:** формализовать `PartialCertificate` и оценить размер покрытия.

**Ключевые факты:**
- Сертификат состоит из ствола (ℓ ограничений) и хвостов (деревья глубины `≤ t₂`).
- Общая глубина `t` даёт число листьев `≤ 2^t` через
  `PDT.leaves_length_le_pow_depth`.
- Подставляя `t = polylog(M)`, получаем квазиполиномиальную оценку числа подкубов.

---

### 5) Интеграция в AC0PolylogBoundWitness и снятие аксиом
**Цель:** заменить аксиому multi‑switching реальным доказательством.

**Шаги:**
1. Доказать `partial_shrinkage_for_AC0` без аксиом и без `AC0SmallEnough`.
2. Удалить `max(M², polylog)` и вернуть чистую `ac0DepthBound_strong = polylog`.
3. Построить реальные `AC0CircuitWitness` и `LocalCircuitWitness`
   через `Classical.choose` и `locality_lift`.
4. Подменить `ExternalLocalityWitnessProvider` на внутренний instance.
5. Удалить `hF_all` из `P_ne_NP_final` и очистить финальные теоремы.

---

## Конкретные точки правки (кодовые якоря)

- **`pnp3/ThirdPartyFacts/Facts_Switching.lean`**
  - `partial_shrinkage_for_AC0` — сильная граница строится через `max(M², polylog)`;
    нужно заменить на чистую polylog‑оценку после multi-switching.
  - `partial_shrinkage_for_AC0_with_bound` — промежуточный артефакт Stage‑1.
  - `ac0DepthBound_weak/strong` — готовые границы, нужно сделать strong фактической.

- **`pnp3/ThirdPartyFacts/LocalityLift.lean`**
  - Класс `ExternalLocalityWitnessProvider` — заменить тривиальный instance.
  - Функции `locality_lift` / `locality_lift'` — ждут реальный witness.

- **`pnp3/Magnification/FinalResult.lean`**
  - Убрать `hF_all` после интеграции witness-провайдера.

---

## Текущий чеклист

- [ ] Multi-switching (полилог) для AC⁰ depth `d>2`.
- [x] Удаление `AC0SmallEnough` из сигнатур конвейера.
- [x] База для модели `R_s`: `restrictionsWithFreeCount` и оценка кардинала.
- [x] Комбинаторная лемма: из `card(bad) < card(total)` следует существование good.
- [x] Лемма `exists_good_of_card_lt` для bad‑подмножеств в `R_s`.
- [x] Базовые типы для multi‑switching: `kCNF/kDNF` и `evalFamily`.
- [ ] Замена `max(M², polylog)` на чистую polylog‑оценку.
- [ ] Реальный `ExternalLocalityWitnessProvider`.
- [ ] Удаление `hF_all` из `P_ne_NP_final`.
- [ ] Финальная проверка `AxiomsAudit` и обновление документов.

---

## Перед аудитом и проверкой корректности

Ниже — краткая фиксация того, что ещё нужно реализовать/проверить, чтобы
передать код на аудит (без клинапа и без изменения публичных интерфейсов).

### Multi‑switching (основной пробел)
- [ ] Реальная конструкция CCDT/encoding (канонический DT, явная инъекция).
- [ ] Оценка мощности множества кодов и доказательство `codes.card < (R_s s).card`.
- [ ] Интеграция в `Facts_Switching.lean`: заменить `max(M², polylog)` на чистую polylog‑оценку.

### Witness‑ы локальности
- [ ] Встроить реальный `ExternalLocalityWitnessProvider` из shrinkage.
- [ ] Убрать гипотезу `hF_all` в `Magnification/FinalResult.lean`.

### Контроль соответствия комментариев и кода
- [ ] Проверить, что все комментарии в `AC0/MultiSwitching/*` соответствуют
  фактическим определениям (особенно вокруг `BadEvent`, `EncodingWitness`, `R_s`).
- [ ] Сверить описания в `Facts_Switching.lean` с реальными параметрами и границами.

---

## Примечания

- **Классическая логика (`Classical.choose`, `noncomputable`) не снижает строгости** —
  это допустимая методология Lean, используемая в формальных доказательствах.
- Все части B, C, D считаются завершёнными и не требуют доработки.
- Единственная «реальная» математика, остающаяся за пределами Lean, — это
  multi-switching lemma и конструкция witness-ов shrinkage.
