# Состояние формализации включения `P ⊆ P/poly`

## Что уже реализовано

* Построены схемы, симулирующие пошаговую работу детерминированной одноленточной машины Тьюринга, и доказана корректность каждой подсхемы ("лента", "голова", "состояние") относительно конфигураций.
* Получены верхние оценки на число вентилей для всех вспомогательных блоков и собраны в единую рекуррентную оценку `affineIter`, контролирующую итерации `stepBounds`.
* Определён кандидат на итоговую оценку размера схем `gatePolyBound` вместе с леммами `sizeOf_acceptCircuit_le_gatePolyBound` и `inPpoly_of_polyBound`, которые сведут задачу к явной полиномиальной границе.

## Основные пробелы

1. **Грубость аффинной рекурсии.** Текущая оценка `totalBound_stepBounds_le_affine` даёт рост вида
   \[
     X_{t+1} \le A(n) \cdot X_t + B(n),
   \]
   где `A(n)` полиномиальна по длине входа. При подстановке в закрытую форму получаем выражения
   `A(n)^{poly(n)}`, что существенно превышает требуемый полиномиальный масштаб. Необходима более тонкая оценка, показывающая, что вклад предыдущей конфигурации растёт только линейно (или с постоянным коэффициентом), иначе не получится доказать `gatePolyBound ≤ n^k + k`.
2. **Отсутствие явной полиномиальной границы.** Лемма `gatePolyBound_le_dominantBase_pow` всё ещё содержит показатель степени, линейный по `dominantBase`. При нынешних оценках это приводит к суперполиномиальному росту. Требуется:
   * либо пересмотреть определение `gatePolyBound`,
   * либо существенно ужесточить промежуточные оценки (`affineFactor`, `affineOffset`), чтобы показатель степени стал константой (зависящей лишь от машины).
3. **Закрытие аксиомы.** После получения `∃ k, ∀ n, gatePolyBound ≤ n^k + k` нужно построить `InPpoly` и заменить аксиому `ComplexityClasses.P_subset_Ppoly` настоящей теоремой, обновив зависимости в `NP_separation.lean` и документации.

## План дальнейших действий

1. Перепроверить `stepBounds`: вычислить точные коэффициенты зависимости каждой компоненты от предыдущей и попытаться показать, что `totalBound` растёт как `X_{t+1} ≤ X_t + poly(n)`. Это сведёт задачу к суммированию по времени `runTime n` и даст прямую полиномиальную оценку.
2. Если уточнение прямо через `totalBound` неудобно, рассмотреть по компонентам (`tape`, `head`, `state`) и доказать отдельные линейные рекурсии, чьи решения явно полиномиальны.
3. После получения адекватной границы пересобрать финальный участок (`gatePolyBound`, `dominantBase`) и доказать лемму вида `∃ k, ∀ n, gatePolyBound ≤ (n + C)^k`, а затем — стандартное неравенство `≤ n^k + k`.
4. Инстанцировать `inPpoly_of_polyBound`, сформулировать и доказать теорему `P_subset_Ppoly` без использования аксиомы, удалить её из `ComplexityClasses.lean` и обновить связанные файлы.

## Блокеры

* Необходим тщательный аудит суммарных оценок: текущие коэффициенты явно завышены. Возможно, стоит ввести более структурированное описание конфигураций (например, вести счетчики по "новым" вентилям, а не абсолютное количество).
* Прежде чем оптимизировать Lean-код, полезно на бумаге проделать расчёт для классического доказательства (Gate-count ≤ `(n + T(n))^{O(1)}`) и перенести формулы в Lean.

## Рекомендуемые ресурсы

* Секция 6.1 книги Arora–Barak — даёт точные границы для симуляции машин схемами.
* Конспект Sipser, §9.3 — простая индукция по шагам с явными полиномиальными оценками.
* Обсуждение в `docs/np_not_p_poly_sketch.md` — краткое описание уже реализованных компонентов.

