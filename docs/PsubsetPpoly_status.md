# Состояние формализации включения `P ⊆ P/poly`

## Что уже реализовано

* Построены схемы, симулирующие пошаговую работу детерминированной одноленточной машины Тьюринга, и доказана корректность каждой подсхемы ("лента", "голова", "состояние") относительно конфигураций.
* Получены верхние оценки на число вентилей для всех вспомогательных блоков и собраны в единую рекуррентную оценку `affineIter`, контролирующую итерации `stepBounds`.
* Определён кандидат на итоговую оценку размера схем `gatePolyBound` вместе с леммами `sizeOf_acceptCircuit_le_gatePolyBound` и `inPpoly_of_polyBound`, которые сведут задачу к явной полиномиальной границе.
* Lean-источники сборки `p-np2` не содержат `sorry`: все вспомогательные леммы для построения прямолинейных конфигураций полностью доказаны. 【F:TODO.md†L31-L33】
* Добавлена модель прямолинейных схем `StraightLineCircuit`, фиксирующая списки вентилей и позволяющая явно описывать повторное
использование промежуточных сигналов при переходе между слоями симуляции. 【F:Pnp2/Circuit/StraightLine.lean†L1-L156】
* Построена прямая конфигурация `StraightConfig.initial`, снабжённая корректностью относительно начальной конфигурации машины, что открывает путь к описанию шагов симуляции как добавления фиксированного числа DAG-вентилей. 【F:Pnp2/PsubsetPpoly.lean†L234-L360】
* Добавлен строитель `StraightLineCircuit.Builder`, который инкапсулирует последовательное добавление вентилей, выдаёт маркеры-провода с контролируемыми границами и переиспользует лемму `eval_snoc` для немедленного анализа семантики новых сигналов. Это подготовительный шаг к прямолинейному описанию одного шага машины. 【F:Pnp2/Circuit/StraightLine.lean†L360-L518】
* Расширен API строителя: добавлены варианты `appendFin`, обёртки для булевых вентилей, сводящиеся к новым индексам `Fin`, а также итератор `appendBigOr`, который аккуратно наращивает схемы для больших дизъюнкций и сопровождается леммой о корректности результата. Эти инструменты необходимы для построения «символа под головой» и других суммарных сигналов без потери шаринга. 【F:Pnp2/Circuit/StraightLine.lean†L518-L723】
* Введён «оценочный» билдер `StraightLineCircuit.EvalBuilder`, фиксирующий неизменность исходных проводов при добавлении вентилей и предоставляющий вспомогательные леммы для подъёма индексов. С его помощью построен прямолинейный символ (`symbolBuilder`) и доказано совпадение с настоящим битом под головкой. 【F:Pnp2/Circuit/StraightLine.lean†L723-L1133】【F:Pnp2/PsubsetPpoly.lean†L416-L565】
* Добавлена упаковка `symbolBuilderWire`, переводящая построенный провод в токен `Wire`. Это упрощает дальнейшее наращивание схем: токен автоматически переиспользуется после добавления новых вентилей, а корректность завернута в отдельные леммы. 【F:Pnp2/Circuit/StraightLine.lean†L320-L356】【F:Pnp2/PsubsetPpoly.lean†L438-L567】
* Построен прямолинейный аналог ветвления по паре `(q, b)` (`branchBuilder` и `branchBuilderWire`), выдающий провод для условия "машина в состоянии `q` и читает бит `b`". Леммы `branchBuilder_spec` и `branchBuilderWire_spec` позволяют использовать его как строительный блок для будущих прямолинейных переходов. 【F:Pnp2/PsubsetPpoly.lean†L586-L747】
* Добавлен обобщённый конструктор `branchBuilderFrom`, который принимает заранее построенный провод символа и расширяет текущий
билдер без повторного вызова `symbolBuilder`. Лемма `branchBuilderFrom_spec` обеспечивает перенос корректности, что пригодится
 при наращивании прямолинейного шага. 【F:Pnp2/PsubsetPpoly.lean†L586-L803】
* Расширен API `EvalBuilder`: добавлен `appendBigOr`, позволяющий собирать дизъюнкцию произвольного списка проводов без потери инвариантов и снабжённый леммой `appendBigOr_eval`. Хелпер пригодится при построении прямолинейных версий `writeBit` и других суммарных сигналов. 【F:Pnp2/Circuit/StraightLine.lean†L670-L802】
* Уточнены леммы о сохранении семантики при добавлении вентилей: `append_evalWire_preserved` и `appendFin_evalWire_preserved` гарантируют, что ранее построенные токены `Wire` продолжают обозначать те же булевы функции после каждого `snoc`. Это подготовительный шаг к корректности прямолинейных снапшотов. 【F:Pnp2/Circuit/StraightLine.lean†L1006-L1046】
* Построен «снимок» прямолинейной конфигурации `branchSnapshot`, который материализует провод символа и список ветвей `(q, b)` с контролем индексов, а также `writeSnapshot`, добавляющий провод записываемого бита и фиксирующий монотонность `appendBigOr`. 【F:Pnp2/PsubsetPpoly.lean†L1128-L1796】
* Зафиксирован инвариант `branchBuilderFrom_preserves_eval`, гарантирующий, что добавление очередной ветви не искажает значения уже построенных проводов; он будет использован при формализации корректности снапшотов и шага. 【F:Pnp2/PsubsetPpoly.lean†L720-L835】
* Доказаны спецификации `branchSnapshot_spec` и `writeSnapshot_spec`: первый утверждает, что все записанные ветви вычисляют охрану `branchGuard`, второй — что итоговый провод `write` совпадает с аккумулятором `writeAccumulator`. Это закрывает семантические пробелы перед реализацией прямолинейного шага. 【F:Pnp2/PsubsetPpoly.lean†L1360-L1900】
* Усилен инвариант ветвей: леммы `writeSnapshot_branch_spec` и `tapeSnapshot_branch_spec` показывают, что даже после добавления провода записи и лентных гаджетов каждый элемент `snapshot.branches` продолжает вычислять `branchGuard`. Это позволяет непосредственно передавать семантику ветвей в будущие билдеры головы и состояния без дополнительной перестройки доказательств. 【F:Pnp2/PsubsetPpoly.lean†L1904-L2061】
* Сформулированы конфигурационные аналоги `branchGuard`, `writeContribution` и `writeAccumulator`, описывающие дизъюнктивное объединение ветвей переходов на уровне булевой семантики. Леммы `writeContribution_spec`, `writeAccumulator_eq_any` и `writeAccumulator_spec` связывают эти определения с таблицей переходов и подготавливают почву для корректности прямолинейного `writeBit`. 【F:Pnp2/PsubsetPpoly.lean†L858-L997】
* Построен лентный снапшот `tapeSnapshot`, аккумулирующий провода для каждой ячейки и связывающий их со значениями `TM.stepConfig` через лемму `tapeSnapshot_step_spec`. Это завершает семантическую картину для прямолинейного обновления ленты перед интеграцией в `StraightConfig.step`. 【F:Pnp2/PsubsetPpoly.lean†L1504-L2334】
* Добавлен вспомогательный билдер `headBuilderStep`, собирающий вклад всех ветвей переходов в следующий индикатор головы, и доказана линейная оценка `headBuilderStep_gate_le`. Теперь рост числа вентилей для головы контролируется напрямую через `snapshot.branches.length ⋅ tapeLength`. 【F:Pnp2/PsubsetPpoly.lean†L3891-L3989】【F:Pnp2/PsubsetPpoly.lean†L3989-L4046】
* Получена точная линейная оценка `tapeSnapshot_gate_le`, показывающая, что построение снапшота добавляет не более `4 ⋅ tapeLength` вентилей сверх `writeSnapshot`. Это фиксирует рост лентной части прямолинейной схемы и делает шаг к глобальной рекурсии по числу вентилей. 【F:Pnp2/PsubsetPpoly.lean†L2604-L2720】
* Сведён рост шага `StraightConfig.step` к сумме вкладов снапшотов: лемма `StraightConfig.step_gateGrowth` показывает, что количество вентилей в прямолинейной конфигурации после шага контролируется линейной комбинацией оценок для ленты, головы и состояний. 【F:Pnp2/PsubsetPpoly.lean†L3778-L3844】
* Линейный рост прямолинейной симуляции на всём промежутке времени: лемма `straightTotalGateCount_runtime_le` завязывает число вентилей после `M.runTime n` шагов на начальный размер и константу `straightStepGateGrowthBound`, подтверждая, что прямолинейная модель масштабируется линейно по числу итераций. 【F:Pnp2/PsubsetPpoly.lean†L286-L297】【F:Pnp2/PsubsetPpoly.lean†L3923-L3951】

### Ключевые итоги последних коммитов

1. **Прямая (DAG) архитектура схем полностью обустроена.** Помимо базового синтаксиса `StraightLineCircuit`, теперь имеется связка из билдера `Builder`, оценочного билдера `EvalBuilder` и набора специализированных конструкторов (`appendConstFin`, `appendAndFin`, `appendBigOr`). Эта инфраструктура обеспечивает управление токенами проводов и гарантирует сохранение значений уже построенных сигналов при любом `snoc`, что критично для шаринга промежуточных выражений. 【F:Pnp2/Circuit/StraightLine.lean†L360-L1133】
2. **Символьные и ветвевые компоненты конфигурации реализованы на прямолинейном уровне.** Функции `symbolBuilder`, `branchBuilder` и их вариации на токенах строят провода для «символа под головкой» и условий ветвления, при этом доказано, что вычисления совпадают с соответствующими булевыми выражениями конфигурации машины. Это позволяет повторно использовать результаты без дублирования вентилей при построении снапшотов и будущего шага `StraightConfig.step`. 【F:Pnp2/PsubsetPpoly.lean†L416-L803】
3. **Снимки конфигурации покрывают весь шаг симуляции.** Комбинация `branchSnapshot`, `writeSnapshot` и `tapeSnapshot` уже формирует полный набор проводов, необходимый для обновления ленты, головы и состояния в прямолинейной схеме, а сопровождающие леммы фиксируют как семантику, так и линейные оценки прироста вентилей. Остаётся лишь собрать эти компоненты в полноценный шаг `StraightConfig.step`. 【F:Pnp2/PsubsetPpoly.lean†L1128-L2720】
4. **Появились прямые извлекатели конечных проводов.** Функции `StraightConfig.nextTapeBuilder`, `StraightConfig.nextHeadBuilder` и `StraightConfig.nextStateBuilder` переводят снапшоты в `Fin`-индексированные токены и тем самым закрывают пропуск в чеклисте по подготовке прямолинейного шага. 【F:Pnp2/PsubsetPpoly.lean†L4841-L4872】【F:Pnp2/PsubsetPpoly.lean†L3435-L3677】
5. **Определён прямолинейный шаг `StraightConfig.step`.** Функция оборачивает `stateSnapshot`, поднимает все записанные провода до `Fin`-ручек итогового билдера и готовит API для дальнейшего доказательства корректности шага и оценки прироста вентилей. 【F:Pnp2/PsubsetPpoly.lean†L3696-L3784】

## Основные пробелы

Все технические препятствия для включения `P ⊆ P/poly` сняты: корректность прямолинейного шага `StraightConfig.step` и его линейная оценка доказаны, рекурсия по числу шагов сведена к линейному росту, а итоговый `gatePolyBound` доминируется явным полиномом `n^k + k`.  Теорема `P_subset_Ppoly` теперь формулируется и используется в `ComplexityClasses.lean` без обращения к аксиомам.

Оставшаяся работа относится к соседним направлениям дорожной карты (`magnification_AC0_MCSP`, `FCE_implies_MCSP`) и выходит за рамки данного файла.

## План дальнейших действий

* Поддерживать доказанный конвейер `StraightConfig` и при необходимости переносить уточнения оценок в смежные конструкции (`ConfigCircuits`, `runtimeCircuits`).
* Сфокусироваться на формализации magnification и мосте от FCE-леммы к `MCSP`, которые теперь единственные несут аксиомы в разделе сложности.
* Обновлять документацию при появлении новых зависимостей, чтобы сохранить прозрачность перехода от машин Тьюринга к схемам.

### Текущий фронт задач

Чтобы зафиксировать ближайшие цельные шаги и синхронизировать работу с прямолинейной архитектурой, выделим оперативный чеклист:

1. **Интегрировать построители головы в общий шаг.** ✓ Построен вспомогательный снимок `StraightConfig.headSnapshot`, который на основе `headContributionIndices` и `headBuilderStep` формирует провода следующего индикатора головы и снабжён линейной оценкой `headSnapshot_gate_le`. 【F:Pnp2/PsubsetPpoly.lean†L4200-L4412】【F:Pnp2/PsubsetPpoly.lean†L4414-L4466】
2. **Свести новые провода ленты к единому билдеру.** ✓ Итоговый прирост зафиксирован леммой `StraightConfig.step_gateGrowth`, использующей `tapeSnapshot_gate_le` и `tapeBuilderStep`. 【F:Pnp2/PsubsetPpoly.lean†L1889-L2133】【F:Pnp2/PsubsetPpoly.lean†L3778-L3844】
3. **Закрыть спецификацию шага без ущерба для шаринга.** ✓ Лемма `StraightConfig.step_spec` доказана без `sorry`, опираясь на `append_evalWire_preserved`, `appendBigOr_eval` и `headContribution_fold_eq_any`. 【F:Pnp2/Circuit/StraightLine.lean†L1006-L1133】【F:Pnp2/PsubsetPpoly.lean†L4126-L4275】

- [x] **Линейная рекурсия по количеству вентилей.** 【F:Pnp2/PsubsetPpoly.lean†L4208-L4272】
  - [x] Ввести числовую инварианту `straightTotalGateCount` и доказать, что переход к `StraightConfig.step` увеличивает её не более чем на `K ⋅ M.tapeLength n`. 【F:Pnp2/PsubsetPpoly.lean†L145-L157】【F:Pnp2/PsubsetPpoly.lean†L3799-L3811】
- [x] Связать `straightTotalGateCount` с уже существующей `totalGateCount` через перевод `StraightConfig` → `ConfigCircuits` (обе стороны должны получать одинаковые суммы за счёт шаринга проводов). 【F:Pnp2/PsubsetPpoly.lean†L296-L469】【F:Pnp2/PsubsetPpoly.lean†L332-L469】
  - [x] Сформулировать и доказать индуктивную лемму `straightGateCount_iterate_le`, применяющую предыдущий пункт к `Nat.iterate` и дающую оценку `≤ gateCount initial + K ⋅ M.tapeLength n ⋅ t`. Новая константа `straightStepGateGrowthBound` фиксирует шаговый прирост, а лемма `straightTotalGateCount_iterate_le` сводит рост к линейной функции по числу итераций. 【F:Pnp2/PsubsetPpoly.lean†L3876-L3940】

- [x] **Полиномиальное доминирование.**
  - [x] Получить явные неравенства `M.tapeLength n ≤ (n + 2) ^ c₁` и `M.runTime n ≤ (n + 2) ^ c₂` из существующих лемм (`runTime_le_polyBase`, вспомогательные утверждения про движение головы) или добавить их при необходимости. Новые оценки `runTime_le_shifted_pow` и `tapeLength_le_shifted_pow` сводят гипотезу `runTime n ≤ n^c + c` к чистым степеням, позволяя в последующих шагах прямо умножать их при переходе к полному числу шагов. 【F:Pnp2/PsubsetPpoly.lean†L8775-L8806】【F:Pnp2/PsubsetPpoly.lean†L9464-L9506】
  - [x] Из леммы `straightGateCount_iterate_le` вывести верхнюю грань на `totalGateCount (runtimeCircuits M n)` вида `≤ K' ⋅ (n + 1)^{c₁ + c₂}` и переписать её в формате `n^k + k` (с явным `k` и доказательством для всех `n`).
  - [x] Обновить доказательство `sizeOf_acceptCircuit_le_gatePolyBound`, заменив `gatePolyBound` на новую компактную оценку или, при сохранении `gatePolyBound`, показать её доминацию полученной формулой. 【F:Pnp2/PsubsetPpoly.lean†L10836-L10879】
  - Дополнительно зафиксировано итоговое утверждение `sizeOf_acceptCircuit_le_gatePolyBound`, завершающее перенос оценки на семейство схем. 【F:Pnp2/PsubsetPpoly.lean†L10930-L10967】

- [x] **Снятие аксиомы.**
  - [x] Переписать `ComplexityClasses.lean`, заменив ссылку на аксиому `P_subset_Ppoly` на конструктивную теорему и зафиксировать источник доказательства. 【F:Pnp2/ComplexityClasses.lean†L1-L120】
  - [x] Обновить `docs/master_blueprint.md`, TODO-лист и связанные разделы документации, отражая факт, что аксиома снята и оценивая зависимости других файлов. (Этот пункт закрывается текущим коммитом.)
- [x] Прогнать `lake build` / `lean --make` и убедиться, что удаление аксиомы не ломает существующие теоремы (`NP_not_in_P_poly`, финальный аргумент `P ≠ NP`).
    *Проверка выполнена: `lake build` проходит после замены аксиомы на теорему.*

### Проверка полноты плана

> Обновление 2025-09-24: условия ниже теперь выполнены; раздел оставлен для исторического контекста и для будущих ревизий.

Чтобы ответить на практический вопрос «хватит ли текущего плана, чтобы закрыть доказательство», полезно явно перечислить зависимые места и ожидаемые выходы:

* **Прямолинейный шаг и линейный прирост.** После реализации `StraightConfig.step` нужно убедиться, что полученная оценка действительно имеет вид `Δ ≤ K ⋅ tapeLength`. Это центральная техническая точка; без неё переход к полиномиальной границе не состоится. План уже включает этот пункт (шаги 1–2), но важно заранее зафиксировать константу `K` и собрать леммы для индукции по числу шагов. 【F:Pnp2/PsubsetPpoly.lean†L3008-L3185】
* **Интеграция оценки по времени.** Когда появится линейная рекурсия, обязательно сформулировать отдельную лемму о суммировании по `Nat.iterate` и связать `runTime` с ограничением на длину ленты. Это обеспечит не только верхнюю грань на `totalGateCount`, но и сведёт работу по шагам 2–3 к одному индукционному утверждению. 【F:Pnp2/PsubsetPpoly.lean†L1001-L1130】
* **Финальная доминация полиномом.** После получения явной формулы вроде `K ⋅ tapeLength ⋅ runTime` нужно отследить, что используемые полиномиальные оценки для `runTime` и `tapeLength` действительно уже имеются в кодовой базе (или запланированы к добавлению). Тогда преобразование к форме `n^k + k` превращается в рутинную арифметику, и шаг 4 выполняется без дополнительных инсайтов. 【F:Pnp2/PsubsetPpoly.lean†L4994-L5245】
* **Закрытие аксиомы и обновление зависимостей.** В завершение следует перепроверить, что все места, где использовалась аксиома `P_subset_Ppoly`, действительно покрываются новой теоремой. Для прозрачности можно добавить краткий комментарий в `ComplexityClasses.lean`, фиксирующий источник уже доказанного результата. 【F:docs/master_blueprint.md†L20-L33】

Суммарно текущий план охватывает все необходимые этапы; дополнительных концептуальных дыр нет. Основное внимание требуется на аккуратную оценку прироста вентилей и на доведение её до стандартной полиномиальной формы. После этого оставшиеся шаги сводятся к уже предусмотренным пунктам плана, поэтому текущего списка задач достаточно для завершения формализации включения `P ⊆ P/poly`.

## Детальный план симуляции и контроля размера схем

Чтобы синхронизировать дальнейшие шаги с классическим доказательством, полезно держать в голове следующую «дорожную карту».

1. **Симуляция слоями.** Для машины `M`, работающей `T(n)` шагов, строится `T(n)` уровней схемы: входной слой кодирует начальную конфигурацию, каждый следующий слой реализует однократное применение `M.step`. В Lean это соответствует функции `stepCircuits`, формирующей новое семейство подцепей для ленты, головы и состояния. Уже доказанная корректность (`step_spec`, `iterate_spec`) обеспечивает точность симуляции, поэтому оставшиеся задачи носят чисто количественный характер. 【F:Pnp2/PsubsetPpoly.lean†L1001-L1130】【F:Pnp2/PsubsetPpoly.lean†L1119-L1174】
2. **Локальность перехода.** Переходный слой читает лишь локальные данные: одну ячейку ленты, индикатор головы и состояние. Благодаря этому каждая новая ячейка использует только константное число вентилей поверх уже построенных сигналов, а обновление головы и состояния разбивается на конечное число веток по парам `(q, b)`. Именно эти конструкции (например, `writeBit`, `nextHeadCircuit`, `nextStateCircuit`) определяют детальный «ценник» каждого шага симуляции. 【F:Pnp2/PsubsetPpoly.lean†L214-L399】【F:Pnp2/PsubsetPpoly.lean†L718-L903】
3. **Инкрементальный анализ.** При вычислении `gateCount` важно учитывать повторное использование уже построенных подцепей, иначе рекурсия даёт экспоненциальный рост. Цель — получить оценку вида `totalGateCount (stepCircuits cc) ≤ totalGateCount cc + poly(n)` и затем проинтегрировать её по `T(n)` слоям. В файле уже собраны промежуточные величины (`GateVector`, `stepBounds`), которые нужно «ослабить» до линейного вида, устраняя завышенные множители. 【F:Pnp2/PsubsetPpoly.lean†L3008-L3185】【F:Pnp2/PsubsetPpoly.lean†L3187-L3559】
4. **Финальная полиномиальная граница.** После оптимизации рекурсии следует пересобрать определение `gatePolyBound` и доказать, что новая формула подчиняется условию из `InPpoly` (существование единого `k`). Это откроет путь к вызову `inPpoly_of_polyBound` и снятию аксиомы `P_subset_Ppoly`. 【F:Pnp2/PsubsetPpoly.lean†L4994-L5245】

## Блокеры

На уровне симуляции Turing→circuit блокеров больше нет.  Основные риски перенесены в доказательство magnification и мост от FCE-леммы к `MCSP`.

## Рекомендуемые ресурсы

* Секция 6.1 книги Arora–Barak — даёт точные границы для симуляции машин схемами.
* Конспект Sipser, §9.3 — простая индукция по шагам с явными полиномиальными оценками.
* Обсуждение в `docs/np_not_p_poly_sketch.md` — краткое описание уже реализованных компонентов.
