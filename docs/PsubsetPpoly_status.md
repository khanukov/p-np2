# Состояние формализации включения `P ⊆ P/poly`

## Что уже реализовано

* Построены схемы, симулирующие пошаговую работу детерминированной одноленточной машины Тьюринга, и доказана корректность каждой подсхемы ("лента", "голова", "состояние") относительно конфигураций.
* Получены верхние оценки на число вентилей для всех вспомогательных блоков и собраны в единую рекуррентную оценку `affineIter`, контролирующую итерации `stepBounds`.
* Определён кандидат на итоговую оценку размера схем `gatePolyBound` вместе с леммами `sizeOf_acceptCircuit_le_gatePolyBound` и `inPpoly_of_polyBound`, которые сведут задачу к явной полиномиальной границе.
* Добавлена модель прямолинейных схем `StraightLineCircuit`, фиксирующая списки вентилей и позволяющая явно описывать повторное
использование промежуточных сигналов при переходе между слоями симуляции. 【F:Pnp2/Circuit/StraightLine.lean†L1-L117】
* Построена прямая конфигурация `StraightConfig.initial`, снабжённая корректностью относительно начальной конфигурации машины, что открывает путь к описанию шагов симуляции как добавления фиксированного числа DAG-вентилей. 【F:Pnp2/PsubsetPpoly.lean†L220-L360】
* Добавлен строитель `StraightLineCircuit.Builder`, который инкапсулирует последовательное добавление вентилей, выдаёт маркеры-провода с контролируемыми границами и переиспользует лемму `eval_snoc` для немедленного анализа семантики новых сигналов. Это подготовительный шаг к прямолинейному описанию одного шага машины. 【F:Pnp2/Circuit/StraightLine.lean†L305-L469】
* Расширен API строителя: добавлены варианты `appendFin`, обёртки для булевых вентилей, сводящиеся к новым индексам `Fin`, а также итератор `appendBigOr`, который аккуратно наращивает схемы для больших дизъюнкций и сопровождается леммой о корректности результата. Эти инструменты необходимы для построения «символа под головой» и других суммарных сигналов без потери шаринга. 【F:Pnp2/Circuit/StraightLine.lean†L470-L636】
* Введён «оценочный» билдер `StraightLineCircuit.EvalBuilder`, фиксирующий неизменность исходных проводов при добавлении вентилей и предоставляющий вспомогательные леммы для подъёма индексов. С его помощью построен прямолинейный символ (`symbolBuilder`) и доказано совпадение с настоящим битом под головкой. 【F:Pnp2/Circuit/StraightLine.lean†L640-L813】【F:Pnp2/PsubsetPpoly.lean†L360-L455】
* Добавлена упаковка `symbolBuilderWire`, переводящая построенный провод в токен `Wire`. Это упрощает дальнейшее наращивание схем: токен автоматически переиспользуется после добавления новых вентилей, а корректность завернута в отдельные леммы. 【F:Pnp2/Circuit/StraightLine.lean†L320-L356】【F:Pnp2/PsubsetPpoly.lean†L409-L471】
* Построен прямолинейный аналог ветвления по паре `(q, b)` (`branchBuilder` и `branchBuilderWire`), выдающий провод для условия "машина в состоянии `q` и читает бит `b`". Леммы `branchBuilder_spec` и `branchBuilderWire_spec` позволяют использовать его как строительный блок для будущих прямолинейных переходов. 【F:Pnp2/PsubsetPpoly.lean†L520-L747】
* Добавлен обобщённый конструктор `branchBuilderFrom`, который принимает заранее построенный провод символа и расширяет текущий
билдер без повторного вызова `symbolBuilder`. Лемма `branchBuilderFrom_spec` обеспечивает перенос корректности, что пригодится
 при наращивании прямолинейного шага. 【F:Pnp2/PsubsetPpoly.lean†L575-L803】
* Расширен API `EvalBuilder`: добавлен `appendBigOr`, позволяющий собирать дизъюнкцию произвольного списка проводов без потери инвариантов и снабжённый леммой `appendBigOr_eval`. Хелпер пригодится при построении прямолинейных версий `writeBit` и других суммарных сигналов. 【F:Pnp2/Circuit/StraightLine.lean†L600-L723】
* Уточнены леммы о сохранении семантики при добавлении вентилей: `append_evalWire_preserved` и `appendFin_evalWire_preserved` гарантируют, что ранее построенные токены `Wire` продолжают обозначать те же булевы функции после каждого `snoc`. Это подготовительный шаг к корректности прямолинейных снапшотов. 【F:Pnp2/Circuit/StraightLine.lean†L724-L779】
* Построен «снимок» прямолинейной конфигурации `branchSnapshot`, который материализует провод символа и список ветвей `(q, b)` с контролем индексов, а также `writeSnapshot`, добавляющий провод записываемого бита и фиксирующий монотонность `appendBigOr`. 【F:Pnp2/PsubsetPpoly.lean†L730-L935】
* Сформулированы конфигурационные аналоги `branchGuard`, `writeContribution` и `writeAccumulator`, описывающие дизъюнктивное объединение ветвей переходов на уровне булевой семантики. Леммы `writeContribution_spec`, `writeAccumulator_eq_any` и `writeAccumulator_spec` связывают эти определения с таблицей переходов и подготавливают почву для корректности прямолинейного `writeBit`. 【F:Pnp2/PsubsetPpoly.lean†L858-L997】
## Основные пробелы

1. **Отсутствует прямолинейный шаг.** Пока описана только стартовая конфигурация DAG, нужно реализовать `StraightConfig.step`, аккумулирующий новые константы и повторно использующий существующие провода. Необходимо доказать его корректность и линейный прирост числа вентилей и затем сопоставить с деревом `ConfigCircuits`.
2. **Грубость аффинной рекурсии.** Текущая оценка `totalBound_stepBounds_le_affine` даёт рост вида\n  \n    X_{t+1} \le A(n) \cdot X_t + B(n),\n  \n  где `A(n)` полиномиальна по длине входа. При подстановке в закрытую форму получаем выражения `A(n)^{poly(n)}`, что существенно превышает требуемый полиномиальный масштаб. Необходима более тонкая оценка, показывающая, что вклад предыдущей конфигурации растёт только линейно (или с постоянным коэффициентом), иначе не получится доказать `gatePolyBound ≤ n^k + k`.
3. **Отсутствие явной полиномиальной границы.** Лемма `gatePolyBound_le_dominantBase_pow` всё ещё содержит показатель степени, линейный по `dominantBase`. При нынешних оценках это приводит к суперполиномиальному росту. Требуется:
   * либо пересмотреть определение `gatePolyBound`,
   * либо существенно ужесточить промежуточные оценки (`affineFactor`, `affineOffset`), чтобы показатель степени стал константой (зависящей лишь от машины).
4. **Закрытие аксиомы.** После получения `∃ k, ∀ n, gatePolyBound ≤ n^k + k` нужно построить `InPpoly` и заменить аксиому `ComplexityClasses.P_subset_Ppoly` настоящей теоремой, обновив зависимости в `NP_separation.lean` и документации.

## План дальнейших действий

1. Сформулировать и реализовать прямолинейный шаг `StraightConfig.step`, аккумулирующий новые константы и повторно использующий существующие провода; доказать `Spec`-лемму и явную оценку на прирост числа вентилей.
2. Перепроверить `stepBounds`: вычислить точные коэффициенты зависимости каждой компоненты от предыдущей и попытаться показать, что `totalBound` растёт как `X_{t+1} ≤ X_t + poly(n)`. Это сведёт задачу к суммированию по времени `runTime n` и даст прямую полиномиальную оценку.
3. Если уточнение прямо через `totalBound` неудобно, рассмотреть по компонентам (`tape`, `head`, `state`) и доказать отдельные линейные рекурсии, чьи решения явно полиномиальны.
4. После получения адекватной границы пересобрать финальный участок (`gatePolyBound`, `dominantBase`) и доказать лемму вида `∃ k, ∀ n, gatePolyBound ≤ (n + C)^k`, а затем — стандартное неравенство `≤ n^k + k`.
5. Инстанцировать `inPpoly_of_polyBound`, сформулировать и доказать теорему `P_subset_Ppoly` без использования аксиомы, удалить её из `ComplexityClasses.lean` и обновить связанные файлы.

## Детальный план симуляции и контроля размера схем

Чтобы синхронизировать дальнейшие шаги с классическим доказательством, полезно держать в голове следующую «дорожную карту».

1. **Симуляция слоями.** Для машины `M`, работающей `T(n)` шагов, строится `T(n)` уровней схемы: входной слой кодирует начальную конфигурацию, каждый следующий слой реализует однократное применение `M.step`. В Lean это соответствует функции `stepCircuits`, формирующей новое семейство подцепей для ленты, головы и состояния. Уже доказанная корректность (`step_spec`, `iterate_spec`) обеспечивает точность симуляции, поэтому оставшиеся задачи носят чисто количественный характер. 【F:Pnp2/PsubsetPpoly.lean†L1001-L1130】【F:Pnp2/PsubsetPpoly.lean†L1119-L1174】
2. **Локальность перехода.** Переходный слой читает лишь локальные данные: одну ячейку ленты, индикатор головы и состояние. Благодаря этому каждая новая ячейка использует только константное число вентилей поверх уже построенных сигналов, а обновление головы и состояния разбивается на конечное число веток по парам `(q, b)`. Именно эти конструкции (например, `writeBit`, `nextHeadCircuit`, `nextStateCircuit`) определяют детальный «ценник» каждого шага симуляции. 【F:Pnp2/PsubsetPpoly.lean†L214-L399】【F:Pnp2/PsubsetPpoly.lean†L718-L903】
3. **Инкрементальный анализ.** При вычислении `gateCount` важно учитывать повторное использование уже построенных подцепей, иначе рекурсия даёт экспоненциальный рост. Цель — получить оценку вида `totalGateCount (stepCircuits cc) ≤ totalGateCount cc + poly(n)` и затем проинтегрировать её по `T(n)` слоям. В файле уже собраны промежуточные величины (`GateVector`, `stepBounds`), которые нужно «ослабить» до линейного вида, устраняя завышенные множители. 【F:Pnp2/PsubsetPpoly.lean†L3008-L3185】【F:Pnp2/PsubsetPpoly.lean†L3187-L3559】
4. **Финальная полиномиальная граница.** После оптимизации рекурсии следует пересобрать определение `gatePolyBound` и доказать, что новая формула подчиняется условию из `InPpoly` (существование единого `k`). Это откроет путь к вызову `inPpoly_of_polyBound` и снятию аксиомы `P_subset_Ppoly`. 【F:Pnp2/PsubsetPpoly.lean†L4994-L5245】

## Блокеры

* Необходим тщательный аудит суммарных оценок: текущие коэффициенты явно завышены. Возможно, стоит ввести более структурированное описание конфигураций (например, вести счетчики по "новым" вентилям, а не абсолютное количество).
* Прежде чем оптимизировать Lean-код, полезно на бумаге проделать расчёт для классического доказательства (Gate-count ≤ `(n + T(n))^{O(1)}`) и перенести формулы в Lean.

## Рекомендуемые ресурсы

* Секция 6.1 книги Arora–Barak — даёт точные границы для симуляции машин схемами.
* Конспект Sipser, §9.3 — простая индукция по шагам с явными полиномиальными оценками.
* Обсуждение в `docs/np_not_p_poly_sketch.md` — краткое описание уже реализованных компонентов.
