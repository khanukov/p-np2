# Состояние формализации включения `P ⊆ P/poly`

## Что уже реализовано

* Построены схемы, симулирующие пошаговую работу детерминированной одноленточной машины Тьюринга, и доказана корректность каждой подсхемы ("лента", "голова", "состояние") относительно конфигураций.
* Получены верхние оценки на число вентилей для всех вспомогательных блоков и собраны в единую рекуррентную оценку `affineIter`, контролирующую итерации `stepBounds`.
* Определён кандидат на итоговую оценку размера схем `gatePolyBound` вместе с леммами `sizeOf_acceptCircuit_le_gatePolyBound` и `inPpoly_of_polyBound`, которые сведут задачу к явной полиномиальной границе.
* Добавлена модель прямолинейных схем `StraightLineCircuit`, фиксирующая списки вентилей и позволяющая явно описывать повторное
использование промежуточных сигналов при переходе между слоями симуляции. 【F:Pnp2/Circuit/StraightLine.lean†L1-L117】
* Построена прямая конфигурация `StraightConfig.initial`, снабжённая корректностью относительно начальной конфигурации машины, что открывает путь к описанию шагов симуляции как добавления фиксированного числа DAG-вентилей. 【F:Pnp2/PsubsetPpoly.lean†L220-L360】
* Добавлен строитель `StraightLineCircuit.Builder`, который инкапсулирует последовательное добавление вентилей, выдаёт маркеры-провода с контролируемыми границами и переиспользует лемму `eval_snoc` для немедленного анализа семантики новых сигналов. Это подготовительный шаг к прямолинейному описанию одного шага машины. 【F:Pnp2/Circuit/StraightLine.lean†L305-L469】
* Расширен API строителя: добавлены варианты `appendFin`, обёртки для булевых вентилей, сводящиеся к новым индексам `Fin`, а также итератор `appendBigOr`, который аккуратно наращивает схемы для больших дизъюнкций и сопровождается леммой о корректности результата. Эти инструменты необходимы для построения «символа под головой» и других суммарных сигналов без потери шаринга. 【F:Pnp2/Circuit/StraightLine.lean†L470-L636】
* Введён «оценочный» билдер `StraightLineCircuit.EvalBuilder`, фиксирующий неизменность исходных проводов при добавлении вентилей и предоставляющий вспомогательные леммы для подъёма индексов. С его помощью построен прямолинейный символ (`symbolBuilder`) и доказано совпадение с настоящим битом под головкой. 【F:Pnp2/Circuit/StraightLine.lean†L640-L813】【F:Pnp2/PsubsetPpoly.lean†L360-L455】
* Добавлена упаковка `symbolBuilderWire`, переводящая построенный провод в токен `Wire`. Это упрощает дальнейшее наращивание схем: токен автоматически переиспользуется после добавления новых вентилей, а корректность завернута в отдельные леммы. 【F:Pnp2/Circuit/StraightLine.lean†L320-L356】【F:Pnp2/PsubsetPpoly.lean†L409-L471】
* Построен прямолинейный аналог ветвления по паре `(q, b)` (`branchBuilder` и `branchBuilderWire`), выдающий провод для условия "машина в состоянии `q` и читает бит `b`". Леммы `branchBuilder_spec` и `branchBuilderWire_spec` позволяют использовать его как строительный блок для будущих прямолинейных переходов. 【F:Pnp2/PsubsetPpoly.lean†L520-L747】
* Добавлен обобщённый конструктор `branchBuilderFrom`, который принимает заранее построенный провод символа и расширяет текущий
билдер без повторного вызова `symbolBuilder`. Лемма `branchBuilderFrom_spec` обеспечивает перенос корректности, что пригодится
 при наращивании прямолинейного шага. 【F:Pnp2/PsubsetPpoly.lean†L575-L803】
* Расширен API `EvalBuilder`: добавлен `appendBigOr`, позволяющий собирать дизъюнкцию произвольного списка проводов без потери инвариантов и снабжённый леммой `appendBigOr_eval`. Хелпер пригодится при построении прямолинейных версий `writeBit` и других суммарных сигналов. 【F:Pnp2/Circuit/StraightLine.lean†L600-L723】
* Уточнены леммы о сохранении семантики при добавлении вентилей: `append_evalWire_preserved` и `appendFin_evalWire_preserved` гарантируют, что ранее построенные токены `Wire` продолжают обозначать те же булевы функции после каждого `snoc`. Это подготовительный шаг к корректности прямолинейных снапшотов. 【F:Pnp2/Circuit/StraightLine.lean†L724-L779】
* Построен «снимок» прямолинейной конфигурации `branchSnapshot`, который материализует провод символа и список ветвей `(q, b)` с контролем индексов, а также `writeSnapshot`, добавляющий провод записываемого бита и фиксирующий монотонность `appendBigOr`. 【F:Pnp2/PsubsetPpoly.lean†L730-L935】
* Зафиксирован инвариант `branchBuilderFrom_preserves_eval`, гарантирующий, что добавление очередной ветви не искажает значения уже построенных проводов; он будет использован при формализации корректности снапшотов и шага. 【F:Pnp2/PsubsetPpoly.lean†L720-L835】
* Доказаны спецификации `branchSnapshot_spec` и `writeSnapshot_spec`: первый утверждает, что все записанные ветви вычисляют охрану `branchGuard`, второй — что итоговый провод `write` совпадает с аккумулятором `writeAccumulator`. Это закрывает семантические пробелы перед реализацией прямолинейного шага. 【F:Pnp2/PsubsetPpoly.lean†L1360-L1900】
* Сформулированы конфигурационные аналоги `branchGuard`, `writeContribution` и `writeAccumulator`, описывающие дизъюнктивное объединение ветвей переходов на уровне булевой семантики. Леммы `writeContribution_spec`, `writeAccumulator_eq_any` и `writeAccumulator_spec` связывают эти определения с таблицей переходов и подготавливают почву для корректности прямолинейного `writeBit`. 【F:Pnp2/PsubsetPpoly.lean†L858-L997】
* Построен лентный снапшот `tapeSnapshot`, аккумулирующий провода для каждой ячейки и связывающий их со значениями `TM.stepConfig` через лемму `tapeSnapshot_step_spec`. Это завершает семантическую картину для прямолинейного обновления ленты перед интеграцией в `StraightConfig.step`. 【F:Pnp2/PsubsetPpoly.lean†L1504-L2334】
* Получена точная линейная оценка `tapeSnapshot_gate_le`, показывающая, что построение снапшота добавляет не более `4 ⋅ tapeLength` вентилей сверх `writeSnapshot`. Это фиксирует рост лентной части прямолинейной схемы и делает шаг к глобальной рекурсии по числу вентилей. 【F:Pnp2/PsubsetPpoly.lean†L2604-L2707】
## Основные пробелы

1. **Отсутствует прямолинейный шаг.** Пока описана только стартовая конфигурация DAG, нужно реализовать `StraightConfig.step`, аккумулирующий новые константы и повторно использующий существующие провода. Необходимо доказать его корректность и линейный прирост числа вентилей и затем сопоставить с деревом `ConfigCircuits`.
2. **Грубость аффинной рекурсии.** Текущая оценка `totalBound_stepBounds_le_affine` даёт рост вида\n  \n    X_{t+1} \le A(n) \cdot X_t + B(n),\n  \n  где `A(n)` полиномиальна по длине входа. При подстановке в закрытую форму получаем выражения `A(n)^{poly(n)}`, что существенно превышает требуемый полиномиальный масштаб. Необходима более тонкая оценка, показывающая, что вклад предыдущей конфигурации растёт только линейно (или с постоянным коэффициентом), иначе не получится доказать `gatePolyBound ≤ n^k + k`.
3. **Отсутствие явной полиномиальной границы.** Лемма `gatePolyBound_le_dominantBase_pow` всё ещё содержит показатель степени, линейный по `dominantBase`. При нынешних оценках это приводит к суперполиномиальному росту. Требуется:
   * либо пересмотреть определение `gatePolyBound`,
   * либо существенно ужесточить промежуточные оценки (`affineFactor`, `affineOffset`), чтобы показатель степени стал константой (зависящей лишь от машины).
4. **Закрытие аксиомы.** После получения `∃ k, ∀ n, gatePolyBound ≤ n^k + k` нужно построить `InPpoly` и заменить аксиому `ComplexityClasses.P_subset_Ppoly` настоящей теоремой, обновив зависимости в `NP_separation.lean` и документации.

## План дальнейших действий

1. Сформулировать и реализовать прямолинейный шаг `StraightConfig.step`, аккумулирующий новые константы и повторно использующий существующие провода; доказать `Spec`-лемму и явную оценку на прирост числа вентилей.
2. Перепроверить `stepBounds`: вычислить точные коэффициенты зависимости каждой компоненты от предыдущей и попытаться показать, что `totalBound` растёт как `X_{t+1} ≤ X_t + poly(n)`. Это сведёт задачу к суммированию по времени `runTime n` и даст прямую полиномиальную оценку.
3. Если уточнение прямо через `totalBound` неудобно, рассмотреть по компонентам (`tape`, `head`, `state`) и доказать отдельные линейные рекурсии, чьи решения явно полиномиальны.
4. После получения адекватной границы пересобрать финальный участок (`gatePolyBound`, `dominantBase`) и доказать лемму вида `∃ k, ∀ n, gatePolyBound ≤ (n + C)^k`, а затем — стандартное неравенство `≤ n^k + k`.
5. Инстанцировать `inPpoly_of_polyBound`, сформулировать и доказать теорему `P_subset_Ppoly` без использования аксиомы, удалить её из `ComplexityClasses.lean` и обновить связанные файлы.

### Развёрнутый чеклист реализации

Ниже собран минимальный набор технических пунктов, который нужно закрыть, чтобы план выше превратился в рабочий Lean-код. Формат чекбоксов позволяет отслеживать прогресс прямо в репозитории.

- [ ] **Прямолинейный шаг (`StraightConfig.step`).**
  - [ ] Реализовать функцию `StraightConfig.step` в `Pnp2/PsubsetPpoly.lean`, используя `StraightLineCircuit.Builder` для аккумулирования вентилей без дублирования существующих проводов.
  - [ ] Построить вспомогательные билдеры `nextTapeBuilder`, `nextHeadBuilder`, `nextStateBuilder`, которые поверх снапшотов (`branchSnapshot`, `writeSnapshot`) возвращают новые токены `Wire` с контролем индексов.
    - [x] Прямая реализация лентного снапшота `tapeSnapshot` с леммой `tapeSnapshot_step_spec`, связывающей полученные провода с лентой `TM.stepConfig`.
  - [x] Построить прямолинейный конвейер для одной ячейки ленты (`tapeBuilderStep`), доказав корректность вычисления `(head ∧ write) ∨ (!head ∧ tape)` и точный прирост на четыре вентиля. 【F:Pnp2/PsubsetPpoly.lean†L1889-L2133】
  - [ ] Сконструировать вспомогательный билдер `headBranchBuilder`, который для каждой ветви `(q, b)` материализует провода `branch ∧ headᵢ` и фиксирует их длину и прирост числа вентилей.
  - [ ] На основе `headBranchBuilder` построить список вкладов `headContributionIndices`, отфильтрованный по целевому индексу головы и готовый к передаче в `appendBigOr`.
  - [ ] Доказать лемму `StraightConfig.step_spec`, переносящую `Spec` по аналогии со `step_spec`, но через прямолинейный API (использовать `append_evalWire_preserved`, `appendBigOr_eval`).
  - [ ] Добавить лемму `StraightConfig.step_gateGrowth` вида `gateCount (StraightConfig.step …) ≤ gateCount … + K ⋅ M.tapeLength n` с явной константой `K`; в доказательстве задокументировать вклад каждой подсхемы.
  - [x] Получить явные линейные границы на вспомогательные снапшоты (`branchSnapshot_gate_le`, `writeSnapshot_gate_le`, `tapeSnapshot_gate_le`), чтобы подготовить анализ шага.

- [ ] **Линейная рекурсия по количеству вентилей.**
  - [ ] Ввести числовую инварианту `straightTotalGateCount` и доказать, что переход к `StraightConfig.step` увеличивает её не более чем на `K ⋅ M.tapeLength n`.
  - [ ] Связать `straightTotalGateCount` с уже существующей `totalGateCount` через перевод `StraightConfig` → `ConfigCircuits` (обе стороны должны получать одинаковые суммы за счёт шаринга проводов).
  - [ ] Сформулировать и доказать индуктивную лемму `straightGateCount_iterate_le`, применяющую предыдущий пункт к `Nat.iterate` и дающую оценку `≤ gateCount initial + K ⋅ M.tapeLength n ⋅ t`.

- [ ] **Полиномиальное доминирование.**
  - [ ] Получить явные неравенства `M.tapeLength n ≤ (n + 1) ^ c₁` и `M.runTime n ≤ (n + 1) ^ c₂` из существующих лемм (`runTime_le_polyBase`, вспомогательные утверждения про движение головы) или добавить их при необходимости.
  - [ ] Из леммы `straightGateCount_iterate_le` вывести верхнюю грань на `totalGateCount (runtimeCircuits M n)` вида `≤ K' ⋅ (n + 1)^{c₁ + c₂}` и переписать её в формате `n^k + k` (с явным `k` и доказательством для всех `n`).
  - [ ] Обновить доказательство `sizeOf_acceptCircuit_le_gatePolyBound`, заменив `gatePolyBound` на новую компактную оценку или, при сохранении `gatePolyBound`, показать её доминацию полученной формулой.

- [ ] **Снятие аксиомы.**
  - [ ] Переписать `ComplexityClasses.lean`, заменив ссылку на аксиому `P_subset_Ppoly` на новую теорему `PsubsetPpoly.main` (или аналогично названное утверждение).
  - [ ] Обновить `docs/master_blueprint.md`, TODO-лист и связанные разделы документации, отражая факт, что аксиома снята и оценивая зависимости других файлов.
  - [ ] Прогнать `lake build` / `lean --make` и убедиться, что удаление аксиомы не ломает существующие теоремы (`NP_not_in_P_poly`, финальный аргумент `P ≠ NP`).

### Проверка полноты плана

Чтобы ответить на практический вопрос «хватит ли текущего плана, чтобы закрыть доказательство», полезно явно перечислить зависимые места и ожидаемые выходы:

* **Прямолинейный шаг и линейный прирост.** После реализации `StraightConfig.step` нужно убедиться, что полученная оценка действительно имеет вид `Δ ≤ K ⋅ tapeLength`. Это центральная техническая точка; без неё переход к полиномиальной границе не состоится. План уже включает этот пункт (шаги 1–2), но важно заранее зафиксировать константу `K` и собрать леммы для индукции по числу шагов. 【F:Pnp2/PsubsetPpoly.lean†L3008-L3185】
* **Интеграция оценки по времени.** Когда появится линейная рекурсия, обязательно сформулировать отдельную лемму о суммировании по `Nat.iterate` и связать `runTime` с ограничением на длину ленты. Это обеспечит не только верхнюю грань на `totalGateCount`, но и сведёт работу по шагам 2–3 к одному индукционному утверждению. 【F:Pnp2/PsubsetPpoly.lean†L1001-L1130】
* **Финальная доминация полиномом.** После получения явной формулы вроде `K ⋅ tapeLength ⋅ runTime` нужно отследить, что используемые полиномиальные оценки для `runTime` и `tapeLength` действительно уже имеются в кодовой базе (или запланированы к добавлению). Тогда преобразование к форме `n^k + k` превращается в рутинную арифметику, и шаг 4 выполняется без дополнительных инсайтов. 【F:Pnp2/PsubsetPpoly.lean†L4994-L5245】
* **Закрытие аксиомы и обновление зависимостей.** В завершение следует перепроверить, что все места, где использовалась аксиома `P_subset_Ppoly`, действительно покрываются новой теоремой. Для прозрачности можно добавить краткий комментарий в `ComplexityClasses.lean`, фиксирующий источник уже доказанного результата. 【F:docs/master_blueprint.md†L20-L33】

Суммарно текущий план охватывает все необходимые этапы; дополнительных концептуальных дыр нет. Основное внимание требуется на аккуратную оценку прироста вентилей и на доведение её до стандартной полиномиальной формы. После этого оставшиеся шаги сводятся к уже предусмотренным пунктам плана, поэтому текущего списка задач достаточно для завершения формализации включения `P ⊆ P/poly`.

## Детальный план симуляции и контроля размера схем

Чтобы синхронизировать дальнейшие шаги с классическим доказательством, полезно держать в голове следующую «дорожную карту».

1. **Симуляция слоями.** Для машины `M`, работающей `T(n)` шагов, строится `T(n)` уровней схемы: входной слой кодирует начальную конфигурацию, каждый следующий слой реализует однократное применение `M.step`. В Lean это соответствует функции `stepCircuits`, формирующей новое семейство подцепей для ленты, головы и состояния. Уже доказанная корректность (`step_spec`, `iterate_spec`) обеспечивает точность симуляции, поэтому оставшиеся задачи носят чисто количественный характер. 【F:Pnp2/PsubsetPpoly.lean†L1001-L1130】【F:Pnp2/PsubsetPpoly.lean†L1119-L1174】
2. **Локальность перехода.** Переходный слой читает лишь локальные данные: одну ячейку ленты, индикатор головы и состояние. Благодаря этому каждая новая ячейка использует только константное число вентилей поверх уже построенных сигналов, а обновление головы и состояния разбивается на конечное число веток по парам `(q, b)`. Именно эти конструкции (например, `writeBit`, `nextHeadCircuit`, `nextStateCircuit`) определяют детальный «ценник» каждого шага симуляции. 【F:Pnp2/PsubsetPpoly.lean†L214-L399】【F:Pnp2/PsubsetPpoly.lean†L718-L903】
3. **Инкрементальный анализ.** При вычислении `gateCount` важно учитывать повторное использование уже построенных подцепей, иначе рекурсия даёт экспоненциальный рост. Цель — получить оценку вида `totalGateCount (stepCircuits cc) ≤ totalGateCount cc + poly(n)` и затем проинтегрировать её по `T(n)` слоям. В файле уже собраны промежуточные величины (`GateVector`, `stepBounds`), которые нужно «ослабить» до линейного вида, устраняя завышенные множители. 【F:Pnp2/PsubsetPpoly.lean†L3008-L3185】【F:Pnp2/PsubsetPpoly.lean†L3187-L3559】
4. **Финальная полиномиальная граница.** После оптимизации рекурсии следует пересобрать определение `gatePolyBound` и доказать, что новая формула подчиняется условию из `InPpoly` (существование единого `k`). Это откроет путь к вызову `inPpoly_of_polyBound` и снятию аксиомы `P_subset_Ppoly`. 【F:Pnp2/PsubsetPpoly.lean†L4994-L5245】

## Блокеры

* Необходим тщательный аудит суммарных оценок: текущие коэффициенты явно завышены. Возможно, стоит ввести более структурированное описание конфигураций (например, вести счетчики по "новым" вентилям, а не абсолютное количество).
* Прежде чем оптимизировать Lean-код, полезно на бумаге проделать расчёт для классического доказательства (Gate-count ≤ `(n + T(n))^{O(1)}`) и перенести формулы в Lean.

## Рекомендуемые ресурсы

* Секция 6.1 книги Arora–Barak — даёт точные границы для симуляции машин схемами.
* Конспект Sipser, §9.3 — простая индукция по шагам с явными полиномиальными оценками.
* Обсуждение в `docs/np_not_p_poly_sketch.md` — краткое описание уже реализованных компонентов.
