# План доказательства `decisionTree_cover`

Документ описывает текущий прогресс и дальнейшие шаги по замене аксиомы
`LowSensitivityCover.decisionTree_cover` полноценным формальным доказательством.
Во всех рассуждениях допускается использование классической логики и аксиомы
выбора.

## Состояние проекта

- В `low_sensitivity_cover.lean` утверждение `decisionTree_cover` оформлено как
`theorem` с пока недостающим доказательством (`sorry`) и уже сформулировано
в точечном виде: для каждого прямоугольника требуется монохромность относительно
каждой функции семейства.
- Реализованы базовые структуры: `Family`, `DecisionTree`, `Subcube`,
  `FamilyCover`.
- Доказаны вспомогательные леммы:
  - `DecisionTree.leaf_count_le_pow_depth`;
  - `H₂_restrict_le`;
  - `sunflower_exists_classic`;
 - набор фактов о мере: `measure_restrict_le`, `measure_filter_le`,
    `measure_empty`, `measure_singleton`, `measure_pos_of_card_two_le`,
    `measure_restrict_lt_of_card_le_half`, `measure_filter_lt_of_card_le_half`.
- Существует каркас для объединения покрытий (`merge_low_sens.lean`) и
  добавлены леммы `merge_card_le_low_sens` и `merge_card_le_entropy` для оценки
  числа субкубов в объединённом покрытии; зафиксирована безопасная константа
  `C = 10` (`BoolFunc.coverConst`) для всех асимптотических оценок.
- Доказана лемма `buildCover_card_bound`; теперь `cover_exists_bound` и
  `FamilyCover` усилены до явной оценки `mBound`, и `entropyCover`
  строит покрытие с ограничением `≤ mBound n h` при условии
  `Fintype.card (Subcube n) ≤ mBound n h`.
- В модуле `cover_numeric.lean` временная аксиома `buildCover_card_le_pow2`
  заменена на доказанную лемму, так что оценка числа точек больше не
  зависит от дополнительных допущений.
- Ранее в `low_sensitivity_cover.lean` случай `A = ∅` обрабатывался через
  `entropyCover`; теперь лемма `nonconstant_all_insensitive_false` показывает,
  что такая ситуация противоречива при наличии функций, достигающих `true`,
  поэтому обращение к `entropyCover` больше не требуется.

- Разработана структура `CoverRes`, упаковывающая набор субкубов вместе с
  доказательствами монохроматичности, полноты и ограничением мощности.
  Базовые случаи реализованы конструкторами `CoverRes.empty` и
  `CoverRes.const`; лемма `CoverRes.as_cover` позволяет ослаблять оценку на
  число прямоугольников.  Выяснилось, что требование семейной
  монохроматичности слишком жёсткое: оно несовместимо с одновременным
  присутствием в семье тождественно ложной функции и функции, принимающей
  значение `true`.  Для дальнейших шагов введена ослабленная структура
  `CoverResP`, в которой для каждого прямоугольника требуются лишь
  точечные свидетельства константности всех функций семейства.
- Определение `CoverResP.toDecisionTree_for` преобразует покрытие в дерево
  решений для конкретной функции; леммы `CoverResP.leaf_count_le`,
  `CoverResP.depth_le_card_mul` и `CoverResP.depth_le_coverConst` связывают
  параметры дерева с оценкой размера покрытия.
 - Все регрессионные примеры собраны в модуле `test/CoverResBaseTest.lean`,
    который подключён к `lake test`. Добавлен пример, проверяющий корректность
    `CoverResP.toDecisionTree_for` на константной семье, тест на работу
    `CoverResP.lift_erase_false` при возвращении тождественно ложной функции,
    проверка склейки ветвей через `glue_branch_coversPw` на одноразрядной
    идентичной функции, новый пример, демонстрирующий спад меры
    `measureLex3` при ветвлении по чувствительной координате, а также тесты
    для лемм `budget_pos_of_sensitive` и `no_sensitive_of_budget_zero`.
- Принято решение отказаться от семейной монохромности и использовать
  **точечную**: каждый прямоугольник остаётся константным для каждой функции
  отдельно, но цвета могут различаться. Для построения дерева решений введена
  функция `CoverResP.toDecisionTree_for`, которая раскрашивает листья под
  конкретную функцию без изменения общей структуры.
- Новая обёртка `decisionTree_cover_of_coverResP` позволяет напрямую
  превращать структуру `CoverResP` в существование покрытия в формулировке
  теоремы. Базовые случаи `decisionTree_cover_of_constant` и
  `decisionTree_cover_empty` теперь выражены через неё.
- Лемма `decisionTree_cover_of_buildCover` объединяет рекурсивный конструктор
  `buildCoverLex3` с обёрткой `decisionTree_cover_of_coverResP`, напрямую
  предоставляя покрытие, соответствующее численной оценке теоремы.
- В рекурсивной функции `buildCoverLex3A` временно применяется аксиома
  временная аксиома `no_sensitive_at_zero`, утверждавшая, что при исчерпании
  бюджета `h` внутри множества `A` не остаётся чувствительных координат, если
  их не было снаружи. Теперь этот пробел закрыт: `buildCoverLex3A` получает
  дополнительный инвариант `A.card ≤ h`.  Ветка `h = 0` обрабатывается явно:
  из `A.card ≤ 0` выводится `A = ∅`, после чего отсутствию чувствительных
  координат соответствует тривиальное покрытие одного субкуба.  При `h > 0`
  лемма `budget_pos_of_sensitive` гарантирует положительный бюджет при
  нахождении чувствительной координаты.  Её простое следствие
  `no_sensitive_of_budget_zero` подтверждает, что при нулевом бюджете внутри
  `A` чувствительных координат быть не может; для полного множества координат
  сформулировано специализированное следствие `no_sensitive_of_budget_zero_univ`.
  Рекурсия более не опирается на недоказанные утверждения.

## Ключевые вопросы и текущий статус

1. **Энтропийная оценка**
 *Сделано:* введена мера `measure F = Nat.ceil (H₂ F)` и принято безопасное
  ограничение `measure F ≤ 10 · s · log₂(n+1)`. Грубая граница из леммы
  `buildCover_card_bound` остаётся в силе, но теперь подготовлен отдельный
  документ `asymptotic_cover_estimates.md`, где эта граница сведена к
  асимптотическим формам `2^{C⋅h}` и `(n+1)^{O(s)}`, согласующимся с
  результатами Gopalan–Moshковitz–Oliveira. Дополнительно леммы
  `cover_exists_mBound`, `coverFamily_card_le_mBound` и обновлённая
  `entropyCover` связывают эти оценки с каноническим покрытием в коде.

2. **Строгое уменьшение меры**
 *Сделано:* леммы `measure_restrict_le`, `measure_restrict_decreases`,
 `measure_restrict_lt_of_card_le_half` и `measure_filter_lt_of_card_le_half`
 показывают падение меры при существенном уменьшении семейства. Добавлена
 оценка `card_le_mul_card_restrict`, ограничивающая размер семейства через
 произведение размеров обеих ветвей при фиксировании координаты. Новые
 результаты `measureLex3_restrict_lt_of_restrict_eq` и
 `measureLex3_restrict_lt_of_card_le_half` переводят эти уменьшения на тройную
 меру `measureLex3`, а лемма `exists_branch_measure_drop_of_sensitive` гарантирует
 спад меры при выборе чувствительной координаты. Добавлена специализированная
 версия `exists_branch_measure_drop_univ`, упрощающая работу со всем набором
 координат сразу. Введены явные операции `restrictDrop` и `extendDrop`,
 моделирующие фиксирование чувствительной координаты и последующее
 восстановление субкуба; леммы `measureLex3_restrictDrop_lt` и
 `measureLex3_restrictDrop_univ_lt` формализуют строгое убывание меры при
 такой операции. Дополнительно этап склейки ветвей (`extend_union_cover` и его
 точечная версия) переписан через `extendDrop`, подчёркивая симметрию с
 `restrictDrop` и подготавливая интеграцию ветвления в рекурсивный алгоритм.
  *Сделано:* эти оценки встроены в рекурсивный алгоритм `buildCoverLex3`.
  Ветвление по чувствительной координате использует `restrictDrop` и
  `glue_branch_coversPw_mBound`, а леммы `measureLex3_restrictDrop_lt` и
  `measureLex3_restrictDrop_univ_lt` фиксируют спад тройной меры в обеих
  ветвях.

3. **Выбор чувствительного бита**
   *Сделано:* лемма `non_constant_family_has_sensitive_coord` находит
   чувствительную координату после удаления тождественно ложных функций;
  подготовлены базовые случаи `CoverResP.empty` и `CoverResP.const`, а также
 лемма `glue_branch_coversPw`, нормализующая покрытия ветвей и объединяющая
  их в точечном формате.
  В текущей версии чувствительный случай обрабатывается упрощённо:
  для каждой ветви строится точечное покрытие (`pointCover`), после чего
  результаты склеиваются через `glue_branch_coversPw_mBound`.  Полноценная
  рекурсивная реализация с последующим уменьшением множества координат
  запланирована на следующих этапах.

4. **Монадическое построение дерева**
   *Сделано:* разработана стратегия: сначала строится покрытие субкубами, затем
  оно переводится в `DecisionTree`. Введена функция `CoverResP.toDecisionTree_for`,
  окрашивающая листья под выбранную функцию, и доказаны леммы
  `CoverRes.eval_true`, `CoverRes.eval_false`,
  `CoverResP.leaf_count_le`, `CoverResP.depth_le_card_mul`,
  `CoverResP.depth_le_coverConst`, `CoverResP.eval_true` и
  `CoverResP.eval_false`, демонстрирующие корректность дерева и его связь
  с мощностью покрытия.
  *Осталось:* для каждой `f ∈ F` использовать построенное дерево в доказательстве
  `decisionTree_cover` и связать его глубину с энтропийной оценкой.

5. **Оценка глубины**  
   *Сделано:* лемма `DecisionTree.leaf_count_le_pow_depth` связывает число
   листьев с глубиной.  
   *Осталось:* связать её с энтропийной мерой и доказать
   `depth ≤ C · s · log₂(n+1)` по завершении рекурсии.

6. **Оптимизация стиля**  
   *Сделано:* многие технические шаги вынесены во вспомогательные леммы,
   упрощающие основное доказательство.  
   *Осталось:* продолжить рефакторинг, чтобы `decisionTree_cover` оставалась
   короткой и концептуальной.

  7. **Гарантия терминирования**
    *Сделано:* тройная мера `measureLex3` обеспечивает строгий спад как при
    удалении тождественно `false` функций, так и при ветвлении по чувствительной
    координате.  В рекурсивной функции `buildCoverLex3A` параметр множества
    координат `A` сокращается до `A.erase i`, а энтропийный бюджет `h` уменьшается
    на каждом шаге, что делает рекурсию по мере хорошо основанной. Леммы
    `measureLex3_erase_lt` и `measureLex3_restrictDrop_lt` используются в
    блоке `decreasing_by` для обеих ветвей. В прежней версии требовалась
    аксиома `no_sensitive_at_zero`; теперь её заменяет доказанный инвариант
    `A.card ≤ h` вместе с леммой `budget_pos_of_sensitive`, показывающей, что
    наличие чувствительной координаты автоматически влечёт строго положительный
    бюджет `h`.  Дополнительное следствие `no_sensitive_of_budget_zero`
    формализует противоположное направление: если бюджет исчерпан, то
    чувствительных координат в `A` не осталось.

## Детализированный план

Ниже перечислены все оставшиеся шаги с указанием предполагаемой сложности и
точек входа в кодовую базу. Предпочтительный маршрут сейчас — **вариант Б** с
лексикографической мерой, при этом **вариант А** с жёстким делением пополам
рассматривается как возможное упрощение.

### 0) Опорные определения и константы

- ✅ Зафиксирована константа `C = 10` (`BoolFunc.coverConst`) во всех оценках
  глубины и размера покрытия.  **Файлы:** `Pnp2/low_sensitivity_cover.lean`,
  тесты.

### 1) Мера и её убывание

1. ✅ Определена лексикографическая мера `measureLex` и показана её
   хорошая основанность `measureLexRel_wf`.  **Файл:** `entropy.lean`.
2. ✅ Лемма `measureLex_restrict_decreases` показывает, что при уменьшении
   мощности ветви лексикографическая мера падает.  **Файл:** `entropy.lean`.
3. ✅ Лемма `card_restrict_lt_of_restrict_eq` фиксирует, что если две функции
   семьи совпадают после фиксации координаты, то соответствующая ветвь
   строго уменьшается по числу функций.  **Файл:** `BoolFunc.lean`.
4. ✅ Лемма `measureLex_restrict_lt_of_restrict_eq` объединяет две предыдущие:
   при наличии такой совпадающей пары лексикографическая мера ветви
   строго падает.  **Файл:** `entropy.lean`.
   🔧 Лемма `exists_branch_measure_drop_of_sensitive` показывает, что сама
   чувствительность уже обеспечивает спад тройной меры `measureLex3`: даже в
   контрпримере `{id, not}` на одном бите ветви сохраняют мощность, но
   удаление чувствительной координаты уменьшает размерность и гарантирует
   прогресс рекурсии.  **Файл:** `entropy.lean`.
5. ✅ Лемма `measureLex_restrict_lt_of_card_le_half` показывает, что если после
   фиксации координаты в ветви остаётся не больше половины функций,
   лексикографическая мера строго падает. **Файл:** `entropy.lean`.
6. ✅ Лемма `exists_branch_lex_smaller_of_half` упаковывает предыдущий результат
   в экзистенциальную форму: из свидетельства половинного уменьшения семейства
   немедленно следует строгий спад лексикографической меры. **Файл:**
   `entropy.lean`.  *Осталось:* связать чувствительную координату с наличием
   такой «половинной» ветви или пары функций, совпадающих после ограничения.
7. ✅ Лемма `exists_branch_lex_smaller_of_merge` показывает, что если две
   функции семьи совпадают после ограничения по некоторой координате, то
   соответствующая ветвь уменьшает лексикографическую меру. **Файл:**
   `entropy.lean`.
8. ✅ Введена тройная лексикографическая мера `measureLex3 F A =
   (measure F, F.card, A.card)` и доказана лемма
   `measureLex3_restrict_lt_dim`, гарантирующая спад по третьему компоненту при
   удалении чувствительной координаты из множества `A`. **Файл:** `entropy.lean`.
   ✅ Добавлен рекурсивный каркас `buildCoverLex3`, использующий эту меру для
   well-founded индукции по парам `(F, A)`. **Файл:** `low_sensitivity_cover.lean`.
  🔧 В `buildCoverLex3` перед ветвлением удаляются тождественно ложные функции,
   затем выбирается чувствительная координата из `A`, и покрытия ветвей
   нормализуются и склеиваются при помощи `glue_branch_coversPw`. Для перехода
   от подсемейства обратно к исходному добавлена лемма
  `CoverResP.lift_erase_false`, наследующая покрытие после удаления
   константно ложной функции и корректная для точечной монохроматичности.
   *Осталось:* заменить все обращения к семейной версии на точечную и
   провести анализ операций `restrictDrop`/`extendDrop` с соответствующими
   леммами о мере.
9. ✅ Новая лемма `H₂_le_of_measure_le` связывает целочисленную меру с
   исходным ограничением на энтропию: из `measure F ≤ h` следует `H₂ F ≤ h`.
   Это позволит в базовых случаях напрямую применять энтропийное покрытие.
   **Файл:** `entropy.lean`.
10. ✅ Показано, что при наличии функции с `true`‑значением ситуация `A = ∅`
    противоречива (лемма `nonconstant_all_insensitive_false`), поэтому
    отдельный случай с `entropyCover` более не требуется.

### 2) «Неконстантность ⇒ чувствительный бит» в рекурсии

- ✅ Добавлена вспомогательная лемма `exists_sensitive_coord_true_false`,
  возвращающая чувствительную координату вместе с точкой, где значение падает
  с `true` на `false`.  Она подготовлена для дальнейшей рекурсивной
  конструкции.  **Файл:** `low_sensitivity_cover.lean`.
  ✅ В `Sensitivity.lean` введена функция `coordSensitivity` и лемма
  `exists_sensitive_coord_in_A`, позволяющая выбирать чувствительную
  координату внутри заданного множества `A` при условии, что вне `A`
  чувствительность занулена.
  ✅ Введена ориентированная версия `exists_sensitive_coord_true_false_in_A`,
  возвращающая координату из `A` вместе с точкой, где значение падает с
  `true` на `false`.  **Файл:** `low_sensitivity_cover.lean`.
  ✅ Новая лемма `insens_off_A_restrict` показывает, что после фиксации бита
  инвариант нечувствительности вне `A` сохраняется для `A.erase i`.
  **Файл:** `Sensitivity.lean`.
  ✅ Инвариант `insens_off_A` теперь передаётся через рекурсивный каркас
  `buildCoverLex3` при помощи вспомогательной структуры `BuildInv`.
  ✅ В самой рекурсии используется `exists_sensitive_coord_true_false_in_A`
  для выбора координаты.
  *Осталось:* внедрить нормализацию и склейку ветвей через
  `glue_branch_coversPw`, чтобы рекурсивное покрытие сразу возвращало
  требуемые доказательства.


### 3) Склейка покрытий двух ветвей

- ✅ Лемма `monochromaticForFamily_extend_restrict` уже доказывает
  корректность расширения субкуба.
- ✅ Добавлены операция `Subcube.unfix` и усиленная лемма
  `cover_normalize_branch`, которая с помощью новой теоремы
  `monochromaticForFamily_unfix_of_insensitive` нормализует покрытия ветвей,
  устраняет фиксацию выбранного бита и сохраняет монохроматичность.
  Добавлена также однофункциональная версия `monochromaticFor_unfix_of_insensitive`
  и новая лемма `cover_normalize_branch_pointwise`, которые готовят почву для
  дальнейшего перехода к точечной монохроматичности.
  **Файлы:** `low_sensitivity_cover.lean`.
- ✅ Реализована лемма `cover_all_inputs_extend_union`, показывающая,
  что покрытия ветвей после расширения объединяются в покрытие исходного
  семейства.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Лемма `disjoint_extend_images` устанавливает, что расширения ветвей по
  противоположным значениям `i` не пересекаются, позволяя суммировать их
  мощности.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Добавлена лемма `card_extend_union_le`, оценивающая мощность
  объединения расширенных ветвей сверху через сумму мощностей исходных
  покрытий.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Новая лемма `extend_union_cover` объединяет все предыдущие результаты:
  из покрытий ветвей можно получить покрытие исходного семейства с контролем
  мощности.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Введена структура `CoverResP` и определение `glue_step`, упаковывающее
  результат склейки в удобный формат с явным ограничением на число субкубов.
  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Лемма `glue_branch_coversPw` нормализует покрытия ветвей, склеивает их и
  переносит оценку мощности `k₀ + k₁` на объединённый результат, готовя почву
  для рекурсивного доказательства.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Добавлена лемма `glue_branch_coversPw_mBound`, которая сразу выводит
  ограничение `mBound n (h + 1)` для склеенного покрытия и пригодится при
  учёте мощности в рекурсивном конструкторе.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Определение `CoverResP.empty` задаёт тривиальное покрытие для пустого
  семейства: прямоугольников нет, и условия монохроматичности и покрытия
  выполняются автоматически.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Определение `CoverResP.const` строит базовое покрытие из одного полного
  субкуба для семейства, где все функции принимают одинаковое значение.
  Это заготовка для базового случая будущей рекурсии.
  **Файл:** `low_sensitivity_cover.lean`.

  ✅ `buildCoverLex3` переписан так, что возвращает заготовку `CoverResP`;
  последующие версии встроят вызовы `glue_branch_coversPw` для склейки ветвей
  и доведут доказательства точечной монохроматичности, покрытия и оценки мощности.

### 4) Построение дерева из покрытия

- ✅ Добавлена заготовка `DecisionTree.ofRectCover`, превращающая набор
  субкубов в дерево решений.  Добавлены вспомогательные леммы
  `matches_toList_of_mem`, `eval_matchSubcube_matches` и
  `eval_ofRectCoverList_cons_mem`, обеспечивающие корректность расчёта
  цвета на точках внутри каждого субкуба.
- ✅ Получены оценки числа листьев, глубины и числа окрашенных субкубов.
  Леммы `leaf_count_matchSubcube` и `leaf_count_ofRectCoverList_le`
  связывают количество листьев построенного дерева с длинами списков
  субкубов; `depth_matchSubcube_le` и `depth_ofRectCoverList_le` оценивают
  глубину через суммарную длину этих списков; `coloredSubcubes_ofRectCover_card_le`
  переносит ту же оценку на мощность множества окрашенных субкубов;
  `coloredSubcubes_cover_eval` (и частные `coloredSubcubes_cover_true`/
  `coloredSubcubes_cover_false`) гарантирует, что каждый вход покрыт
  подходящим субкубом.  Связь с глобальной оценкой
  `DecisionTree.leaf_count_le_pow_depth` всё ещё требует исследования.
  **Файл:** `DecisionTree.lean`.
- ✅ Реализована функция `CoverResP.toDecisionTree_for`, превращающая
  структурированное покрытие в исполнимое дерево решений для выбранной
  функции. Новые леммы `CoverResP.leaf_count_le`, `CoverResP.depth_le`,
  `CoverResP.eval_true`, `CoverResP.eval_false` и `CoverResP.depth_le_card_mul`
  связывают число листьев и глубину дерева с размерами покрывающих субкубов,
  а также подтверждают корректность вычисления дерева. Это подготавливает
  переход к глобальной оценке.
  **Файлы:** `low_sensitivity_cover.lean`, `DecisionTree.lean`.
- ✅ Сама теорема `decisionTree_cover` переформулирована с точечной
  монохромностью: для каждого прямоугольника запрашивается константность
  каждой функции семейства. Доказательство пока остаётся незавершённым.

### 5) Глобальная оценка глубины

- ✅ Получено общее неравенство `depth ≤ n · k` для дерева, построенного из
  покрытия `CoverResP` с `k` прямоугольниками (`CoverResP.depth_le_card_mul`).
  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Лемма `CoverResP.depth_le_of_card_le` позволяет подставлять внешнюю оценку
  на число прямоугольников, а её специальный случай
  `CoverResP.depth_le_coverConst` фиксирует верхнюю границу через глобальную
  константу `coverConst`.  **Файл:** `low_sensitivity_cover.lean`.
- Собрать итоговую оценку числа листьев и перевести её в ограничение на глубину:
  `depth ≤ C · s · log₂(n+1)`.  **Сложность:** низкая.  **Файл:**
  `low_sensitivity_cover.lean`.

### 6) Вспомогательные леммы и рефакторинг

- Довести до ума набор утилит для `Finset`, `Nat.ceil` и логарифмов, чтобы
  доказательство оставалось кратким и ясным.  **Сложность:** низкая.

### 7) Опциональные задачи

- При желании формализовать оценку `H₂(F) ≤ C · s · log(n+1)` вместо приёма
  “безопасной константы”.

## Ожидаемый результат

После реализации плана аксиома `decisionTree_cover` будет заменена
конструктивной теоремой с границей `depth ≤ 10 · s · log₂(n+1)`, основанной на
строгом убывании выбранной меры.  Это закроет один из ключевых фрагментов
проекта и приблизит доказательство FCE‑Lemma.


## Оставшиеся шаги

Задача о комбинаторной оценке числа субкубов закрыта и удалена из списка.
Ниже собраны все остальные задачи, которые нужно завершить перед тем, как
удалить данный план и перенести итоговое доказательство в основную
документацию.

Перед продолжением работ зафиксируем несколько решений, вытекающих из дополнительного анализа:

- В покрытии переходим на **точечную монохромность**: прямоугольник должен быть константным для каждой функции семейства, но цвет может зависеть от самой функции. Для построения деревьев используется `CoverResP.toDecisionTree_for`, который окрашивает листья под выбранную функцию.
- Инвариант `BuildInv` менять не нужно: рекурсивная функция `buildCoverLex3` возвращает структуру `CoverResP` и использует `glue_branch_coversPw` для склейки ветвей.
- Основной маршрут — **вариант B** с лексикографической мерой; «жёсткое деление пополам» рассматривается лишь как возможное упрощение в будущем.

1. **Связь чувствительности с уменьшением меры.**
    - Доказаны леммы `measureLex3_restrict_lt_of_restrict_eq` и `measureLex3_restrict_lt_of_card_le_half`, а также существование ветви со спадом `measureLex3` (`exists_branch_measure_drop_of_sensitive`).
    - `buildCoverLex3` теперь использует `measureLex3` в качестве функции
      терминации: удаление тождественно ложной функции уменьшает тройную
      меру по лемме `measureLex3_erase_lt`.
    - Добавлена лемма `measureLex3_drop_coord`, показывающая, что исключение
      координаты из набора `A` снижает третью компоненту меры без изменения
      семейства.
    - В чувствительной ветви `buildCoverLex3` пока нет настоящего
      рекурсивного деления: обнаружив чувствительную координату `i`,
      функция строит точечные покрытия `pointCover` для ветвей
      `F.restrict i false` и `F.restrict i true`, после чего склеивает
      их с помощью `glue_branch_coversPw_mBound`.  Такое поведение
      корректно, но не уменьшает семейство рекурсивно.
    - Леммы `glue_branch_coversPw` и `glue_branch_coversPw_mBound` уже
      используются для этой склейки, подготавливая почву для будущего
      полноценного ветвления.  Также введены обёртки
      `CoverResP.pointCover_succ`, `CoverResP.const_mBound` и
      `CoverResP.const_mBound_exact`, позволяющие при необходимости
      повышать бюджет `mBound`.  В текущей реализации используется только
      базовая версия `pointCover`.
   - ✅ Устранена прежняя аксиома `no_sensitive_at_zero`: введён инвариант
     `A.card ≤ h` и доказана лемма `budget_pos_of_sensitive`, обеспечивающая
     положительность бюджета при наличии чувствительной координаты.
2. **Рекурсивное построение покрытия.**
    - ✅ `buildCoverLex3` теперь возвращает структуру `CoverResP`; в отсутствие
      чувствительных координат покрытие сводится к одному полному кубу с
      помощью леммы `all_true_of_no_sensitive_coord`.
3. **Переход от покрытия к дереву решений.**
    - Закрыть все допуски в `decisionTree_cover`: использовать построенное покрытие, для каждого `f ∈ F` превращать его в дерево `DecisionTree` через `CoverResP.toDecisionTree_for` и доказать корректность вычислений.
    - Отказ от семейной монохромности требует окраски листьев относительно конкретной функции, но структура дерева остаётся общей.
4. **Оценка числа прямоугольников и глубины.**
    - Из условия `card_le` выводить `|Rset| ≤ mBound n h`, затем применять `Cover2.pow_le_mBound_simple` для получения границы `|Rset| ≤ 2^h`.
    - Сформулировать окончательную оценку `depth ≤ coverConst · s · log₂ (n + 1)` и перенести её в теорему `decisionTree_cover`, используя связь `leaf_count ≤ 2^{depth}` из `DecisionTree.leaf_count_le_pow_depth`.
5. **Рефакторинг и документация.**
   - Упростить конечное доказательство, вынеся технические леммы в отдельные разделы.
   - После выполнения всех задач перенести краткое описание результата в `README` и удалить данный план.
6. **Опционально: точная оценка энтропии.**
   - Формализовать неравенство `H₂(F) ≤ coverConst · s · log₂ (n + 1)` вместо использования «безопасной константы».


## Обновление плана (рефакторинг `buildCoverLex3`)

  1. **Рекурсивное ветвление по чувствительной координате.**
    - Чувствительный случай пока реализован через точечные покрытия на каждой
      ветви и последующую склейку `glue_branch_coversPw_mBound`.
    - Определения `glue_step_pw`, `glue_branch_coversPw` и
      `glue_branch_coversPw_mBound` уже готовы для будущего рекурсивного шага,
      но сами рекурсивные вызовы `buildCoverLex3A` по ветвям ещё не внедрены.
    - Лемма-заглушка `glue_branch_coversPw_card_le_mBound_succ` удалена.
    - ✅ Блок `decreasing_by` содержит только случай удаления постоянно ложной
      функции; ветвление по координате в текущей версии рекурсии не использует.
    - ✅ Введена вспомогательная функция `buildCoverLex3A` с параметром множества
      координат `A`; обёртка `buildCoverLex3` вызывает её с `A = univ`, что
      подготавливает инфраструктуру для дальнейшего рекурсивного ветвления.
     для дальнейшего рекурсивного ветвления по чувствительным координатам.
