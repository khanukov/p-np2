# План доказательства `decisionTree_cover`

Документ описывает текущий прогресс и дальнейшие шаги по замене аксиомы
`LowSensitivityCover.decisionTree_cover` полноценным формальным доказательством.
Во всех рассуждениях допускается использование классической логики и аксиомы
выбора.

## Состояние проекта

- В `low_sensitivity_cover.lean` утверждение `decisionTree_cover` пока объявлено
  как `axiom`.
- Реализованы базовые структуры: `Family`, `DecisionTree`, `Subcube`,
  `FamilyCover`.
- Доказаны вспомогательные леммы:
  - `DecisionTree.leaf_count_le_pow_depth`;
  - `H₂_restrict_le`;
  - `sunflower_exists_classic`;
  - набор фактов о мере: `measure_restrict_le`, `measure_filter_le`,
    `measure_empty`, `measure_singleton`, `measure_pos_of_card_two_le`,
    `measure_restrict_lt_of_card_le_half`, `measure_filter_lt_of_card_le_half`.
- Существует каркас для объединения покрытий (`merge_low_sens.lean`) и
  добавлены леммы `merge_card_le_low_sens` и `merge_card_le_entropy` для оценки
  числа субкубов в объединённом покрытии; зафиксирована безопасная константа
  `C = 10` (`BoolFunc.coverConst`) для всех асимптотических оценок.
- Добавлена лемма `cover_exists_bound`, а структура `FamilyCover` вновь
  содержит явное поле `bound`.  Получено утверждение `entropyCover`,
  предоставляющее покрытие из `2^{C⋅h}` субкубов при условии `measure F ≤ h`.

## Ключевые вопросы и текущий статус

1. **Энтропийная оценка**
   *Сделано:* введена мера `measure F = Nat.ceil (H₂ F)` и принято безопасное
   ограничение `measure F ≤ 10 · s · log₂(n+1)`. Добавлена конструкция
   `cover_exists_bound` и лемма `entropyCover`, дающие покрытие размером не
   более `2^{C⋅h}` при `H₂ F ≤ h`.
   *Осталось:* при необходимости уточнить константу, формализовав оценку
   `(n+1)^{O(s)}` из работы Gopalan–Moshковitz–Oliveira.

2. **Строгое уменьшение меры**  
 *Сделано:* леммы `measure_restrict_le`, `measure_restrict_decreases`,
  `measure_restrict_lt_of_card_le_half` и `measure_filter_lt_of_card_le_half`
  показывают падение меры при существенном уменьшении семейства.
  Добавлена вспомогательная оценка `card_le_mul_card_restrict`, ограничивающая
  размер семейства через произведение размеров обеих ветвей при фиксировании
  координаты.
  *Осталось:* доказать, что при разбиении по чувствительной координате одна из
  ветвей уменьшает меру (например, вывести `2 * |F.restrict i b| ≤ |F|` из
  чувствительности, используя новую оценку), либо перейти к лексикографической
  мере `(measure F, card F)`.

3. **Выбор чувствительного бита**  
   *Сделано:* лемма `non_constant_family_has_sensitive_coord` находит
   чувствительную координату после удаления тождественно ложных функций.  
   *Осталось:* встроить процедуру выбора координаты в основную рекурсию.

4. **Монадическое построение дерева**  
   *Сделано:* разработана стратегия: сначала строится покрытие субкубами, затем
   оно переводится в `DecisionTree`; имеются леммы `Subcube.extend` и
   `monochromaticForFamily_extend_restrict`.  
   *Осталось:* реализовать объединение покрытий и финальное преобразование
   покрытия в дерево.

5. **Оценка глубины**  
   *Сделано:* лемма `DecisionTree.leaf_count_le_pow_depth` связывает число
   листьев с глубиной.  
   *Осталось:* связать её с энтропийной мерой и доказать
   `depth ≤ C · s · log₂(n+1)` по завершении рекурсии.

6. **Оптимизация стиля**  
   *Сделано:* многие технические шаги вынесены во вспомогательные леммы,
   упрощающие основное доказательство.  
   *Осталось:* продолжить рефакторинг, чтобы `decisionTree_cover` оставалась
   короткой и концептуальной.

7. **Гарантия терминирования**
   *Сделано:* подготовлены леммы, обеспечивающие положительность меры и её
   падение при уменьшении семейства. Добавлена тройная мера `measureLex3`,
   которая убывает при каждом исключении координаты из множества `A`.
   *Осталось:* встроить эту меру в рекурсивное построение покрытия.

## Детализированный план

Ниже перечислены все оставшиеся шаги с указанием предполагаемой сложности и
точек входа в кодовую базу. Предпочтительный маршрут сейчас — **вариант Б** с
лексикографической мерой, при этом **вариант А** с жёстким делением пополам
рассматривается как возможное упрощение.

### 0) Опорные определения и константы

- ✅ Зафиксирована константа `C = 10` (`BoolFunc.coverConst`) во всех оценках
  глубины и размера покрытия.  **Файлы:** `Pnp2/low_sensitivity_cover.lean`,
  тесты.

### 1) Мера и её убывание

**Вариант А — строгое убывание по чувствительной координате.**

*⚠️ Этот подход оказался непригодным.*  Предположение, что из чувствительности
по координате `i` следует существование ветви, как минимум вдвое меньшей, было
опровергнуто контрпримером: семейство `{id, not}` на одном бите чувствительно
к единственной координате, однако обе ветви после ограничения содержат по две
функции, и неравенство `2 * |F.restrict i b| ≤ |F|` нарушается.  Поэтому
вариант А больше не рассматривается и дальнейшая работа сосредоточена на
варианте Б.

**Вариант Б — лексикографическая мера `(measure F, F.card)` (надёжный fallback).**

1. ✅ Определена лексикографическая мера `measureLex` и показана её
   хорошая основанность `measureLexRel_wf`.  **Файл:** `entropy.lean`.
2. ✅ Лемма `measureLex_restrict_decreases` показывает, что при уменьшении
   мощности ветви лексикографическая мера падает.  **Файл:** `entropy.lean`.
3. ✅ Лемма `card_restrict_lt_of_restrict_eq` фиксирует, что если две функции
   семьи совпадают после фиксации координаты, то соответствующая ветвь
   строго уменьшается по числу функций.  **Файл:** `BoolFunc.lean`.
4. ✅ Лемма `measureLex_restrict_lt_of_restrict_eq` объединяет две предыдущие:
   при наличии такой совпадающей пары лексикографическая мера ветви
   строго падает.  **Файл:** `entropy.lean`.
   *Осталось:* получить из чувствительности пару функций, сливающихся при
   ограничении, и тем самым найти ветвь меньшей мощности. Попытка сформулировать
   такую лемму (`exists_restrict_eq_of_sensitive`) обнаружила контрпример:
   семейство `{id, not}` на одном бите опровергает утверждение. Требуется
   пересмотреть формулировку — возможно, добавив дополнительные условия — прежде
   чем продолжать этот шаг.
5. ✅ Лемма `measureLex_restrict_lt_of_card_le_half` показывает, что если после
   фиксации координаты в ветви остаётся не больше половины функций,
   лексикографическая мера строго падает. **Файл:** `entropy.lean`.
6. ✅ Лемма `exists_branch_lex_smaller_of_half` упаковывает предыдущий результат
   в экзистенциальную форму: из свидетельства половинного уменьшения семейства
   немедленно следует строгий спад лексикографической меры. **Файл:**
   `entropy.lean`.  *Осталось:* связать чувствительную координату с наличием
   такой «половинной» ветви или пары функций, совпадающих после ограничения.
7. ✅ Лемма `exists_branch_lex_smaller_of_merge` показывает, что если две
   функции семьи совпадают после ограничения по некоторой координате, то
   соответствующая ветвь уменьшает лексикографическую меру. **Файл:**
   `entropy.lean`.
8. ✅ Введена тройная лексикографическая мера `measureLex3 F A =
   (measure F, F.card, A.card)` и доказана лемма
   `measureLex3_restrict_lt_dim`, гарантирующая спад по третьему компоненту при
   удалении чувствительной координаты из множества `A`. **Файл:** `entropy.lean`.
   ✅ Добавлен рекурсивный каркас `buildCoverLex3`, использующий эту меру для
   well-founded индукции по парам `(F, A)`. **Файл:** `low_sensitivity_cover.lean`.
   🔧 В `buildCoverLex3` реализован прототип шага рекурсии: выбор координаты из
   `A`, рекурсивное построение покрытий ветвей и их объединение через `extend`.
   *Осталось:* обосновать корректность — монохроматичность, полноту покрытия и
   оценку мощности — а также связывать выбор координаты с чувствительностью.
   Кроме того, требуется ввести версии операций с уменьшением размерности
   (`restrictDrop`, `extendDrop`) и доказать для них аналоги лемм о чувствительности,
   мере и слиянии.  Без этих инструментов пока не удаётся строго показать, что
   рекурсивные покрытия не фиксируют разбиенную координату, что необходимо для
   финальной склейки ветвей.
9. ✅ Новая лемма `H₂_le_of_measure_le` связывает целочисленную меру с
   исходным ограничением на энтропию: из `measure F ≤ h` следует `H₂ F ≤ h`.
   Это позволит в базовых случаях напрямую применять энтропийное покрытие.
   **Файл:** `entropy.lean`.
10. ✅ В `buildCoverLex3` обработан случай `A = ∅`: когда координаты
    для ветвления заканчиваются, используется вспомогательное аксиомное
    построение `entropyCover`, опирающееся на предыдущую лемму
    `H₂_le_of_measure_le`.

### 2) «Неконстантность ⇒ чувствительный бит» в рекурсии

- ✅ Добавлена вспомогательная лемма `exists_sensitive_coord_true_false`,
  возвращающая чувствительную координату вместе с точкой, где значение падает
  с `true` на `false`.  Она подготовлена для дальнейшей рекурсивной
  конструкции.  **Файл:** `low_sensitivity_cover.lean`.
  ✅ В `Sensitivity.lean` введена функция `coordSensitivity` и лемма
  `exists_sensitive_coord_in_A`, позволяющая выбирать чувствительную
  координату внутри заданного множества `A` при условии, что вне `A`
  чувствительность занулена.
  ✅ Введена ориентированная версия `exists_sensitive_coord_true_false_in_A`,
  возвращающая координату из `A` вместе с точкой, где значение падает с
  `true` на `false`.  **Файл:** `low_sensitivity_cover.lean`.
  ✅ Новая лемма `insens_off_A_restrict` показывает, что после фиксации бита
  инвариант нечувствительности вне `A` сохраняется для `A.erase i`.
  **Файл:** `Sensitivity.lean`.
  ✅ Инвариант `insens_off_A` теперь передаётся через рекурсивный каркас
  `buildCoverLex3` при помощи вспомогательной структуры `BuildInv`.
  *Осталось:* использовать лемму `exists_sensitive_coord_in_A`, чтобы каждая
  рекурсия выбирала действительно чувствительную координату, а также убедиться,
  что полученные покрытия ветвей не фиксируют этот индекс
  (`hi₀`/`hi₁` в лемме `extend_union_cover`).


### 3) Склейка покрытий двух ветвей

- ✅ Лемма `monochromaticForFamily_extend_restrict` уже доказывает
  корректность расширения субкуба.
- ✅ Добавлены операция `Subcube.unfix` и лемма `cover_normalize_branch`,
  позволяющие нормализовать покрытия ветвей так, чтобы ни один субкуб не
  фиксировал выбранную координату.  **Файлы:** `BoolFunc.lean`,
  `low_sensitivity_cover.lean`.
- ✅ Реализована лемма `cover_all_inputs_extend_union`, показывающая,
  что покрытия ветвей после расширения объединяются в покрытие исходного
  семейства.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Лемма `disjoint_extend_images` устанавливает, что расширения ветвей по
  противоположным значениям `i` не пересекаются, позволяя суммировать их
  мощности.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Добавлена лемма `card_extend_union_le`, оценивающая мощность
  объединения расширенных ветвей сверху через сумму мощностей исходных
  покрытий.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Новая лемма `extend_union_cover` объединяет все предыдущие результаты:
  из покрытий ветвей можно получить покрытие исходного семейства с контролем
  мощности.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Введена структура `CoverRes` и определение `glue_step`, упаковывающее
  результат склейки в удобный формат с явным ограничением на число субкубов.
  **Файл:** `low_sensitivity_cover.lean`.

### 4) Построение дерева из покрытия

- ✅ Добавлена заготовка `DecisionTree.ofRectCover`, превращающая набор
  субкубов в дерево решений.  Добавлены вспомогательные леммы
  `matches_toList_of_mem`, `eval_matchSubcube_matches` и
  `eval_ofRectCoverList_cons_mem`, обеспечивающие корректность расчёта
  цвета на точках внутри каждого субкуба.
- ✅ Получены оценки числа листьев и глубины.  Леммы
  `leaf_count_matchSubcube` и `leaf_count_ofRectCoverList_le` связывают
  количество листьев построенного дерева с длинами списков субкубов, а
  `depth_matchSubcube_le` и `depth_ofRectCoverList_le` оценивают глубину
  через суммарную длину этих списков.  Связь с глобальной оценкой
  `DecisionTree.leaf_count_le_pow_depth` всё ещё требует исследования.
  **Файл:** `DecisionTree.lean`.

### 5) Глобальная оценка глубины

- Собрать итоговую оценку числа листьев и перевести её в ограничение на глубину:
  `depth ≤ C · s · log₂(n+1)`.  **Сложность:** низкая.  **Файл:**
  `low_sensitivity_cover.lean`.

### 6) Вспомогательные леммы и рефакторинг

- Довести до ума набор утилит для `Finset`, `Nat.ceil` и логарифмов, чтобы
  доказательство оставалось кратким и ясным.  **Сложность:** низкая.

### 7) Опциональные задачи

- Попытаться реализовать вариант А и тем самым избавиться от лексикографической
  меры.
- При желании формализовать оценку `H₂(F) ≤ C · s · log(n+1)` вместо приёма
  “безопасной константы”.

## Ожидаемый результат

После реализации плана аксиома `decisionTree_cover` будет заменена
конструктивной теоремой с границей `depth ≤ 10 · s · log₂(n+1)`, основанной на
строгом убывании выбранной меры.  Это закроет один из ключевых фрагментов
проекта и приблизит доказательство FCE‑Lemma.

