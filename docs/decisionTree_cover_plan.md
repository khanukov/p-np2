# План доказательства `decisionTree_cover`

Этот документ описывает, как заменить текущую аксиому
`LowSensitivityCover.decisionTree_cover` на полностью формализованное
доказательство.  План подробно разбивает работу на этапы и фиксирует
вопросы, которые ещё требуют прояснения.  Все шаги допускают свободное
использование classical-аксиом.

## 1. Текущее положение

* В файле `low_sensitivity_cover.lean` утверждение `decisionTree_cover`
  объявлено как `axiom`.
 * Разработка уже содержит:
  - определения `Family`, `DecisionTree`, `Subcube` и `FamilyCover`;
  - леммы `DecisionTree.leaf_count_le_pow_depth`, `H₂_restrict_le` и
    реализованный `sunflower_exists_classic`;
  - каркас для объединения покрытий в `merge_low_sens.lean`.
  - определение `measure` как `Nat.ceil (H₂ F)` и леммы
    `measure_restrict_le`, `measure_filter_le`, `measure_empty`,
    `measure_singleton`, `measure_pos_of_card_two_le`,
    `measure_restrict_lt_of_card_le_half` в `entropy.lean`.
* Недостаёт доказательства существования дерева решений глубины
  `O(s · log (n+1))`, покрывающего все 1‑входы семейства.

## 2. Общая стратегия

1. **Мера для индукции.**  Вводим функцию
   `measure : Family n → ℕ`, отражающую сложность семейства.
   Теперь считаем, что
   `measure F = Nat.ceil (H₂ F)`; поскольку `H₂ F = log₂ |F|`, это равно
   целочисленному потолку от логарифма мощности семейства.  Такой выбор
   обеспечивает убывание меры минимум на `1` при любом реальном падении
   энтропии.  При желании для более тонкого шага можно домножить `H₂ F`
   на `(n+1)^k`, но пока достаточно потолка.  Требуется доказать, что при
   каждом разбиении по чувствительной координате эта мера строго
   убывает.

2. **База.**  Если семейство `F` постоянно на всём `BoolCube n`, то
   возвращаем одно покрытие из полного куба.  Лемма
   `decisionTree_cover_of_constant` уже имеется и должна быть
   переиспользована.

3. **Выбор чувствительной координаты.**  Если семейство не постоянно,
   нужно выбрать индекс `i`, такой что существует `f ∈ F` и точка `x`,
   где `sensitivity f x i`.  Планируется доказать вспомогательное
   утверждение `non_constant_family_has_sensitive_coord`, используя
   лемму `sensitivity_const` (константные функции имеют чувствительность
   0) и готовую `exists_family_sensitive_coord`, которая из факта
  `∃ f ∈ F, sensitivity f > 0` выдаёт конкретный чувствительный бит и
  точку.  Для непостоянного семейства удаляем тождественно ложные
  функции и получаем хотя бы одну неконстантную функцию, что обеспечивает
  требуемую чувствительность.

4. **Ограничение семейства.**  Определяем `F₀` и `F₁` – семейства после
   подстановки `xᵢ := 0` и `xᵢ := 1` соответственно.  На чувствительность
   действует лемма `sensitivity_restrictCoord_le`, уже реализованная в
   `BoolFunc/Sensitivity.lean`, поэтому `sensitivity (f|_{xᵢ=b}) ≤ s`.
   Осталось доказать строгое уменьшение меры: требуется лемма
   `measure_restrict_decreases`, утверждающая, что хотя бы в одной ветви
   `measure F_b < measure F`.

5. **Рекурсивное построение.**  Применяем индукционное предположение к
   `F₀` и `F₁`, получая покрытия `R₀` и `R₁` и деревья глубины `≤ d₀` и
   `≤ d₁`.

6. **Склейка покрытий.**  Расширяем каждый `R ∈ R_b` условием `xᵢ = b`
   (операция `Subcube.extend`), объединяем результаты в `Rset`.  Нужно
   показать:
   * монохроматичность каждого расширенного субкуба для исходного `F`;
   * покрытие всех 1‑входов `F`;
   * оценку `card Rset ≤ card R₀ + card R₁`.

7. **Оценка глубины/количества листьев.**
   * Используем ограничение на энтропию: ожидаем оценку
     `measure F ≤ C · s · log₂(n+1)` (в литературе ожидается результат
     порядка `(n+1)^{O(s)}`; достаточно взять явный запас, например
     `C = 10`).
   * Из шага 4 должно следовать `measure F_b ≤ measure F - δ` для
     некоторого `δ > 0`; тогда глубина дерева `≤ (C/δ) · s · log₂(n+1)`.
   * Далее используется арифметика Finset и лемма
     `DecisionTree.leaf_count_le_pow_depth`, что приводит к границе
     `|Rset| ≤ 2^(depth)` и `depth ≤ C·s·log₂(n+1)`.

## 3. Детализация необходимых лемм

1. ~~`non_constant_family_has_sensitive_coord`
   * ввод: `¬(∃ b, ∀ f∈F, ∀ x, f x = b)`;
   * вывод: `∃ i, ∃ f∈F, sensitivity f i`.
   * вероятно потребуется лемма о том, что если `f` различается на двух
     точках, то существует координата, влияющая на результат.~~
   Реализована как `BoolFunc.non_constant_family_has_sensitive_coord` с
   дополнительным предположением, что в `F` нет тождественно ложных функций.
   Для удаления таких функций добавлена лемма `measure_filter_le`,
   гарантирующая неувеличение меры при фильтрации семейства.

2. `measure_restrict_decreases`
   * для выбранного индекса `i` доказать `measure F₀ < measure F` либо
     `measure F₁ < measure F` (хватит строгого уменьшения хотя бы в
     среднем).
   * имеется нестрогая `measure_restrict_le` и более сильная
     `measure_restrict_lt_of_card_le_half`, обеспечивающая уменьшение
     при сокращении семейства как минимум вдвое;
     общий случай строгого уменьшения всё ещё открыт.

3. ~~`sensitivity_restrict_le`
   * показать, что ограничение функции по координате не увеличивает
     чувствительность.  Эта лемма уже присутствует в
     `Pnp2/BoolFunc/Sensitivity.lean` под названием
     `sensitivity_restrictCoord_le`; вероятно достаточно ссылаться на
     неё.~~

4. ~~`extend_monochromatic`
   * если `R` монохроматичен для `F_b`, то `extend i b R` монохроматичен
     для `F`.~~ Реализовано как `Subcube.extend` и лемма
   `monochromaticForFamily_extend_restrict` в `BoolFunc.lean`.

5. ~~`cover_all_inputs`
   * формализовать приведённый в описании аргумент: каждую точку с
     `f x = true` спускаем по пути дерева согласно значениям
     координат, получаем подходящий лист.~~ Реализовано как
   `DecisionTree.coloredSubcubes_cover_true`, который связывает
   истинную оценку дерева с листом‑субкубом, содержащим вход.

6. ~~`size_bound_step`
   * аккуратная арифметика: `card Rset = card R₀ + card R₁`,
     `card R_b ≤ 2^{depth_b}`, ⇒ `card Rset ≤ 2^{max depth_b + 1}` и
     далее `≤ 2^{C·s·log₂(n+1)}`.~~ Используются существующие
   оценки `DecisionTree.tree_depth_bound` и
   `DecisionTree.leaf_count_le_pow_depth`, дающие верхнюю границу
   на число листьев через глубину.

## 4. Открытые вопросы и места, требующие уточнений

1. **Энтропийная мера.**  В настоящее время отсутствует явное доказательство
   `measure F ≤ C · s · log₂(n+1)`.  Предполагается использовать результат
   Гопалана–Мошковица–Оливейры о том, что семейства малой чувствительности
   имеют мощность не более `(n+1)^{O(s)}`.  Нужно либо формализовать эту
   оценку, либо принять достаточный запас для константы `C`.

2. **Строгое уменьшение энтропии.**  Лемма `H₂_restrict_le` даёт лишь
   нестрогое неравенство.  Реализована `measure_restrict_le`, но нужное
   строгое убывание остаётся открытым.  Новая лемма
   `measure_pos_of_card_two_le` показывает, что положительная мера
   появляется только при наличии как минимум двух функций; поэтому в
   случае единственной неконстантной функции мера равна нулю и не
   уменьшается.  Возможные направления — доказать существование
   совпадающих ограничений в хотя бы одной ветви либо перейти к
   лексикографической мере `(measure F, n)` для обеспечения
   терминальности.

3. **Монадическая конструкция дерева.**  ~~Вопрос о наиболее удобной форме
   индуктивной гипотезы: лучше строить дерево сразу в теле доказательства
   или сначала покрытие, а дерево потом восстанавливать?~~ Выбрана стратегия
   сначала строить покрытие, а затем превращать его в дерево при помощи
   существующего конструктора `DecisionTree`.

4. **Константа `C` и точные оценки.**  ~~Какие численные константы уже
   зафиксированы в проекте?  Возможно, проще установить заведомо большую
   константу (например `C = 10`), если это не повредит последующим
   расчётам.~~  В текущей версии будем использовать безопасную
   константу `C = 10`, что достаточно для всех оценок.

5. **Оптимизация стиля.**  ~~Требуются ли вспомогательные теоремы для
   работы с Finset‑ами (`card_disjoint_union`, `mem_map`, и т.п.), или
   стоит зафиксировать несколько удобных вспомогательных лемм в отдельных
   файлах?~~  Рекомендуется подготовить набор вспомогательных лемм для
   Finset‑ов и арифметики, чтобы основной текст доказательства оставался
   читаемым.

6. **Неконстантность семейства.**  ~~Имеющихся лемм `sensitivity_const` и
   `exists_family_sensitive_coord` может быть достаточно, чтобы из
   неконстантности заключить положительную чувствительность для некоторой
   функции.  Нужно проверить, хватает ли их для построения
   `non_constant_family_has_sensitive_coord`, или требуется отдельное
   доказательство.~~  Считаем, что комбинация этих лемм, совместно с
   удалением тождественно ложных функций, даёт желаемое утверждение.

## 5. Последовательность реализации

1. Подготовить набор вспомогательных лемм (раздел 3) в соответствующих
   файлах (`Sensitivity.lean`, `entropy.lean`, `DecisionTree.lean`).
2. В `low_sensitivity_cover.lean` переписать `decisionTree_cover`:
   * объявить рекурсивную функцию, принимающую `F` и `measure F`;
   * реализовать ветвление по чувствительной координате;
   * встроить проверки монохроматичности и покрытия.
3. После получения финсета прямоугольников построить из него дерево
   (`DecisionTree.ofRectCover`) и применить `leaf_count_le_pow_depth` для
   оценки числа листьев.
4. Заменить аксиому на доказанную теорему, обновить `TODO.md`.
5. Запустить `./scripts/check.sh` для проверки сборки.

## 6. Ожидаемый результат

После выполнения шагов выше аксиома `decisionTree_cover` будет удалена,
а её место займёт формальное доказательство с параметром `C` и
полным описанием построенного покрытия.  Это позволит устранить ещё одну
основную брешь в проекте и приблизит нас к доказательству FCE‑Lemma.

