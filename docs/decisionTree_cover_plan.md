# План доказательства `decisionTree_cover`

Документ описывает текущий прогресс и дальнейшие шаги по замене аксиомы
`LowSensitivityCover.decisionTree_cover` полноценным формальным доказательством.
Во всех рассуждениях допускается использование классической логики и аксиомы
выбора.

## Состояние проекта

- В `low_sensitivity_cover.lean` утверждение `decisionTree_cover` уже
представлено в окончательном виде: доказательство построено, и для каждого
прямоугольника требуется точечная монохромность относительно каждой функции
семейства.
- Реализованы базовые структуры: `Family`, `DecisionTree`, `Subcube`,
  `FamilyCover`.
- Доказаны вспомогательные леммы:
  - `DecisionTree.leaf_count_le_pow_depth`;
  - `decisionTree_cover_of_tree`, извлекающая покрытие из дерева решений через
    `coloredSubcubes` и дающая оценку размера `≤ 2^{depth}`;
  - `agreesWithAssignments_path_to_leaf` и `eval_tree_of_agrees_path`,
    показывающие, что путь до листа задаёт монохроматический субкуб;
  - `H₂_restrict_le`;
  - `sunflower_exists_classic`;
 - набор фактов о мере: `measure_restrict_le`, `measure_filter_le`,
    `measure_empty`, `measure_singleton`, `measure_pos_of_card_two_le`,
    `measure_restrict_lt_of_card_le_half`, `measure_filter_lt_of_card_le_half`.
- Существует каркас для объединения покрытий (`merge_low_sens.lean`) и
  добавлены леммы `merge_card_le_low_sens` и `merge_card_le_entropy` для оценки
  числа субкубов в объединённом покрытии; зафиксирована безопасная константа
  `C = 10` (`BoolFunc.coverConst`) для всех асимптотических оценок.
- Доказана лемма `buildCover_card_bound`; теперь `cover_exists_bound` и
  `FamilyCover` усилены до явной оценки `mBound`, и `entropyCover`
  строит покрытие с ограничением `≤ mBound n h` при условии
  `Fintype.card (Subcube n) ≤ mBound n h`.
- В модуле `cover_numeric.lean` временная аксиома `buildCover_card_le_pow2`
  заменена на доказанную лемму, так что оценка числа точек больше не
  зависит от дополнительных допущений.
- Ранее в `low_sensitivity_cover.lean` случай `A = ∅` обрабатывался через
  `entropyCover`; теперь лемма `nonconstant_all_insensitive_false` показывает,
  что такая ситуация противоречива при наличии функций, достигающих `true`,
  поэтому обращение к `entropyCover` больше не требуется.

- Разработана структура `CoverRes`, упаковывающая набор субкубов вместе с
  доказательствами монохроматичности, полноты и ограничением мощности.
  Базовые случаи реализованы конструкторами `CoverRes.empty` и
  `CoverRes.const`; лемма `CoverRes.as_cover` позволяет ослаблять оценку на
  число прямоугольников.  Выяснилось, что требование семейной
  монохроматичности слишком жёсткое: оно несовместимо с одновременным
  присутствием в семье тождественно ложной функции и функции, принимающей
  значение `true`.  Для дальнейших шагов введена ослабленная структура
  `CoverResP`, в которой для каждого прямоугольника требуются лишь
  точечные свидетельства константности всех функций семейства.
- Определение `CoverResP.toDecisionTree_for` преобразует покрытие в дерево
  решений для конкретной функции; леммы `CoverResP.leaf_count_le`,
  `CoverResP.depth_le_card_mul` и `CoverResP.depth_le_coverConst` связывают
  параметры дерева с оценкой размера покрытия.
 - Все регрессионные примеры собраны в модуле `test/CoverResBaseTest.lean`,
    который подключён к `lake test`. Добавлен пример, проверяющий корректность
    `CoverResP.toDecisionTree_for` на константной семье, тест на работу
    `CoverResP.lift_erase_false` при возвращении тождественно ложной функции,
    проверка склейки ветвей через `glue_branch_coversPw` на одноразрядной
    идентичной функции, новый пример, демонстрирующий спад меры
    `measureLex3` при ветвлении по чувствительной координате, а также тесты
    для лемм `budget_pos_of_sensitive` и `no_sensitive_of_budget_zero`.
- Принято решение отказаться от семейной монохромности и использовать
  **точечную**: каждый прямоугольник остаётся константным для каждой функции
  отдельно, но цвета могут различаться. Для построения дерева решений введена
  функция `CoverResP.toDecisionTree_for`, которая раскрашивает листья под
  конкретную функцию без изменения общей структуры.
- Новая обёртка `decisionTree_cover_of_coverResP` позволяет напрямую
  превращать структуру `CoverResP` в существование покрытия в формулировке
  теоремы. Базовые случаи `decisionTree_cover_of_constant` и
  `decisionTree_cover_empty` теперь выражены через неё.
- Добавлены преобразование `CoverRes.toCoverResP` и лемма
  `decisionTree_cover_of_coverRes`, связывающие семейные покрытия с точечной
  формулировкой.
- Лемма `decisionTree_cover_mBound` упаковывает результат
  `cover_exists_mBound` в формат `decisionTree_cover`, предоставляя явное
  покрытие с границей `Cover2.mBound n (n+1)` на числе прямоугольников.
- Введена конструкция `CoverResP.constFamily` и базовый случай
  `decisionTree_cover_of_constFamily`, покрывающий семейства, где каждая
  функция постоянна (возможно, с различными значениями).
- Лемма `decisionTree_cover_of_buildCover` объединяет рекурсивный конструктор
  `buildCoverLex3` с обёрткой `decisionTree_cover_of_coverResP`, напрямую
  предоставляя покрытие, соответствующее численной оценке теоремы.
- Для удобства применения введена вариация `decisionTree_cover_of_buildCover_choose_h`,
    автоматически выбирающая бюджет `h = n` и, благодаря обработке случая
    `n = 0` через `decisionTree_cover_of_constFamily`, не требующая предположения
    `0 < n`.
- Определена функция `decisionTreeBudget`, реализующая выбор бюджета
  \(h = \max(0, \lfloor s\log_2(n{+}1) - 1 - \frac{\log_2 n + \log_2(s\log_2(n{+}1)+3)}{\mathtt{coverConst}} \rfloor)\).
    Доказана лемма `mBound_le_pow_of_budget_choice_bigS`, связывающая
    `Cover2.mBound n (n + 1)` с оценкой \(2^{\mathtt{coverConst} \cdot s \cdot \log_2(n+1)}\)
    при `s ≥ n + 2`. Оценка для `s ≤ n + 1` остаётся недоказанной;
    дополнительная лемма `mBound_le_pow_of_budget_choice_smallS_false`
    показывает, что неравенство в целом неверно уже при `n = 1`, `s = 1`
    (`Cover2.mBound 1 2 = 4·2^{20} > 2^{10}`), что подтверждает необходимость
    другого подхода к малому случаю.
- В самой теореме `decisionTree_cover` теперь явно разбираются тривиальные
  случаи: при `F = ∅` используется `decisionTree_cover_empty`, для семейства
  из константных функций — `decisionTree_cover_of_constFamily`, а при `s ≥ n + 2`
  применяется лемма `mBound_le_pow_of_budget_choice_bigS`.  Случай `s ≤ n + 1`
  остаётся без доказательства и реализован в коде через `admit`.  Попытка
  свести его к существующей оценке `Cover2.mBound n (n + 1)` требует
  дополнительного не установленного неравенства
  `Cover2.mBound n (n + 1) ≤ 2^{\mathtt{coverConst} \cdot s \cdot \log_2(n+1)}`.
  Вероятно, необходим отдельный комбинаторный анализ или новое численное
  сравнение, не использующее `mBound`.
- В рекурсивной функции `buildCoverLex3A` временно применяется аксиома
  временная аксиома `no_sensitive_at_zero`, утверждавшая, что при исчерпании
  бюджета `h` внутри множества `A` не остаётся чувствительных координат, если
  их не было снаружи. Теперь этот пробел закрыт: `buildCoverLex3A` получает
  дополнительный инвариант `A.card ≤ h`.  Ветка `h = 0` обрабатывается явно:
  из `A.card ≤ 0` выводится `A = ∅`, после чего отсутствию чувствительных
  координат соответствует тривиальное покрытие одного субкуба.  При `h > 0`
  лемма `budget_pos_of_sensitive` гарантирует положительный бюджет при
  нахождении чувствительной координаты.  Её простое следствие
  `no_sensitive_of_budget_zero` подтверждает, что при нулевом бюджете внутри
  `A` чувствительных координат быть не может; для полного множества координат
  сформулировано специализированное следствие `no_sensitive_of_budget_zero_univ`.
  Рекурсия более не опирается на недоказанные утверждения.

### Локальная нечувствительность

В модуле `BoolFunc/Sensitivity.lean` введено понятие
`insensitiveCoordsAt f x`, возвращающее множество координат, на которых
функция `f` не реагирует на одиночный переворот бита в точке `x`.
Показано, что количество таких координат равно `n - sensitivityAt f x` и,
следовательно, при ограничении чувствительности `sensitivity f ≤ s` каждая
точка обладает минимум `n - s` локально нечувствительными координатами.
Дополнительно определено глобальное множество `insensitiveCoords f`
из координат, которые функция игнорирует во всех точках.  Оно вложено в
`insensitiveCoordsAt f x` для любого `x`, что позволит в будущем
расширять монохроматические подкубы за счёт таких координат.
Новое наблюдение связывает `insensitiveCoords f` с привычным понятием
поддержки: это точное дополнение к `support f`, и потому их мощности в сумме
дают `n`.  Таким образом, глобальная нечувствительность описывает те же
координаты, что и отсутствие в поддержке, но в более удобной для рекурсии
форме.
Дополнительно определён подкуб `supportSubcube f x`, фиксирующий все
координаты из `support f` в значениях точки `x`.  На нём функция `f`
оказалась монохроматичной, а его размерность совпадает с числом
глобально нечувствительных координат `insensitiveCoords f`.  В дальнейшем
этот подкуб позволит расширять ветви решающего дерева, не увеличивая
его глубину.

Новые леммы `flip_mem_supportSubcube` и
`flip_mem_supportSubcube_iff` описывают этот подкуб через операции
массового переворота битов: точка `Point.flip x S` лежит в
`supportSubcube f x` тогда и только тогда, когда все биты из `S`
глобально нечувствительны для `f`.  Это обеспечивает удобный мостик
между структурой подкуба и симметричными преобразованиями входа,
которые сохраняют значение функции.

Дополнительно `mem_supportSubcube_self` фиксирует, что базовая точка всегда
принадлежит своему `supportSubcube`, а лемма `supportSubcube_monochromatic`
формально доказывает монохроматичность этого подкуба.  В связке они дают
готовую конструкцию монохроматического блока вокруг любой точки, что будет
использоваться как базовый случай при построении покрытия.

Глобальная оценка чувствительности даёт грубую, но конструктивную
нижнюю границу на размерность `supportSubcube f x`:
`n - 2^n \cdot s \le (supportSubcube f x).dimension`.  Это означает,
что при малом `s` даже такая простая заморозка поддерживающих
координат оставляет много свободных направлений для дальнейшей
рекурсии в дереве решений.  В частности, сам `supportSubcube f x` уже
даёт подходящий монохроматический блок вокруг `x`, который можно
использовать при построении конечного покрытия.

Теперь построен более общий подкуб `insensitiveSubcubeAt f x`, который
замораживает лишь координаты, чувствительные в точке `x`, и потому
включает `supportSubcube f x` как частный случай.  Его размерность равна
числу локально нечувствительных координат `(insensitiveCoordsAt f x).card`,
что гарантирует минимум `n - sensitivityAt f x` свободных направлений.  При
глобальном ограничении `sensitivity f ≤ s` отсюда немедленно следует оценка
`(insensitiveSubcubeAt f x).dimension ≥ n - s` для любой точки `x`.  Эти
наблюдения подчёркивают связь между локальной структурой функции и объёмом
подкуба, с которого можно начинать ветвление решающего дерева.
Нулевая локальная чувствительность делает `insensitiveCoordsAt f x` равным
всей `Finset.univ`, и соответствующий подкуб `insensitiveSubcubeAt f x`
совпадает с полным кубом.  Дополнительно установлен точный критерий
принадлежности: перевод точки `x` с помощью `Point.flip` по множеству
индексов `S` остаётся внутри `insensitiveSubcubeAt f x` тогда и только
тогда, когда `S ⊆ insensitiveCoordsAt f x`.  В частности, базовая точка
`x` всегда лежит в своём `insensitiveSubcubeAt`.  Любой монохроматический
подкуб, проходящий через `x`, целиком содержится в `insensitiveSubcubeAt f x`
и не может иметь размерность больше `(insensitiveSubcubeAt f x).dimension`.
Однако сам подкуб `insensitiveSubcubeAt f x` не обязан быть монохроматичным:
контрпример `sensitivityTwoSupportFull` при `x = 0` демонстрирует наличие
разных значений внутри него.
Тем не менее, из глобального ограничения чувствительности можно извлечь
большой монохроматический субкуб, целиком лежащий внутри
`insensitiveSubcubeAt f x`.  Лемма
`exists_large_monochromatic_subcube_div_subset_insensitiveSubcubeAt`
гарантирует подкуб размерности не меньше `n/(2*s)` (при выполнении
дизъюнктивной численной гипотезы) и допускающий последующие перевороты лишь по
локально нечувствительным координатам.
Из такого вложенного подкуба можно явно извлечь множество локально
нечувствительных координат той же размерности, лежащее внутри
`insensitiveCoordsAt f x`.  Лемма
`exists_large_insensitive_subset_subset_insensitiveCoordsAt`
даёт такую конструкцию в безусловном виде с границей `n - 2^n·s`, а её точечная
форма `exists_large_insensitive_subset_pointwise_subset_insensitiveCoordsAt`
гарантирует равенство значений при совпадении вне найденного множества.
Для оптимизированной оценки `n/(2*s)` используются условные версии
`exists_large_insensitive_subset_div_subset_insensitiveCoordsAt`
предоставляет такой набор и обеспечивает инвариантность `f` при перевороте
любой его подмножины; её точечная форма
`exists_large_insensitive_subset_pointwise_div_subset_insensitiveCoordsAt`
удобна при последующем построении субкубов.
Комбинируя её с `monochromaticSubcube_of_pointwise`, получаем
`exists_large_monochromatic_subcube_div_subset_insensitiveCoordsAt`,
гарантирующую монохроматический субкуб той же размерности, свободные координаты
которого лежат внутри `insensitiveCoordsAt f x`.
На глобальном уровне показано, что `sensitivity f = 0` эквивалентно
пустой поддержке `support f`.
Эти факты подготовят почву для последующих шагов: из крупных нечувствительных
наборов планируется извлекать монохроматические ветви решающего дерева,
что позволит ограничить глубину построения `O(s · log n)`.

Дополнительно показано, что фиксация координаты не увеличивает поддержку:
`support (f.restrictCoord i b) ⊆ (support f).erase i`, откуда следует оценка
`(support (f.restrictCoord i b)).card ≤ (support f).card`. Это наблюдение
гарантирует, что при рекурсивном ветвлении размер поддержек монотонно падает,
по крайней мере удаляя фиксированную координату, и тем самым подготавливает
почву для более явного контроля глубины дерева решений.

Более того, положительная чувствительность гарантирует непустоту поддержки,
а фиксация действительно чувствительной координаты уменьшает её мощность
строго на единицу. Эти простые числовые факты обеспечивают, что рекурсивная
  процедура всегда имеет координату для ветвления и делает измеримый прогресс.

Также реализована стартовая конструкция дерева решений: лемма
`exists_decisionTree_depth_le_support_card` строит дерево глубины не больше
`|support f|`, последовательно ветвясь по координатам из поддержки. Эта грубая
оценка будет служить базовой отправной точкой перед применением более тонких
лемм о крупных нечувствительных наборах.

Для дальнейших комбинаторных аргументов удобно уметь переворачивать сразу
несколько координат.  В файле `BoolFunc.lean` добавлена операция `Point.flip`
и леммы, описывающие её действие: на элементах выбранного множества значение
инвертируется, а вне его остаётся прежним.  Это позволит в дальнейшем кратко
говорить о вершинах, отличающихся от исходной точки на заданном наборе индексов,
и формулировать утверждения о нечувствительности к целым группам битов.  Лемма
`Point.flip_insert` показывает, что последовательные перевороты по дизъюнктным
множествам можно объединять, а `Point.flip_flip` подтверждает инволютивность
переворота.

Для последующего построения неглубокого дерева решений введён конструктор
`DecisionTree.ofAssignments`, который превращает список пар `(i, b)` в
«цепочку» вопросов: на каждом шаге проверяется соответствующее значение
координаты, и при первом же несоответствии дерево переходит в лист с цветом
`!c`. Лемма `DecisionTree.eval_ofAssignments_of_agrees` гарантирует, что если
точка удовлетворяет всем условиям, результат равен `c`, а оценка
`DecisionTree.depth_ofAssignments_le` связывает глубину построенной цепочки с
длиной списка.  Этот примитив позволит компактно фиксировать большие группы
нечувствительных битов, не наращивая глубину дерева более чем на число
установленных координат.

Дополнительно определён конструктор `DecisionTree.ofSubcube`, который напрямую
превращает подкуб `R` в такую цепочку проверок.  Лемма
`DecisionTree.eval_ofSubcube_of_mem` утверждает, что любой `x ∈ R` ведёт к
правильному цвету, а `DecisionTree.depth_ofSubcube_le` оценивает глубину через
число фиксированных координат `R.idx.card`.  Введённая дополнительно лемма
`DecisionTree.depth_ofSubcube_le_codim` переформулирует эту оценку через
кодимeнсию `n - R.dimension`, что удобно при наличии априорного нижнего
барьера на размерность.  Это связывает абстрактные подкубы с явными ветвями
дерева решений.

Для симметричного преобразования на стороне функций введена вспомогательная
операция `BFunc.restrictAssignments`: она последовательно применяет
`restrictCoord`, фиксируя множество координат согласно списку пар `(i, b)`.
Лемма `restrictAssignments_agrees` показывает, что точка, удовлетворяющая всем
этим присваиваниям, даёт одинаковое значение и для исходной, и для
ограниченной функции.  Такая конструкция позволит в рекурсии сразу «замораживать»
несколько переменных и переходить к задаче меньшей размерности.
Новые факты `sensitivity_restrictAssignments_le` и
`coordSensitivity_restrictAssignments_self_zero` уточняют, что массовое
ограничение не увеличивает чувствительность и делает фиксированные координаты
глобально нечувствительными.  Это гарантирует сохранение инварианта
`sensitivity ≤ s` при последовательной фиксации большого набора битов.
Дополнительно, леммы `support_restrictAssignments_subset` и
`support_card_restrictAssignments_le` показывают, что после применения списка
присваиваний множество существенных координат только уменьшается, и тем самым
задача действительно переходит к подфункции меньшей размерности.
Новая лемма `eval_flip_subset_insensitiveCoords` показывает, что если функция
полностью игнорирует некоторые координаты, то одновременный переворот любого их
конечного подмножества оставляет значение функции неизменным.
Её следствие `eval_eq_of_eq_on_compl_insensitive` формулирует это свойство через
совпадение двух точек вне фиксированного множества: если `y` совпадает с `x`
по всем координатам за пределами глобально нечувствительных, то `f y = f x`.
Лемма `exists_large_insensitive_subset_pointwise` извлекает такой набор
координат размером `≥ n - 2^n·s` вокруг любой точки, предоставляя явный
монохромный подкуб для дальнейшего ветвления.
Дополнительно, если глобальное ограничение чувствительности достаточно
строгое (условие `2^n·s ≤ n - n/(2*s)`), лемма
`exists_large_insensitive_subset_div_of_small` напрямую строит подмножество
мощности `n / (2*s)` из глобально нечувствительных координат, что частично
закрывает целевое неравенство.
Её субкубное следствие `exists_large_monochromatic_subcube_div_of_small`
превращает это множество в монохроматический подкуб той же размерности,
предоставляя явный регион для дальнейших рекурсивных шагов.  Общая
связка между субкубами и наборами нечувствительных координат обеспечена
леммой `exists_large_insensitive_subset_of_monochromatic_subcube`, которая
переводит нижнюю оценку на размерность произвольного монохроматического
подкуба в явное множество из не менее чем `k` координат, инвариантных к
переворотам вокруг базовой точки.
Объединяя результаты, лемма `exists_large_insensitive_subset_div` охватывает
оба числовых сценария — малую поддержку и грубое глобальное ограничение — и
даёт единый способ построить большое нечувствительное множество.
Также получена оценка `∑_x sensitivityAt f x ≤ 2^n·s`, связывающая суммарную
чувствительность на всём кубе с глобальным пределом `sensitivity f ≤ s` и
подготавливающая почву для вероятностных рассуждений.  Через двойной подсчёт
получено тождество `∑_x sensitivityAt f x = ∑_i coordSensitivity f i`, что
дополнительно ограничивает суммарную чувствительность по координатам.
Из этого сразу вытекает грубое ограничение мощности поддержки: лемма
`support_card_le_sum_coordSensitivity` показывает, что число существенных
координат не превосходит суммарной координатной чувствительности, а
`support_card_le` переводит глобальное ограничение
`sensitivity f ≤ s` в оценку `|support f| ≤ 2^n·s`.
Дополнительно, лемма `coordSensitivity_pos_of_mem_support` отмечает, что любая
координата из поддержки действительно встречает ненулевую чувствительность.

Полученная оценка на поддержку позволяет явно строить большой блок глобально
нечувствительных координат.  Лемма
`exists_large_insensitive_subset_of_support_le` выделяет множество размера
`n - m` при условии `|support f| ≤ m`, её специализация
`exists_large_insensitive_subset_div_of_support` формулирует результат в виде
`|A| ≥ n / (2*s)`.  Применение точечной версии
`exists_large_insensitive_subset_pointwise_div_of_support`
вместе с новой `monochromaticSubcube_of_pointwise`
даёт лемму
`exists_large_monochromatic_subcube_pointwise_div_of_support`,
гарантирующую монохроматический субкуб размерности не меньше `n / (2*s)` при
условии `|support f| ≤ n - n/(2*s)`.  Эта точечная форма показывает, что
любое множество точек, совпадающих с базовой вне выбранного `A`, принимает то
же значение функции.
Дополнительная лемма `eval_eq_of_mem_of_monochromatic` упрощает извлечение
равенства значений из факта монохроматичности: любые две точки внутри одного
и того же субкуба дают одинаковый результат.

Комбинированная лемма `exists_large_insensitive_subset_div` объединяет обе
стратегии: она строит множество мощности `n / (2*s)` при выполнении хотя бы
одного из условий `2^n·s ≤ n - n/(2*s)` или `|support f| ≤ n - n/(2*s)`.
Её точечная и субкубная формы — `exists_large_insensitive_subset_pointwise_div`
и `exists_large_monochromatic_subcube_div` — позволяют напрямую получать
монохроматические подкубы той же размерности.  Полностью безусловное
утверждение остаётся задачей для будущей работы.

Дополнительно установлен численный факт `div_two_mul_le_sub`, показывающий, что
при положительном `s` нижнюю границу `n - s` можно ослабить до `n / (2*s)`.
Сочетая его с `exists_large_insensitiveCoordsAt`, получаем лемму
`exists_insensitiveCoordsAt_card_ge_div`, предоставляющую явное множество из
`n / (2*s)` локально нечувствительных координат в любой точке.
Отсюда также следует оценка ` (insensitiveSubcubeAt f x).dimension ≥ n / (2*s)`:
раз размер `insensitiveCoordsAt f x` таков, то и подкуб, фиксирующий все
чувствительные биты, имеет не меньшую размерность.

Дополнительно лемма `exists_insensitiveCoordsAt_card_eq_div` позволяет выбрать
подмножество ровно из `n / (2*s)` локально нечувствительных координат, что
удобно при рекурсивном ветвлении в дереве решений.

Ещё два наблюдения усиливают связь чувствительности с глобальной структурой.
Во‑первых, максимум в определении `sensitivity f` достигается: существует точка
`x`, для которой `sensitivityAt f x = sensitivity f`.  Эта точка служит
конкретным свидетелем максимальной чувствительности и пригодится при выборе
опорных вершин в рекурсивной конструкции.
Во‑вторых, если поддержка `support f` не заполняет весь набор координат,
находится хотя бы одна глобально нечувствительная координата.  Она позволяет
расширять монохроматические подкубы без увеличения глубины дерева решений.
Дополнительно из глобального ограничения чувствительности получена оценка
`insensitiveCoords_card_ge_of_global`: число таких координат не меньше
`n - 2^n·s`, и лемма `exists_insensitiveCoords_card_eq_of_global` предоставляет
явное множество указанной мощности.

- Дополнительно сформулирована общая конструкция
  `monochromaticSubcube_of_insensitive_subset`, которая из любого множества
  глобально нечувствительных координат строит монохромный подкуб той же
  размерности.  Подставляя в неё множество из
  `exists_insensitiveCoords_card_eq_of_global`, получаем лемму
  `exists_large_monochromatic_subcube`, гарантирующую субкуб размерности не
  меньше `n - 2^n·s`, содержащий произвольную точку `x` и на котором `f`
  постоянна.  Это станет строительным блоком при формировании неглубоких
  решающих деревьев.

  В обратную сторону, лемма `insensitive_subset_of_monochromatic_subcube`
  извлекает из произвольного монохроматического подкуба явное множество
  координат, инвариантное к массовым переворотам.  Его мощность равна
  размерности подкуба, что позволяет переходить от субкубов к наборам
  нечувствительных битов и обратно.  Её численное следствие
  `exists_large_insensitive_subset_of_monochromatic_subcube` формулирует тот
  же переход через произвольное нижнее ограничение `k` на размерность,
  гарантируя существование множества из как минимум `k` глобально
  нечувствительных координат вокруг выбранной точки.

  Дополнительно, ограничение на размер поддержки приводит к более точным
  результатам.  Леммы `exists_large_insensitive_subset_of_support_le` и
  `exists_large_insensitive_subset_div_of_support` извлекают крупное множество
  глобально нечувствительных координат напрямую из условия
  `|support f| ≤ m`.  Их точечная версия
  `exists_large_insensitive_subset_pointwise_div_of_support` гарантирует
  неизменность значения на любом наборе точек, совпадающих с базовой
  вне выбранного множества.  Новая лемма
  `monochromaticSubcube_of_pointwise` превращает такую точечную
  нечувствительность в явный субкуб, что в сочетании даёт
  `exists_large_monochromatic_subcube_pointwise_div_of_support`,
  обеспечивающую субкуб размерности `≥ n / (2*s)` при оценке
`|support f| ≤ n - n/(2*s)`.  Дополнительно, лемма
`insensitiveCoords_card_ge_div_of_support` напрямую оценивает
мощность глобально нечувствительных координат: при том же ограничении на
поддержку гарантируется `|insensitiveCoords f| ≥ n/(2*s)`.  В сочетании с
грубым неравенством `|support f| ≤ 2^n * s` из глобальной чувствительности
получается лемма `insensitiveCoords_card_ge_div_of_small`, обеспечивающая ту
же границу при дополнительном численном условии `2^n * s ≤ n - n/(2*s)`.
Объединяющая лемма `insensitiveCoords_card_ge_div` охватывает оба случая и
выводит нижнюю границу из дизъюнкции этих двух числовых условий.
Комбинированная форма `exists_large_insensitive_subset_div` использует эти
подходы одновременно: большое нечувствительное множество существует, если
выполнено хотя бы одно из числовых ограничений.

  Однако без подобных ограничений утверждение не верно.  Пример
  `f(x₀,x₁,x₂,x₃) = (x₁ ∧ x₂) ∨ (x₃ ∧ x₀)` имеет чувствительность `2` и
  использует все четыре координаты, поэтому `insensitiveCoords f = ∅` и
  нижняя граница `|insensitiveCoords f| ≥ n/(2*s)` нарушается.  Для снятия
  аксиомы потребуется иной подход, опирающийся на локальные подкубы
  `insensitiveSubcubeAt` или более тонкие вероятностные аргументы.

Следующий этап — усилить это утверждение до асимптотически оптимальной границы
`≥ n / (2*s)`.  Здесь потребуется новый комбинаторный аргумент, фактически
реализующий известную из теории *шумоустойчивость* функций малой чувствительности.
Идея состоит в анализе случайных ограничений: при выборе каждого бита с
вероятностью `1/(2*s)` функция меняется с малой вероятностью, поэтому можно
деревянным перебором найти конкретное множество `A` такой плотности, что на
подкубе `x ⊕ A` значение `f` неизменно.  Формализация этой схемы разбивается на
несколько лемм:

1. Определить операцию `randomRestrict` и доказать оценку ожидания
   `E[sensitivityAt (randomRestrict f) x] ≤ sensitivity f / 2`.
2. Показать, что существует конкретное ограничение, обнуляющее половину
   локальной чувствительности в выбранной точке.
3. Итеративно применяя эту процедуру, извлечь множество размера не меньше
   `n / (2*s)`, на котором `f` постоянно.

После реализации этих шагов появится лемма
`exists_large_insensitive_subset_div`, полностью снимающая дополнительные
численные ограничения.  На данный момент реализована комбинированная версия,
охватывающая случаи малого глобального параметра или небольшого `support`, но
общее безусловное утверждение остаётся открытым.  В арсенале уже есть леммы
`exists_large_insensitive_subset_div_of_small`,
`exists_large_insensitive_subset_of_support_le`,
`exists_large_insensitive_subset_div_of_support`, их точечная форма
`exists_large_insensitive_subset_pointwise_div_of_support` и субкубное
следствие `exists_large_monochromatic_subcube_pointwise_div_of_support`.

## Ключевые вопросы и текущий статус

1. **Энтропийная оценка**
 *Сделано:* введена мера `measure F = Nat.ceil (H₂ F)` и принято безопасное
  ограничение `measure F ≤ 10 · s · log₂(n+1)`. Грубая граница из леммы
  `buildCover_card_bound` остаётся в силе, но теперь подготовлен отдельный
  документ `asymptotic_cover_estimates.md`, где эта граница сведена к
  асимптотическим формам `2^{C⋅h}` и `(n+1)^{O(s)}`, согласующимся с
  результатами Gopalan–Moshковitz–Oliveira. Дополнительно леммы
  `cover_exists_mBound`, `coverFamily_card_le_mBound` и обновлённая
  `entropyCover` связывают эти оценки с каноническим покрытием в коде.

2. **Строгое уменьшение меры**
 *Сделано:* леммы `measure_restrict_le`, `measure_restrict_decreases`,
 `measure_restrict_lt_of_card_le_half` и `measure_filter_lt_of_card_le_half`
 показывают падение меры при существенном уменьшении семейства. Добавлена
 оценка `card_le_mul_card_restrict`, ограничивающая размер семейства через
 произведение размеров обеих ветвей при фиксировании координаты. Новые
 результаты `measureLex3_restrict_lt_of_restrict_eq` и
 `measureLex3_restrict_lt_of_card_le_half` переводят эти уменьшения на тройную
 меру `measureLex3`, а лемма `exists_branch_measure_drop_of_sensitive` гарантирует
 спад меры при выборе чувствительной координаты. Добавлена специализированная
 версия `exists_branch_measure_drop_univ`, упрощающая работу со всем набором
 координат сразу. Введены явные операции `restrictDrop` и `extendDrop`,
 моделирующие фиксирование чувствительной координаты и последующее
 восстановление субкуба; леммы `measureLex3_restrictDrop_lt` и
 `measureLex3_restrictDrop_univ_lt` формализуют строгое убывание меры при
 такой операции. Дополнительно этап склейки ветвей (`extend_union_cover` и его
 точечная версия) переписан через `extendDrop`, подчёркивая симметрию с
 `restrictDrop` и подготавливая интеграцию ветвления в рекурсивный алгоритм.
  *Сделано:* эти оценки встроены в рекурсивный алгоритм `buildCoverLex3`.
  Ветвление по чувствительной координате использует `restrictDrop` и
  `glue_branch_coversPw_mBound`, а леммы `measureLex3_restrictDrop_lt` и
  `measureLex3_restrictDrop_univ_lt` фиксируют спад тройной меры в обеих
  ветвях.

3. **Выбор чувствительного бита**
   *Сделано:* лемма `non_constant_family_has_sensitive_coord` находит
   чувствительную координату после удаления тождественно ложных функций;
  подготовлены базовые случаи `CoverResP.empty` и `CoverResP.const`, а также
 лемма `glue_branch_coversPw`, нормализующая покрытия ветвей и объединяющая
  их в точечном формате.
  В текущей версии чувствительный случай обрабатывается упрощённо:
  для каждой ветви строится точечное покрытие (`pointCover`), после чего
  результаты склеиваются через `glue_branch_coversPw_mBound`.  Полноценная
  рекурсивная реализация с последующим уменьшением множества координат
  запланирована на следующих этапах.

4. **Монадическое построение дерева**
   *Сделано:* разработана стратегия: сначала строится покрытие субкубами, затем
  оно переводится в `DecisionTree`. Введена функция `CoverResP.toDecisionTree_for`,
  окрашивающая листья под выбранную функцию, и доказаны леммы
  `CoverRes.eval_true`, `CoverRes.eval_false`,
  `CoverResP.leaf_count_le`, `CoverResP.depth_le_card_mul`,
  `CoverResP.depth_le_coverConst`, `CoverResP.eval_true` и
  `CoverResP.eval_false`, демонстрирующие корректность дерева и его связь
  с мощностью покрытия.
  *Осталось:* для каждой `f ∈ F` использовать построенное дерево в доказательстве
  `decisionTree_cover` и связать его глубину с энтропийной оценкой.

5. **Оценка глубины**
   *Сделано:* лемма `DecisionTree.leaf_count_le_pow_depth` связывает число
   листьев с глубиной.
   *Осталось:* связать её с энтропийной мерой и доказать
   `depth ≤ C · s · log₂(n+1)` по завершении рекурсии.

   Дополнительно требуется аритметический мост между оценкой размера покрытия
   `Cover2.mBound` и окончательной границей `2^{C · s · log₂(n+1)}`. Пока не
   получено неравенство `Cover2.mBound n (n+1) ≤ 2^{C · s · log₂(n+1)}`, что
   необходимо для передачи результатов `buildCoverLex3` в формулировку
   `decisionTree_cover`.

6. **Оптимизация стиля**  
   *Сделано:* многие технические шаги вынесены во вспомогательные леммы,
   упрощающие основное доказательство.  
   *Осталось:* продолжить рефакторинг, чтобы `decisionTree_cover` оставалась
   короткой и концептуальной.

  7. **Гарантия терминирования**
    *Сделано:* тройная мера `measureLex3` обеспечивает строгий спад как при
    удалении тождественно `false` функций, так и при ветвлении по чувствительной
    координате.  В рекурсивной функции `buildCoverLex3A` параметр множества
    координат `A` сокращается до `A.erase i`, а энтропийный бюджет `h` уменьшается
    на каждом шаге, что делает рекурсию по мере хорошо основанной. Леммы
    `measureLex3_erase_lt` и `measureLex3_restrictDrop_lt` используются в
    блоке `decreasing_by` для обеих ветвей. В прежней версии требовалась
    аксиома `no_sensitive_at_zero`; теперь её заменяет доказанный инвариант
    `A.card ≤ h` вместе с леммой `budget_pos_of_sensitive`, показывающей, что
    наличие чувствительной координаты автоматически влечёт строго положительный
    бюджет `h`.  Дополнительное следствие `no_sensitive_of_budget_zero`
    формализует противоположное направление: если бюджет исчерпан, то
    чувствительных координат в `A` не осталось.

## Детализированный план

Ниже перечислены все оставшиеся шаги с указанием предполагаемой сложности и
точек входа в кодовую базу. Предпочтительный маршрут сейчас — **вариант Б** с
лексикографической мерой, при этом **вариант А** с жёстким делением пополам
рассматривается как возможное упрощение.

### 0) Опорные определения и константы

- ✅ Зафиксирована константа `C = 10` (`BoolFunc.coverConst`) во всех оценках
  глубины и размера покрытия.  **Файлы:** `Pnp2/low_sensitivity_cover.lean`,
  тесты.

### 1) Мера и её убывание

1. ✅ Определена лексикографическая мера `measureLex` и показана её
   хорошая основанность `measureLexRel_wf`.  **Файл:** `entropy.lean`.
2. ✅ Лемма `measureLex_restrict_decreases` показывает, что при уменьшении
   мощности ветви лексикографическая мера падает.  **Файл:** `entropy.lean`.
3. ✅ Лемма `card_restrict_lt_of_restrict_eq` фиксирует, что если две функции
   семьи совпадают после фиксации координаты, то соответствующая ветвь
   строго уменьшается по числу функций.  **Файл:** `BoolFunc.lean`.
4. ✅ Лемма `measureLex_restrict_lt_of_restrict_eq` объединяет две предыдущие:
   при наличии такой совпадающей пары лексикографическая мера ветви
   строго падает.  **Файл:** `entropy.lean`.
   🔧 Лемма `exists_branch_measure_drop_of_sensitive` показывает, что сама
   чувствительность уже обеспечивает спад тройной меры `measureLex3`: даже в
   контрпримере `{id, not}` на одном бите ветви сохраняют мощность, но
   удаление чувствительной координаты уменьшает размерность и гарантирует
   прогресс рекурсии.  **Файл:** `entropy.lean`.
5. ✅ Лемма `measureLex_restrict_lt_of_card_le_half` показывает, что если после
   фиксации координаты в ветви остаётся не больше половины функций,
   лексикографическая мера строго падает. **Файл:** `entropy.lean`.
6. ✅ Лемма `exists_branch_lex_smaller_of_half` упаковывает предыдущий результат
   в экзистенциальную форму: из свидетельства половинного уменьшения семейства
   немедленно следует строгий спад лексикографической меры. **Файл:**
   `entropy.lean`.  *Осталось:* связать чувствительную координату с наличием
   такой «половинной» ветви или пары функций, совпадающих после ограничения.
7. ✅ Лемма `exists_branch_lex_smaller_of_merge` показывает, что если две
   функции семьи совпадают после ограничения по некоторой координате, то
   соответствующая ветвь уменьшает лексикографическую меру. **Файл:**
   `entropy.lean`.
8. ✅ Введена тройная лексикографическая мера `measureLex3 F A =
   (measure F, F.card, A.card)` и доказана лемма
   `measureLex3_restrict_lt_dim`, гарантирующая спад по третьему компоненту при
   удалении чувствительной координаты из множества `A`. **Файл:** `entropy.lean`.
   ✅ Добавлен рекурсивный каркас `buildCoverLex3`, использующий эту меру для
   well-founded индукции по парам `(F, A)`. **Файл:** `low_sensitivity_cover.lean`.
  🔧 В `buildCoverLex3` перед ветвлением удаляются тождественно ложные функции,
   затем выбирается чувствительная координата из `A`, и покрытия ветвей
   нормализуются и склеиваются при помощи `glue_branch_coversPw`. Для перехода
   от подсемейства обратно к исходному добавлена лемма
  `CoverResP.lift_erase_false`, наследующая покрытие после удаления
   константно ложной функции и корректная для точечной монохроматичности.
   *Осталось:* заменить все обращения к семейной версии на точечную и
   провести анализ операций `restrictDrop`/`extendDrop` с соответствующими
   леммами о мере.
9. ✅ Новая лемма `H₂_le_of_measure_le` связывает целочисленную меру с
   исходным ограничением на энтропию: из `measure F ≤ h` следует `H₂ F ≤ h`.
   Это позволит в базовых случаях напрямую применять энтропийное покрытие.
   **Файл:** `entropy.lean`.
10. ✅ Показано, что при наличии функции с `true`‑значением ситуация `A = ∅`
    противоречива (лемма `nonconstant_all_insensitive_false`), поэтому
    отдельный случай с `entropyCover` более не требуется.

### 2) «Неконстантность ⇒ чувствительный бит» в рекурсии

- ✅ Добавлена вспомогательная лемма `exists_sensitive_coord_true_false`,
  возвращающая чувствительную координату вместе с точкой, где значение падает
  с `true` на `false`.  Она подготовлена для дальнейшей рекурсивной
  конструкции.  **Файл:** `low_sensitivity_cover.lean`.
  ✅ В `Sensitivity.lean` введена функция `coordSensitivity` и лемма
  `exists_sensitive_coord_in_A`, позволяющая выбирать чувствительную
  координату внутри заданного множества `A` при условии, что вне `A`
  чувствительность занулена.
  ✅ Введена ориентированная версия `exists_sensitive_coord_true_false_in_A`,
  возвращающая координату из `A` вместе с точкой, где значение падает с
  `true` на `false`.  **Файл:** `low_sensitivity_cover.lean`.
  ✅ Новая лемма `insens_off_A_restrict` показывает, что после фиксации бита
  инвариант нечувствительности вне `A` сохраняется для `A.erase i`.
  **Файл:** `Sensitivity.lean`.
  ✅ Инвариант `insens_off_A` теперь передаётся через рекурсивный каркас
  `buildCoverLex3` при помощи вспомогательной структуры `BuildInv`.
  ✅ В самой рекурсии используется `exists_sensitive_coord_true_false_in_A`
  для выбора координаты.
  *Осталось:* внедрить нормализацию и склейку ветвей через
  `glue_branch_coversPw`, чтобы рекурсивное покрытие сразу возвращало
  требуемые доказательства.


### 3) Склейка покрытий двух ветвей

- ✅ Лемма `monochromaticForFamily_extend_restrict` уже доказывает
  корректность расширения субкуба.
- ✅ Добавлены операция `Subcube.unfix` и усиленная лемма
  `cover_normalize_branch`, которая с помощью новой теоремы
  `monochromaticForFamily_unfix_of_insensitive` нормализует покрытия ветвей,
  устраняет фиксацию выбранного бита и сохраняет монохроматичность.
  Добавлена также однофункциональная версия `monochromaticFor_unfix_of_insensitive`
  и новая лемма `cover_normalize_branch_pointwise`, которые готовят почву для
  дальнейшего перехода к точечной монохроматичности.
  **Файлы:** `low_sensitivity_cover.lean`.
- ✅ Реализована лемма `cover_all_inputs_extend_union`, показывающая,
  что покрытия ветвей после расширения объединяются в покрытие исходного
  семейства.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Лемма `disjoint_extend_images` устанавливает, что расширения ветвей по
  противоположным значениям `i` не пересекаются, позволяя суммировать их
  мощности.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Добавлена лемма `card_extend_union_le`, оценивающая мощность
  объединения расширенных ветвей сверху через сумму мощностей исходных
  покрытий.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Новая лемма `extend_union_cover` объединяет все предыдущие результаты:
  из покрытий ветвей можно получить покрытие исходного семейства с контролем
  мощности.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Введена структура `CoverResP` и определение `glue_step`, упаковывающее
  результат склейки в удобный формат с явным ограничением на число субкубов.
  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Лемма `glue_branch_coversPw` нормализует покрытия ветвей, склеивает их и
  переносит оценку мощности `k₀ + k₁` на объединённый результат, готовя почву
  для рекурсивного доказательства.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Добавлена лемма `glue_branch_coversPw_mBound`, которая сразу выводит
  ограничение `mBound n (h + 1)` для склеенного покрытия и пригодится при
  учёте мощности в рекурсивном конструкторе.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Определение `CoverResP.empty` задаёт тривиальное покрытие для пустого
  семейства: прямоугольников нет, и условия монохроматичности и покрытия
  выполняются автоматически.  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Определение `CoverResP.const` строит базовое покрытие из одного полного
  субкуба для семейства, где все функции принимают одинаковое значение.
  Это заготовка для базового случая будущей рекурсии.
  **Файл:** `low_sensitivity_cover.lean`.

  ✅ `buildCoverLex3` переписан так, что возвращает заготовку `CoverResP`;
  последующие версии встроят вызовы `glue_branch_coversPw` для склейки ветвей
  и доведут доказательства точечной монохроматичности, покрытия и оценки мощности.

### 4) Построение дерева из покрытия

- ✅ Добавлена заготовка `DecisionTree.ofRectCover`, превращающая набор
  субкубов в дерево решений.  Добавлены вспомогательные леммы
  `matches_toList_of_mem`, `eval_matchSubcube_matches` и
  `eval_ofRectCoverList_cons_mem`, обеспечивающие корректность расчёта
  цвета на точках внутри каждого субкуба.
- ✅ Получены оценки числа листьев, глубины и числа окрашенных субкубов.
  Леммы `leaf_count_matchSubcube` и `leaf_count_ofRectCoverList_le`
  связывают количество листьев построенного дерева с длинами списков
  субкубов; `depth_matchSubcube_le` и `depth_ofRectCoverList_le` оценивают
  глубину через суммарную длину этих списков; `coloredSubcubes_ofRectCover_card_le`
  переносит ту же оценку на мощность множества окрашенных субкубов;
  `coloredSubcubes_cover_eval` (и частные `coloredSubcubes_cover_true`/
  `coloredSubcubes_cover_false`) гарантирует, что каждый вход покрыт
  подходящим субкубом.  Связь с глобальной оценкой
  `DecisionTree.leaf_count_le_pow_depth` всё ещё требует исследования.
  **Файл:** `DecisionTree.lean`.
- ✅ Добавлен упрощённый конструктор `DecisionTree.branchOnSubcube`,
  специализирующий `matchSubcube` на уже заданном субкубе.  Доказаны
  леммы `eval_branchOnSubcube_mem`, `eval_branchOnSubcube_not_mem` и
  `depth_branchOnSubcube_le`, позволяющие легко ветвиться по известному
  монохромному субкубу без ручного управления списком присваиваний.
- ✅ Построен вспомогательный шаг `branchLargeInsensitive`, который
  выделяет большой глобально нечувствительный субкуб и добавляет в дерево
  ветку, мгновенно возвращающую правильный цвет на всём этом субкубе.
  Лемма `depth_branchLargeInsensitive_le` оценивает прирост глубины через
  кодимeнсию выбранного субкуба.
- ✅ Леммы `eval_branchLargeInsensitive_mem`,
  `eval_branchLargeInsensitive_not_mem` и
  `eval_branchLargeInsensitive_self` уточняют поведение
  этого шага: на выбранном субкубе дерево всегда выдаёт `f x`,
  а вне его — делегирует вычисление запасному дереву.
  Дополнительная лемма `eval_branchLargeInsensitive` показывает, что если
  запасное дерево корректно вычисляет исходную функцию на всём кубе, то после
  добавления шага `branchLargeInsensitive` корректность сохраняется.
- Точечная лемма `eval_branchLargeInsensitive_off` утверждает, что вне
  выделенного субкуба дерево с добавленной веткой совпадает с исходной
  функцией, если запасное дерево давало правильный ответ в той точке.
  Это позволяет по одному добавлять монохроматические блоки, постепенно
  расширяя область корректности.
- ✅ Реализована функция `CoverResP.toDecisionTree_for`, превращающая
  структурированное покрытие в исполнимое дерево решений для выбранной
  функции. Новые леммы `CoverResP.leaf_count_le`, `CoverResP.depth_le`,
  `CoverResP.eval_true`, `CoverResP.eval_false`, `CoverResP.eval` и
  `CoverResP.depth_le_card_mul` связывают число листьев и глубину дерева с
  размерами покрывающих субкубов, а также подтверждают корректность
  вычисления дерева. Это подготавливает переход к глобальной оценке.
  **Файлы:** `low_sensitivity_cover.lean`, `DecisionTree.lean`.
- ✅ Сама теорема `decisionTree_cover` переформулирована с точечной
  монохромностью: для каждого прямоугольника запрашивается константность
  каждой функции семейства. Доказательство пока остаётся незавершённым.

### 5) Глобальная оценка глубины

- ✅ Получено общее неравенство `depth ≤ n · k` для дерева, построенного из
  покрытия `CoverResP` с `k` прямоугольниками (`CoverResP.depth_le_card_mul`).
  **Файл:** `low_sensitivity_cover.lean`.
- ✅ Лемма `CoverResP.depth_le_of_card_le` позволяет подставлять внешнюю оценку
  на число прямоугольников, а её специальный случай
  `CoverResP.depth_le_coverConst` фиксирует верхнюю границу через глобальную
  константу `coverConst`.  **Файл:** `low_sensitivity_cover.lean`.
- Собрать итоговую оценку числа листьев и перевести её в ограничение на глубину:
  `depth ≤ C · s · log₂(n+1)`.  **Сложность:** низкая.  **Файл:**
  `low_sensitivity_cover.lean`.

### 6) Вспомогательные леммы и рефакторинг

- Довести до ума набор утилит для `Finset`, `Nat.ceil` и логарифмов, чтобы
  доказательство оставалось кратким и ясным.  **Сложность:** низкая.

### 7) Опциональные задачи

- При желании формализовать оценку `H₂(F) ≤ C · s · log(n+1)` вместо приёма
  “безопасной константы”.

## Ожидаемый результат

После реализации плана аксиома `decisionTree_cover` будет заменена
конструктивной теоремой с границей `depth ≤ 10 · s · log₂(n+1)`, основанной на
строгом убывании выбранной меры.  Это закроет один из ключевых фрагментов
проекта и приблизит доказательство FCE‑Lemma.


## Оставшиеся шаги

Задача о комбинаторной оценке числа субкубов закрыта и удалена из списка.
Ниже собраны все остальные задачи, которые нужно завершить перед тем, как
удалить данный план и перенести итоговое доказательство в основную
документацию.

Перед продолжением работ зафиксируем несколько решений, вытекающих из дополнительного анализа:

- В покрытии переходим на **точечную монохромность**: прямоугольник должен быть константным для каждой функции семейства, но цвет может зависеть от самой функции. Для построения деревьев используется `CoverResP.toDecisionTree_for`, который окрашивает листья под выбранную функцию.
- Инвариант `BuildInv` менять не нужно: рекурсивная функция `buildCoverLex3` возвращает структуру `CoverResP` и использует `glue_branch_coversPw` для склейки ветвей.
- Основной маршрут — **вариант B** с лексикографической мерой; «жёсткое деление пополам» рассматривается лишь как возможное упрощение в будущем.

1. **Связь чувствительности с уменьшением меры.**
    - Доказаны леммы `measureLex3_restrict_lt_of_restrict_eq` и `measureLex3_restrict_lt_of_card_le_half`, а также существование ветви со спадом `measureLex3` (`exists_branch_measure_drop_of_sensitive`).
    - `buildCoverLex3` теперь использует `measureLex3` в качестве функции
      терминации: удаление тождественно ложной функции уменьшает тройную
      меру по лемме `measureLex3_erase_lt`.
    - Добавлена лемма `measureLex3_drop_coord`, показывающая, что исключение
      координаты из набора `A` снижает третью компоненту меры без изменения
      семейства.
    - В чувствительной ветви `buildCoverLex3` теперь выполняется
      полноценное рекурсивное деление: обнаружив координату `i`,
      функция вызывает `buildCoverLex3A` на подсемействах
      `F.restrict i false` и `F.restrict i true`, после чего склеивает
      результаты через `glue_branch_coversPw_mBound`.
    - Обёртки `CoverResP.pointCover_succ`, `CoverResP.const_mBound` и
      `CoverResP.const_mBound_exact` при необходимости увеличивают бюджет
      `mBound`, но основная логика основана на рекурсивных вызовах.
   - ✅ Устранена прежняя аксиома `no_sensitive_at_zero`: введён инвариант
     `A.card ≤ h` и доказана лемма `budget_pos_of_sensitive`, обеспечивающая
     положительность бюджета при наличии чувствительной координаты.
2. **Рекурсивное построение покрытия.**
    - ✅ `buildCoverLex3` теперь возвращает структуру `CoverResP`; в отсутствие
      чувствительных координат покрытие сводится к одному полному кубу с
      помощью леммы `all_true_of_no_sensitive_coord`.
3. **Переход от покрытия к дереву решений.**
    - ✅ Построена функция `CoverResP.toDecisionTree_for` и доказана лемма
      `CoverResP.eval`, подтверждающая корректность вычислений для каждой
      функции семейства.
    - На базе этих результатов получен мост
      `decisionTree_cover_of_coverRes`, позволяющий конвертировать
      `CoverRes` в спецификацию `decisionTree_cover`.
4. **Оценка числа прямоугольников и глубины.**
    - ✅ Леммы `decisionTree_cover_of_coverResP` и `decisionTree_cover_mBound`
      связывают границу `mBound` с экспонентой `2^h`, обеспечивая нужную
      оценку числа прямоугольников.
    - Введена функция выбора бюджета `decisionTreeBudget`. Для случая
      `s ≥ n + 2` доказана лемма `mBound_le_pow_of_budget_choice_bigS`,
      сравнивающая `Cover2.mBound` с требуемой границей `2^{coverConst·s·log₂(n+1)}`.
      Случай `s ≤ n + 1` остаётся открытым, поэтому общее неравенство
      `mBound_le_pow_of_budget_choice` ещё не завершено. Кроме того, текущая
      реализация `buildCoverLex3` требует условия `n ≤ h`, что мешает
      напрямую использовать адаптивный бюджет.
    - Реализовать малый случай `s ≤ n + 1` в теореме `decisionTree_cover`,
      заменив оставшийся `admit` в `low_sensitivity_cover.lean`.
    - Остаётся объединить глубинную оценку с рекурсивной конструкцией и
      заменить допущение в теореме `decisionTree_cover` на полноценное
      доказательство.
5. **Рефакторинг и документация.**
   - Упростить конечное доказательство, вынеся технические леммы в отдельные разделы.
   - После выполнения всех задач перенести краткое описание результата в `README` и удалить данный план.
6. **Опционально: точная оценка энтропии.**
   - Формализовать неравенство `H₂(F) ≤ coverConst · s · log₂ (n + 1)` вместо использования «безопасной константы».


## Обновление плана (рефакторинг `buildCoverLex3`)

  1. **Рекурсивное ветвление по чувствительной координате.**
    - Чувствительный случай теперь полностью рекурсивен: `buildCoverLex3A`
      вызывает себя на ветвях `F.restrict i false` и `F.restrict i true`,
      а затем склеивает их через `glue_branch_coversPw_mBound`.
    - Определения `glue_step_pw`, `glue_branch_coversPw` и
      `glue_branch_coversPw_mBound` используются на каждом шаге рекурсии.
    - Лемма-заглушка `glue_branch_coversPw_card_le_mBound_succ` удалена.
    - ✅ Блок `decreasing_by` обрабатывает как удаление постоянно ложной
      функции, так и ветвление по координате.
    - ✅ Вспомогательная функция `buildCoverLex3A` с параметром множества
      координат `A` уже задействована; обёртка `buildCoverLex3` вызывает её
      с `A = univ`.
## Конструктивный алгоритм для малой чувствительности

Для устранения оставшейся аксиомы в `low_sensitivity_cover.lean` требуется
построить решающее дерево глубины `O(s · log n)` для функций с глобальной
чувствительностью `sensitivity f ≤ s`.

1. **Большой блок нечувствительных координат.**
   Ранее предполагалось доказать лемму
   `exists_large_insensitive_subset_div`, обеспечивающую подмножество
   `A ⊆ Fin n` размера `|A| ≥ n / (2*s)`.
   Однако построенный контрпример при `n = 4`, `s = 2` показывает, что
   такая граница неверна: функция `(x₁ ∧ x₂) ∨ (x₃ ∧ x₀)` использует все
   координаты и не имеет глобально нечувствительных направлений.  Поэтому
   дальнейшее развитие должно опираться на локальные подкубы
   `insensitiveSubcubeAt` или альтернативные вероятностные методы.
2. **Рекурсивное дерево.**
   Используя множество `A`, фиксируем соответствующие биты одной ветвью и
   рекурсивно строим дерево для остатка из `n - |A|` координат.  При каждом шаге
   размер входа сокращается примерно в `(1 - 1/(2*s))` раз, что даёт глубину
   `O(s · log n)`.
3. **Интеграция в `decisionTree_cover`.**
   Полученное дерево преобразуется в покрытие через
    `decisionTree_cover_of_tree`.  Лемма
    `decisionTree_cover_smallS_pos_general` теперь опирается на предположенную
   `exists_common_monochromatic_subcube`, предоставляющую большой подкуб,
   монохроматический для всего семейства.  На данный момент реализованы
   базовый случай пустого семейства (подкуб — весь куб) и частный случай
   одноэлементного семейства: используется лемма
   `exists_large_monochromatic_subcube`, что даёт подкуб с оценкой
   `R.idx.card ≤ |Point n| · s`.  Для семейств, содержащих две и более
   функций, перенос монохроматичности на остальные элементы остаётся
   незавершённой задачей.
    Вокруг выбранного подкуба
    `branchOnSubcube`, а внешняя область теперь описывается отдельной
    леммой `decisionTree_cover_smallS_pos_general_rec`: она постулирует
    существование поддерева, монохромного для всех функций и удовлетворяющего
    ограничению
    `depth tRec + R.idx.card ≤ coverConst · s · log₂(n+1)`.  В этой лемме уже
    реализован базовый случай `R.idx = ∅`: возвращается тривиальное дерево из
    одного листа с нулевой глубиной.  В невырожденном случае `R.idx ≠ ∅`
    теперь выделяется конкретная координата `i ∈ R.idx` как отправная точка для
    анализа внешней области.  Из `R` формируется ослабленный подкуб
    `R₁ = R.unfix i`, содержащий все точки `R` и имеющий кодименсию ровно на
    единицу меньше (`R₁.idx.card + 1 = R.idx.card`).  Для этого введена явная
    лемма `Subcube.card_idx_unfix`, снимающая координату и уменьшающая индекс на
    единицу.  Более того, показано, что
    `R₁` наследует глобальное ограничение `R₁.idx.card ≤ |Point n| · s`, что
    подготавливает дальнейший рекурсивный шаг.  Дальнейшее рекурсивное
    построение дерева и оценка глубины остаются незавершёнными.  Обеспечение
    покрытия теперь целиком берёт на себя общая лемма
    `coloredSubcubes_cover_eval`, а проверка монохромности ветвей сводится к
    разбору случаев при помощи `DecisionTree.coloredSubcubes_branchOnSubcube_subset`
    и `Subcube.monochromaticFor_subset`.  На их основе добавлена объединяющая
    лемма `DecisionTree.coloredSubcubes_branchOnSubcube_monochromatic`,
    автоматически переносящая монохроматичность на все ветви `branchOnSubcube`.
    В `coloredSubcubes_branchOnSubcube_subset` уже полностью
    доказан вырожденный случай `R.idx = ∅` — показано, что единственная
    ветвь совпадает с `R`; общий индуктивный разбор остаётся TODO.  В качестве
    подготовки добавлена вспомогательная лемма
    `DecisionTree.coloredSubcubesAux_cons_subset`, позволяющая
    удалять ведущую координату из пути; реализован листовой случай, а также
    обработка узла при совпадении первой координаты с текущим разветвлением
    (используется вспомогательная лемма `subcube_of_path_cons_cons_idx`,
    теперь допускающая разные значения и устраняющая повторное
    фиксирование той же координаты на уровне индексов).  В качестве
    следующего шага добавлена лемма `subcube_of_path_cons_cons`, которая
    утверждает полное совпадение подкубов при повторном фиксировании одной
    и той же координаты, что позволит в дальнейшем безопасно удалять из пути
    избыточные присваивания.
    Для более гибкого разбора `coloredSubcubes` в рекурсивном шаге
    добавлена лемма `DecisionTree.coloredSubcubes_node`, явно раскладывающая
    множество цветных подкубов `node i t₀ t₁` на объединение ветвей `false`
    и `true`.
    В качестве подготовки добавлена общая экстенсиональная лемма
    `Subcube.ext`, фиксирующая, что совпадение индексов и значений
    полностью определяет подкуб.  Это создаёт основу для дальнейшего
    упрощения путей и построения леммы о полном совпадении подкубов.
    Дополнительно доказана техническая лемма
    `not_mem_subcube_of_path_cons`, показывающая, что при добавлении новой
    координаты сохранится свежесть уже отсутствующего индекса; она понадобится
    при анализе случая с различными координатами, который остаётся задачей для
    будущей доработки.  Дополнительно введены леммы
    `not_mem_subcube_of_path_of_not_mem_fst` и
    `mem_subcube_idx_of_mem_path`, связывающие синтаксическое присутствие
    координаты в списке присваиваний с её появлением в множестве фиксированных
    координат подкуба.  Оценка глубины напрямую
    получается из `depth_branchOnSubcube_le`, поскольку предположение
    `depth tRec + R.idx.card ≤ coverConst · s · log₂(n+1)` позволяет сразу
    ограничить глубину результирующего дерева.  Дополнительная лемма
    `DecisionTree.mem_subcube_of_path_iff_agrees` теперь формулируется при
    условии отсутствия повторов координат в пути
    (`List.Nodup (p.map Prod.fst)`).  В этом случае принадлежность точки
    подкубу эквивалентна выполнению всех присваиваний, что избавляет от
    необходимости отдельно рассматривать повторяющиеся индексы.  Лемма
    `DecisionTree.mem_subcube_of_path_cons_subset` по‑прежнему требует, чтобы
    удаляемая координата не появлялась в хвосте пути, и в такой форме
    используется при анализе включений между подкубами.
    Для завершения леммы `coloredSubcubesAux_cons_subset` теперь требуется
    лишь техническая перестановка координат:

    * `coloredSubcubesAux_cons_cons` уже доказана: повторное фиксирование одной
      и той же координаты не меняет множества цветных подкубов, что следует из
      равенства `subcube_of_path_cons_cons`.
    * `coloredSubcubesAux_cons_swap` теперь также доказана: присваивания для
      разных координат коммутируют при отсутствии этих координат в хвосте пути.
      Лемма опирается на обобщённое равенство
      `subcube_of_path_append_cons_swap` и переносит коммутативность с
      подкубов на множества цветных подкубов.
    * Добавлена специализированная лемма
      `coloredSubcubesAux_cons_subset_node_same`: если вершина дерева ветвится
      по той же координате, что и удаляемое присваивание, то соответствующий
      подкуб уже присутствует в укороченном наборе цветных подкубов, и
      дополнительных перестановок не требуется.
      Вместе с `coloredSubcubesAux_cons_cons` она позволяет переносить
      членство из пути `((i, b) :: p)` в укороченный `p`, что необходимо для
      индуктивного шага в `coloredSubcubesAux_cons_subset`.
    * Новая лемма `coloredSubcubesAux_cons_subset_node_diff` покрывает
      противоположный случай, когда вершина ветвится по другой координате `j`,
      отсутствующей в хвосте пути.  В этом случае присваивание `(i, b)` можно
      переставить через `j` и применить общее включение для соответствующего
      поддерева; в основной лемме этот случай теперь закрыт прямым обращением к
      `coloredSubcubesAux_cons_subset_node_diff`.
    * В общей лемме `coloredSubcubesAux_cons_subset` реализованы оба упомянутых
      частных случая: ветвление по той же координате и ветвление по новой
      координате, отсутствующей в хвосте.  Остаётся завершить разбор ситуации,
      когда `j` встречается в хвосте пути, требующий более тонкой перестановки
      шагов.  Для подготовки к этому добавлена лемма
      `subcube_of_path_idx_split_last`, позволяющая выделить последнее
      вхождение координаты в пути и тем самым гарантировать отсутствие этой
      координаты в оставшемся хвосте.  Она создаёт базу для дальнейшего
      применения `coloredSubcubesAux_cons_swap` и завершения общего случая.
      Следующий шаг — разложить путь `p = p₁ ++ (j, b_j) :: p₂` по лемме
      `path_split_last` и последовательно переставить головное присваивание
      `(i, b)` через префикс `p₁`, а затем обменять его с `(j, b_j)`.
      Эти перестановки пока не формализованы, поэтому в коде на месте
      соответствующего доказательства остаётся `sorry`.
    * Для пустого хвоста пути уже реализована специализированная версия
      `coloredSubcubesAux_cons_subset_nil`.  Она удаляет единственное
      присваивание и тем самым обеспечивает включение, нужное на ранних
      шагах построения дерева решений.  Общий случай с произвольным хвостом
      остаётся задачей на будущее.
    Открытыми остаются конструкция
    `exists_common_monochromatic_subcube` для непустого семейства и
    реализация рекурсивного шага `hRec`.  В непустом случае ранее выделялась
    вторая функция `f₁ ≠ f₀` для последующего переноса монохроматичности, но
    полноценный анализ пока отсутствует.  Вместо него теперь используется
    тривиальный одноточечный подкуб `Rpt`, фиксирующий все координаты и тем
    самым монохроматичный для любого семейства.  Для его кодименсии добавлена
    вспомогательная лемма `n_le_pow_two : n ≤ 2^n`, позволяющая оценивать
    размер `Rpt.idx` через мощность всего куба; это неравенство теперь
    используется напрямую через вычисление `|Point n| = 2^n`.  В лемме `decisionTree_cover_smallS_pos_general_rec`
    зафиксирована координата `i` и построен ослабленный подкуб `R₁`, для
    которого рекурсивный вызов описан схематично.  Формально показано,
    что `R` включён в `R₁`.  Для работы с точками ослабленного подкуба
    добавлена лемма `mem_unfix_update`, позволяющая изменять значение
    координаты `i` и оставаться внутри `R.unfix i`.  Однако этого недостаточно для переноса
    монохроматичности: требуется лемма о нечувствительности всех функций
    по координате `i`.  Теперь явным образом введено промежуточное
    утверждение `hins_all : ∀ f ∈ F, coordSensitivity f i = 0`,
    позволяющее при его наличии вывести монохроматичность `R₁` через
    `Subcube.monochromaticFor_unfix_of_insensitive`.  Для будущего вывода
    нечувствительности добавлена заготовка леммы
    `coordSensitivity_zero_of_large_subcube`, использующей ограничение
    чувствительности и крупный размер `R`.  Формальное доказательство
    `hins_all` по-прежнему отсутствует, как и вывод из него
    монохроматичности `R₁` и проверка глубины
    после ветвления пока оставлены `sorry`.  При этом
    равенство
    `depth (DecisionTree.node i t₀ (leaf false)) + R.idx.card =
     (depth t₀ + R₁.idx.card) + 2` доказано формально и демонстрирует
    две лишние единицы в бюджет глубины, которые ещё предстоит поглотить
    численными оценками.  Дополнительно показано строгое неравенство
    `R₁.idx.card < R.idx.card`, подчёркивающее уменьшение кодименсии и
    служащее мерой для индуктивного шага.  В качестве подготовки к будущей
    оценке глубины доказано грубое неравенство
    `two_le_coverConst_mul : 2 ≤ coverConst · s · log₂(n+1)` при `n ≥ 2` и
    `s > 0`, гарантирующее, что глобальный бюджет как минимум покрывает
    дополнительный вклад двух уровней при вставке узла.  Теперь эта оценка
    использована для закрытия неравенства `hdepth_aux`: рекурсивное
    предположение возвращает запас в две единицы, а лемма
    `two_le_coverConst_mul` позволяет его поглотить, выводя
    `(depth t₀ + R₁.idx.card) + 2 ≤ coverConst · s · log₂(n+1)`.  Данное
    неравенство реализовано в коде через перенос `+2` в правую часть и последующее
    упрощение `… - 2 + 2` с помощью `Nat.sub_add_cancel`.

    Монокроматичность цветных подкубов, происходящих из рекурсивного поддерева, теперь переносится
    посредством леммы `DecisionTree.coloredSubcubesAux_cons_subset` и
    `Subcube.monochromaticFor_subset`; листовая ветвь по противоположному значению
    всё ещё требует отдельного анализа.

    Следующие шаги:

    1. **Нечувствительность `hins_all`.** Нужно формально вывести
       `coordSensitivity f i = 0` из ограничения `Hsens` и крупных размеров
       подкуба `R`.  Предполагается использовать комбинаторный подсчёт пар
       точек внутри `R`, различающихся только в координате `i`.
    2. **Перенос цвета в листовой ветви.** После доказательства `hins_all`
       следует построить точку из `R`, совпадающую с рассматриваемым `x`
       по всем координатам, кроме `i`, и переписать значение функции на
       нужный подкуб.
    3. **Рекурсивный вызов для `R₁`.** Осталось аккуратно сформулировать
       рекурсивное предположение с запасом по глубине и получить дерево `t₀`
       для внешней области.

* Для будущей обработки ветвления по подкубу введена заготовка леммы
  `coloredSubcubes_branchOnSubcube_eq`, описывающей структуру множества
  цветных подкубов `branchOnSubcube R b t` как объединения самого `R` и
  элементов fallback-дерева `t`, унаследовавших путь `Subcube.toList R`.
  Доказательство этой леммы пока отложено, но она задаёт форму итогового
  рассуждения в `coloredSubcubes_branchOnSubcube_subset`.
