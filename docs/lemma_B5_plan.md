# План завершения доказательства Леммы B-5

## 0. Подготовка инфраструктуры
- [ ] Просмотреть существующие формулировки в `Pnp2/bound.lean`, `cover_numeric.lean`, `Cover/Bounds.lean`, `cover2.lean` и связанных файлах, чтобы определить, где лучше разместить итоговую формулировку Леммы B-5.
- [ ] Уточнить используемые параметры: зафиксировать константы \(c>0\), \(\alpha>0\), \(\delta>0\), а также порог \(n_0\) для "достаточно больших" \(n\).
- [ ] Проверить, какие вспомогательные леммы уже доступны (например, `Bound.family_collision_entropy_lemma`, `count_canonical_bounded`, свойства подсолнухов) и какие формальные интерфейсы они предоставляют.

## 1. Интеграция оценки семейства схем (результат B-3)
1.1. Определить семейство функций
- [ ] В существующем модуле (например, `cover_numeric.lean`) ввести определение семейства \( \mathcal F_{n,c} \) всех булевых функций на \(n\) переменных, реализуемых схемами размера \( \le n^c \).
- [ ] Убедиться, что определение согласовано с уже имеющимися понятиями о схемах и булевых функциях в проекте.

1.2. Получить верхнюю оценку на мощность семейства
- [ ] Использовать доказанную лемму `count_canonical_bounded` (или более прямой аналог) для вывода оценки \(|\mathcal F_{n,c}| \le 2^{C n^{c+1} + 1}\) для некоторой явной константы \(C\).
- [ ] Сформулировать и доказать в Lean промежуточную теорему (например, `family_of_circuits_card_bound`), возвращающую константу \(C\) и требуемое неравенство для всех достаточно больших \(n\).
- [ ] Из неравенства на мощность вывести ограничение на коллизионную энтропию: \(H_2(\mathcal F_{n,c}) \le C n^{c+1} + 1\).

1.3. Подготовить параметры для применения `Bound.family_collision_entropy_lemma`
- [ ] Записать в Lean вспомогательную лемму, связывающую выбранные \(C\) и \(h(n) = C n^{c+1} + 1\) с гипотезами `family_collision_entropy_lemma`.
- [ ] Проверить, что необходимые условия (монотонность \(h\), диапазоны индексов, неотрицательность) явно зафиксированы и легко доступны в доказательствах.

## 2. Получение покрытия с нужной мощностью
2.1. Применение `family_collision_entropy_lemma`
- [ ] Для \( \mathcal F_{n,c} \) вызвать `Bound.family_collision_entropy_lemma`, подставив вычисленное \(h(n)\).
- [ ] Извлечь из результата множество подкубов \(Rset\) и границу на его мощность \(|Rset| \le 2^{3n + 11 h(n) + 2}\).

2.2. Сравнение с \(2^{N - N^\delta}\)
- [ ] Выбрать конкретное \( \delta > 0 \) (например, \(1/2\)).
- [ ] Доказать лемму о существовании \(n_0\), такой что для всех \(n \ge n_0\) выполнено \(3n + 11 h(n) + 2 \le 2^n - 2^{n/2}\).
  - [ ] При необходимости воспользоваться инструментами `linarith`, `norm_num`, либо заранее оценить полином \(h(n)\) более грубо.
- [ ] Заключить, что \(|Rset| \le 2^{N - N^\delta}\) для \(N = 2^n\) и всех \(n \ge n_0\).

2.3. Ограничение покрытия конкретной функции
- [ ] Для конкретной функции \(f\) определить \(Rset_f = \{ R \in Rset \mid \exists x \in R: f(x) = 1 \}\).
- [ ] Доказать, что \(Rset_f\) наследует монохроматичность и покрытие всех единичных точек \(f\).
- [ ] Установить, что \(|Rset_f| \le |Rset|\), сохраняя требуемую оценку на мощность.

## 3. Свойство эффективной перечислимости прямоугольников
3.1. Формализация разбиения координат
- [ ] Зафиксировать разбиение \(n = k + \ell\) (например, определить `leftCoords n k` и `rightCoords n k`).
- [ ] Ввести определения `fixedLeft(R)` и `fixedRight(R)` как подмножества фиксированных координат подкуба \(R\).
- [ ] Определить `freeLeft(R)` и `freeRight(R)` как дополнения.

3.2. Доказательство нижних границ на число фиксированных координат
- [ ] Формулировать ключевую лемму: если \(R\) из покрытия \(Rset_f\), то \(|freeLeft(R)| \le (1-\alpha)k\) и \(|freeRight(R)| \le (1-\alpha)\ell\).
- [ ] Провести доказательство от противного, используя ограничение \(|\mathcal F_{n,c}| \le 2^{(1-\alpha)k}\) (результат из шага 1).
  - [ ] При необходимости уточнить связь между параметрами \(k\) и \(n^{c+1}\).
  - [ ] Разработать конструкцию, преобразующую избыток свободных бит в набор попарно различимых функций семейства, противоречащий оценке из B-3.
- [ ] В Lean реализовать доказательство, аккуратно используя `Finset.card`, операции на подмножествах координат и уже существующие леммы о подсолнухах/ядрах.

3.3. Формализация утверждения о времени перечисления
- [ ] На основе леммы из предыдущего шага сформулировать и доказать утверждение: прямой перебор по свободным левым (правым) битам выполняется за \(2^{(1-\alpha)k}\) (соответственно \(2^{(1-\alpha)\ell}\)) шагов.
- [ ] Добавить комментарии или определения, связывающие эти оценки с понятием "эффективная перечислимость" в формулировке Леммы B-5.

## 4. Удаление вспомогательных гипотез в `sunflower_step`
4.1. Гипотеза `h_true`
- [ ] Доказать лемму, что при наличии множества точек \(Pts\), где все функции \(F\) принимают значение 1, можно без потери общности выбрать нулевой вектор (или иной фиксированный элемент) в качестве базы.
- [ ] Переписать реализацию `sunflower_step`, убрав требование `h_true` и заменив его на применение новой леммы.

4.2. Гипотеза `h_agree`
- [ ] Изучить текущую реализацию в `cover2.lean`, понять, где используется `h_agree`.
- [ ] На основе `Agreement.coreAgreement` и свойств `CoreClosed` сконструировать явное соответствие между лепестками подсолнуха и функциями \(F\).
- [ ] Обновить доказательство в `sunflower_step`, устранив необходимость передавать `h_agree` как гипотезу.
- [ ] Добавить подробные комментарии, документирующие новую структуру доказательства.

4.3. Рефакторинг вызовов `sunflower_step`
- [ ] Проверить все места использования `sunflower_step`, обновить их сигнатуры и передаваемые аргументы.
- [ ] Прогнать Lean для убедительности, что новые предпосылки автоматически выполняются в существующих доказательствах.

## 5. Формулировка и доказательство Леммы B-5
5.1. Формальное утверждение
- [ ] В выбранном модуле (например, `Pnp2/bound.lean`) сформулировать теорему `lemma_B5` с тремя условиями: ограниченное число подкубов, покрытие всех 1-точек \(f\), монохроматичность и ограничение на свободные биты.
- [ ] В явной форме задать константы \(C\), \(\alpha\), \(\delta\), \(n_0\) и зависимости от \(n\).

5.2. Структура доказательства
- [ ] Использовать результаты из шагов 2 и 3 для построения покрытия \(Rset_f\) с требуемыми свойствами.
- [ ] По очереди закрыть все условия теоремы (мощность, покрытие, монохроматичность, перечислимость).
- [ ] Обеспечить, чтобы все леммы аккуратно применялись через `have`, `refine`, `rcases` и другие подходящие тактики.
- [ ] Добавить подробные комментарии, объясняющие логику каждого шага.

5.3. Финальные проверки
- [ ] Убедиться, что доказательство не использует дополнительных неприведённых гипотез и не оставляет `sorry`.
- [ ] Прогнать `lake build` или эквивалентную команду для проверки всего репозитория.
- [ ] Внести при необходимости мелкие правки в документацию или комментарии, описывающие новую теорему.

## 6. Дополнительные улучшения (по возможности)
- [ ] Проанализировать оценки констант \(coverConst\) и множитель \(3^n\) в `mBound`, наметить будущие шаги по их ужесточению.
- [ ] Задокументировать идеи по оптимизации в отдельном разделе комментариев или в `TODO.md`.
- [ ] Рассмотреть возможность автоматизации выбора \(\delta\) и \(\alpha\) (например, через отдельные конструкции Lean), чтобы упростить дальнейшие улучшения.

## 7. Организационные шаги
- [ ] Обновить `TODO.md` или соответствующий раздел дорожной карты, отметив прогресс по задачам Леммы B-5.
- [ ] Подготовить PR-описание, суммирующее выполненные изменения и обосновывающее закрытие Леммы B-5.
- [ ] Согласовать с коллегами (при необходимости) стратегию дальнейшей оптимизации констант.

