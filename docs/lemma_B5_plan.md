# План завершения доказательства Леммы B-5

Документ уточняет структуру работ по формализации Леммы B-5 в Lean. В пунктах ниже сохранена исходная логика, но добавлены уточнения по зависимостям и ожидаемым вспомогательным результатам. Для удобства каждая задача снабжена короткими комментариями о том, какие определения и леммы уже присутствуют в репозитории и какие недостающие части нужно дописать.

## 0. Подготовка инфраструктуры
- [ ] Просмотреть существующие формулировки в `Pnp2/bound.lean`, `cover_numeric.lean`, `Cover/Bounds.lean`, `Cover/Sunflower.lean`, `cover2.lean` и связанных файлах, чтобы определить, где лучше разместить итоговую формулировку Леммы B-5 и какие модули уже импортируют необходимые определения (например, `Subcube`, `CoverFamily`, `canonicalCircuit`).
- [ ] Уточнить используемые параметры: зафиксировать константы $c>0$, $\alpha>0$, $\delta>0$, а также порог $n_0$ для "достаточно больших" $n$. Дополнительно проверить, что диапазоны целых параметров (например, $n\ge 1$, $k, \ell \le n$) явно отражены в сигнатурах лемм.
- [ ] Проверить, какие вспомогательные леммы уже доступны (например, `Bound.family_collision_entropy_lemma`, `Bound.family_card_le`, `count_canonical_bounded`, свойства подсолнухов), и зафиксировать конкретные версии/варианты, которые удобно применять в дальнейших шагах. При необходимости отметить отсутствие прямых интерфейсов и подготовить список необходимых вспомогательных утверждений.

## 1. Интеграция оценки семейства схем (результат B-3)
1.1. Определить семейство функций
- [x] В существующем модуле (например, `cover_numeric.lean` или новом файле `Cover/Circuits.lean`) ввести определение семейства $\mathcal F_{n,c}$ всех булевых функций на $n$ переменных, реализуемых схемами размера $\le n^c$. При необходимости использовать уже существующий конструктор `canonicalCircuit` для получения Lean-объектов схем.
- [x] Убедиться, что определение согласовано с имеющимися понятиями о схемах и булевых функциях (например, `Circuit.eval`, `BoolCube`). Проверить, что семейство представлено как `Finset` или `Set` (в зависимости от интерфейса `family_collision_entropy_lemma`). При несовпадении типов подготовить вспомогательную конверсию.
  *Готово:* определения `Circuit.family` и `Circuit.powFamily` находятся в `Pnp2/canonical_circuit.lean` и `Pnp2/Circuit/EntropyCover.lean`.

1.2. Получить верхнюю оценку на мощность семейства
- [x] Использовать доказанную лемму `count_canonical_bounded` (или более прямой аналог) для вывода оценки $|\mathcal F_{n,c}| \le 2^{C n^{c+1} + 1}$ для некоторой явной константы $C$. Проверить, что константа совместима с ограничениями на параметр $c$ и предполагаемыми границами на $n$.
- [x] Сформулировать и доказать в Lean промежуточную теорему (например, `family_of_circuits_card_bound`), возвращающую константу $C$ и требуемое неравенство для всех достаточно больших $n$. В этой лемме явно использовать `Bound.family_card_le` или аналогичные результаты, чтобы показать совместимость нового определения семьи с существующими оценками.
- [x] Из неравенства на мощность вывести ограничение на коллизионную энтропию: $H_2(\mathcal F_{n,c}) \le C n^{c+1} + 1$. Зафиксировать явную связь между доказанным `card`-неравенством и формализацией энтропии (включая преобразование логарифмов).
  *Статус:* леммы `Circuit.pow_family_card_le` и `Circuit.pow_family_H₂_le` реализуют необходимые оценки в `Pnp2/canonical_circuit.lean`.

1.3. Подготовить параметры для применения `Bound.family_collision_entropy_lemma`
- [x] Записать в Lean вспомогательную лемму, связывающую выбранные $C$ и $h(n) = C n^{c+1} + 1$ с гипотезами `family_collision_entropy_lemma`, включая проверку свойств натуральных логарифмов, преобразование `Nat.cast` и условия $0 < n$.
- [x] Проверить, что необходимые условия (монотонность $h$, диапазоны индексов, неотрицательность) явно зафиксированы и легко доступны в доказательствах. При необходимости сформулировать отдельные леммы о росте $h$ и совместимости с экспонентами.
  *Комментарий:* определения `powFamilyEntropyBound` и лемма `Circuit.powFamily_H₂_le` дают прямую подстановку в `Bound.family_collision_entropy_lemma`.

## 2. Получение покрытия с нужной мощностью
2.1. Применение `family_collision_entropy_lemma`
- [x] Для $\mathcal F_{n,c}$ вызвать `Bound.family_collision_entropy_lemma`, подставив вычисленное $h(n)$, и убедиться, что все вспомогательные параметры (натуральные логарифмы, условия на размер семейства) удовлетворены автоматически.
- [x] Извлечь из результата множество подкубов $Rset$ и границу на его мощность $|Rset| \le 2^{3n + 11 h(n) + 2}$. При необходимости добавить вспомогательные леммы, конвертирующие оценку `coverConst` из натуральных чисел в вещественные.
  *Результат:* лемма `Circuit.powFamily_cover` в `Pnp2/Circuit/EntropyCover.lean` предоставляет покрытие и явную верхнюю границу.

2.2. Сравнение с $2^{N - N^\delta}$
- [x] Выбрать конкретное $\delta > 0$ (используем значение $\delta = 1/2$ через явное сравнение с $2^{n/2}$) и зафиксировать соответствующий порог в виде `Numeric.coverThreshold`.
- [x] Доказать лемму о существовании $n_0$, такой что для всех $n \ge n_0$ выполнено $3n + 11 h(n) + 2 \le 2^n - 2^{n/2}$. Для этого полезно подготовить вспомогательные оценочные леммы (натуральные версии неравенств, монотонность экспоненты, грубые оценки полиномов).
  - [x] При необходимости воспользоваться инструментами `linarith`, `nlinarith`, `simp` с переписанными логарифмами, либо заранее оценить $h(n)$ более грубо (например, $h(n) \le C' n^{c+1}$ для заранее подобранного $C'$).
- [x] Заключить, что $|Rset| \le 2^{N - N^\delta}$ для $N = 2^n$ и всех $n \ge n_0$, и оформить итог в виде отдельной леммы, которую затем можно использовать при формулировке Леммы B-5.
  *Готово:* леммы `Circuit.Numeric.exponent_le_doubleExp` и `Circuit.powFamily_cover_for_member_doubleExp` выводят оценку $3n + 66 n^{c+1} + 2 \le 2^n - 2^{n/2}$ и сразу переносят её на кардинальность покрытия после фильтрации по конкретной функции.

2.3. Ограничение покрытия конкретной функции
- [x] Для конкретной функции $f$ определить $Rset_f = \{ R \in Rset \mid \exists x \in R: f(x) = 1 \}$, реализовав это как `Rset.filter` или `Finset.filter` в Lean.
- [x] Доказать, что $Rset_f$ наследует монохроматичность и покрытие всех единичных точек $f$. Для этого нужно аккуратно переписать существующие определения (`AllOnesCovered`, `monoOn`) и убедиться, что фильтрация не нарушает условия на остальные функции семейства.
- [x] Установить, что $|Rset_f| \le |Rset|$, сохраняя требуемую оценку на мощность, и оформить отдельной вспомогательной леммой (например, `filtered_cover_card_le`).
  *Готово:* лемма `Circuit.powFamily_cover_for_member` фильтрует покрытие и переносит все три свойства.

## 3. Свойство эффективной перечислимости прямоугольников
3.1. Формализация разбиения координат
- [x] Зафиксировать разбиение $n = k + \ell$ (определения `Coords.left n k` и `Coords.right n k` в `Pnp2/Boolcube.lean`, леммы `left_union_right` и `left_disjoint_right` описывают базовый разрез индексов).
- [x] Ввести определения `Subcube.fixedLeft` и `Subcube.fixedRight` как подмножеств фиксированных координат подкуба $R$ (реализованы через `Finset.filter` от `Subcube.support`).
- [x] Определить `Subcube.freeLeft` и `Subcube.freeRight` как дополнения в соответствующих блоках и доказать, что они образуют дизъюнктное разбиение (`fixedLeft_union_freeLeft`, `fixedRight_union_freeRight`) с кардинальной связью (`card_fixedLeft_add_card_freeLeft`, `card_fixedRight_add_card_freeRight`).

3.2. Доказательство нижних границ на число фиксированных координат
- [ ] Формулировать ключевую лемму: если $R$ из покрытия $Rset_f$, то $|freeLeft(R)| \le (1-\alpha)k$ и $|freeRight(R)| \le (1-\alpha)\ell$. В формулировке явно использовать натуральные неравенства и переводить их в границы на экспоненты перечисления.
- [ ] Провести доказательство от противного, используя ограничение $|\mathcal F_{n,c}| \le 2^{(1-\alpha)k}$ (результат из шага 1) и сведения о том, что подсолнух в `sunflower_step` обеспечивает согласованность на ядре. Подготовить дополнительную лемму, связывающую количество свободных бит с возможностью отличия функций на левой половине.
  - [ ] При необходимости уточнить связь между параметрами $k$ и $n^{c+1}$ (например, через явную формулу выбора $k = \lfloor C' n^{c+1} \rfloor$ или ссылку на соответствующий шаг алгоритма).
  - [ ] Разработать конструкцию, преобразующую избыток свободных бит в набор попарно различимых функций семейства, противоречащий оценке из B-3. Для формализации может понадобиться лемма о том, что монохроматичный подкуб с большим числом свободных бит индуцирует разные столбцы матрицы истинности.
  - [ ] В Lean реализовать доказательство, аккуратно используя `Finset.card`, операции на подмножествах координат и уже существующие леммы о подсолнухах/ядрах (`Agreement.coreAgreement`, `CoreClosed`).
  *Прогресс:* добавлены леммы `Coords.card_left/right` и их следствия (`Subcube.card_freeLeft_eq_left_sub_fixed`, `Subcube.card_freeRight_eq_right_sub_fixed`, верхние оценки на `card_freeLeft`/`card_freeRight`), которые переводят информацию о числе фиксированных координат в ограничения на количество свободных бит.

3.3. Формализация утверждения о времени перечисления
- [ ] На основе леммы из предыдущего шага сформулировать и доказать утверждение: прямой перебор по свободным левым (правым) битам выполняется за $2^{(1-\alpha)k}$ (соответственно $2^{(1-\alpha)\ell}$) шагов. При необходимости ввести вспомогательное определение `enumerationComplexity` и связать его с подсчётом свободных координат.
- [ ] Добавить комментарии или определения, связывающие эти оценки с понятием "эффективная перечислимость" в формулировке Леммы B-5, чтобы избежать неоднозначности при дальнейших ссылках.
  *Прогресс:* в `Pnp2/Boolcube.lean` добавлены определения `Subcube.enumerationCostLeft/Right`, фиксирующие стоимость полного перебора свободных координат, и леммы `enumerationCostLeft_le_of_card_le`, `enumerationCostRight_le_of_card_le`, `enumerationCostLeft_eq_pow_left_sub_fixed`, `enumerationCostRight_eq_pow_right_sub_fixed`, переводящие оценки на число свободных бит в прямые экспоненциальные ограничения.

## 4. Удаление вспомогательных гипотез в `sunflower_step`
4.1. Гипотеза `h_true`
- [ ] Доказать лемму, что при наличии множества точек $Pts$, где все функции $F$ принимают значение 1, можно без потери общности выбрать нулевой вектор (или иной фиксированный элемент) в качестве базы. Уточнить, какие условия нужны на `Pts` (непустота, замкнутость относительно ядра) и доказать соответствующие вспомогательные утверждения.
- [ ] Переписать реализацию `sunflower_step`, убрав требование `h_true` и заменив его на применение новой леммы. Проверить, что остальные части доказательства (например, переход к `coverConst`) не нуждаются в дополнительных правках.

4.2. Гипотеза `h_agree`
- [ ] Изучить текущую реализацию в `cover2.lean`, понять, где используется `h_agree`, и составить перечень зависимых лемм (в частности, блок с `choose f`).
- [ ] На основе `Agreement.coreAgreement` и свойств `CoreClosed` сконструировать явное соответствие между лепестками подсолнуха и функциями $F$; при необходимости выделить отдельную лемму `petal_has_agreeing_function`.
- [ ] Обновить доказательство в `sunflower_step`, устранив необходимость передавать `h_agree` как гипотезу. Убедиться, что изменения совместимы с интерфейсом `CoverFamily.sunflowerStep` и что новые доказательства не требуют дополнительных аксиом.
- [ ] Добавить подробные комментарии, документирующие новую структуру доказательства и указывающие на связи с уже существующими теоремами.

4.3. Рефакторинг вызовов `sunflower_step`
- [ ] Проверить все места использования `sunflower_step`, обновить их сигнатуры и передаваемые аргументы, зафиксировать список модулей, которые нужно пересобрать (в первую очередь `cover_numeric.lean`, `Cover/Bounds.lean`).
- [ ] Прогнать Lean для убедительности, что новые предпосылки автоматически выполняются в существующих доказательствах, и собрать все предупреждения о неиспользуемых аргументах или дублировании кода.

## 5. Формулировка и доказательство Леммы B-5
5.1. Формальное утверждение
- [ ] В выбранном модуле (например, `Pnp2/bound.lean` или `Cover/Result.lean`) сформулировать теорему `lemma_B5` с тремя условиями: ограниченное число подкубов, покрытие всех 1-точек $f$, монохроматичность и ограничение на свободные биты. Убедиться, что формулировка использует уже существующие структуры (`CoverFamily`, `MonoRectCover`) вместо дублирования определений.
- [ ] В явной форме задать константы $C$, $\alpha$, $\delta$, $n_0$ и зависимости от $n$. Добавить комментарии о выборе констант и ссылку на соответствующие леммы, чтобы последующие читатели легко восстановили обоснование.

5.2. Структура доказательства
- [ ] Использовать результаты из шагов 2 и 3 для построения покрытия $Rset_f$ с требуемыми свойствами. Разбить доказательство на отдельные вспомогательные леммы, чтобы итоговая теорема оставалась читаемой.
- [ ] По очереди закрыть все условия теоремы (мощность, покрытие, монохроматичность, перечислимость), явно указывая, какие леммы используются на каждом этапе (например, `filtered_cover_card_le`, `cover_monochromatic`, `enumeration_complexity_le`).
- [ ] Обеспечить, чтобы все леммы аккуратно применялись через `have`, `refine`, `rcases` и другие подходящие тактики, а доказательство не зависело от `simp` без предварительно зафиксированных лемм.
- [ ] Добавить подробные комментарии, объясняющие логику каждого шага и роль каждого вспомогательного результата.

5.3. Финальные проверки
- [ ] Убедиться, что доказательство не использует дополнительных неприведённых гипотез и не оставляет `sorry`. Проверить, что все новые определения имеют заметки о вычислительной сложности и сопряжены с существующими структурами данных.
- [ ] Прогнать `lake build` или эквивалентную команду для проверки всего репозитория и зафиксировать команду/вывод в журнале изменений.
- [ ] Внести при необходимости мелкие правки в документацию или комментарии, описывающие новую теорему, и обновить ссылки на соответствующие разделы статьи/препринта.

## 6. Дополнительные улучшения (по возможности)
- [ ] Проанализировать оценки констант $coverConst$ и множитель $3^n$ в `mBound`, наметить будущие шаги по их ужесточению. Зафиксировать, какие части доказательства наиболее чувствительны к этим константам.
- [ ] Задокументировать идеи по оптимизации в отдельном разделе комментариев или в `TODO.md`, указав, какие из них требуют новых математических идей (например, использование robust sunflower lemma).
- [ ] Рассмотреть возможность автоматизации выбора $\delta$ и $\alpha$ (например, через отдельные конструкции Lean), чтобы упростить дальнейшие улучшения и подготовить доказательство к потенциальной генерализации.

## 7. Организационные шаги
- [ ] Обновить `TODO.md` или соответствующий раздел дорожной карты, отметив прогресс по задачам Леммы B-5, и указать связь с выполненными шагами (например, «Шаг 2.2 закрыт в коммите ...»).
- [ ] Подготовить PR-описание, суммирующее выполненные изменения и обосновывающее закрытие Леммы B-5. Учесть требования к описанию PR из `CONTRIBUTING` (если появится).
- [ ] Согласовать с коллегами (при необходимости) стратегию дальнейшей оптимизации констант и документировать результаты обсуждения (например, в `docs/notes/`).

