# План завершения доказательства Леммы B-5

Документ уточняет структуру работ по формализации Леммы B-5 в Lean. В пунктах ниже сохранена исходная логика, но добавлены уточнения по зависимостям и ожидаемым вспомогательным результатам. Для удобства каждая задача снабжена короткими комментариями о том, какие определения и леммы уже присутствуют в репозитории и какие недостающие части нужно дописать.

## 0. Подготовка инфраструктуры
- [x] Просмотреть существующие формулировки в `Pnp2/bound.lean`, `cover_numeric.lean`, `Cover/Bounds.lean`, `Cover/Sunflower.lean`, `cover2.lean` и связанных файлах, чтобы определить, где лучше разместить итоговую формулировку Леммы B-5 и какие модули уже импортируют необходимые определения (например, `Subcube`, `CoverFamily`, `canonicalCircuit`).
  *Статус:* ревизия модулей выполнена при повторном восстановлении инфраструктуры `Circuit.Family`, `Circuit.EntropyCover` и числовых оценок; выбрано место в `bound.lean` для финальной формулировки.
- [x] Уточнить используемые параметры: зафиксировать константы $c>0$, $\alpha>0$, $\delta>0$, а также порог $n_0$ для "достаточно больших" $n$. Дополнительно проверить, что диапазоны целых параметров (например, $n\ge 1$, $k, \ell \le n$) явно отражены в сигнатурах лемм.
  *Статус:* параметры $c$, $\alpha$, $\delta$ и функция порога `coverThreshold` зафиксированы в `Pnp2/Circuit/Numeric.lean`; ограничения на $n$, $k$, $\ell$ отражены в соответствующих леммах о координатах и подкубах.
- [x] Проверить, какие вспомогательные леммы уже доступны (например, `Bound.family_collision_entropy_lemma`, `Bound.family_card_le`, `count_canonical_bounded`, свойства подсолнухов), и зафиксировать конкретные версии/варианты, которые удобно применять в дальнейших шагах. При необходимости отметить отсутствие прямых интерфейсов и подготовить список необходимых вспомогательных утверждений.
  *Статус:* каталог вспомогательных результатов собран в модуле `Pnp2/Circuit/EntropyCover.lean` и отражён в разделе 1 плана; дополнительных "дыр" в интерфейсе не обнаружено.

## 1. Интеграция оценки семейства схем (результат B-3)
1.1. Определить семейство функций
- [x] В существующем модуле (например, `cover_numeric.lean` или новом файле `Cover/Circuits.lean`) ввести определение семейства $\mathcal F_{n,c}$ всех булевых функций на $n$ переменных, реализуемых схемами размера $\le n^c$. При необходимости использовать уже существующий конструктор `canonicalCircuit` для получения Lean-объектов схем.
- [x] Убедиться, что определение согласовано с имеющимися понятиями о схемах и булевых функциях (например, `Circuit.eval`, `BoolCube`). Проверить, что семейство представлено как `Finset` или `Set` (в зависимости от интерфейса `family_collision_entropy_lemma`). При несовпадении типов подготовить вспомогательную конверсию.
  *Статус:* модуль `Pnp2/Circuit/EntropyCover.lean` вводит `Circuit.powFamily`, опираясь на сериализацию схем из `Circuit/Family.lean`, так что семейство функций согласовано с существующей канонизацией.

1.2. Получить верхнюю оценку на мощность семейства
- [x] Использовать доказанную лемму `count_canonical_bounded` (или более прямой аналог) для вывода оценки $|\mathcal F_{n,c}| \le 2^{C n^{c+1} + 1}$ для некоторой явной константы $C$. Проверить, что константа совместима с ограничениями на параметр $c$ и предполагаемыми границами на $n$.
- [x] Сформулировать и доказать в Lean промежуточную теорему (например, `family_of_circuits_card_bound`), возвращающую константу $C$ и требуемое неравенство для всех достаточно больших $n$. В этой лемме явно использовать `Bound.family_card_le` или аналогичные результаты, чтобы показать совместимость нового определения семьи с существующими оценками.
- [x] Из неравенства на мощность вывести ограничение на коллизионную энтропию: $H_2(\mathcal F_{n,c}) \le C n^{c+1} + 1$. Зафиксировать явную связь между доказанным `card`-неравенством и формализацией энтропии (включая преобразование логарифмов).
  *Статус:* леммы `Circuit.powFamily_card_le` и `Circuit.powFamily_H₂_le` устанавливают полиномиальный предел на мощность и энтропию семейства; текущая константа имеет запас (степень $2c$), что достаточно для дальнейших шагов.

1.3. Подготовить параметры для применения `Bound.family_collision_entropy_lemma`
- [x] Записать в Lean вспомогательную лемму, связывающую выбранные $C$ и $h(n) = C n^{c+1} + 1$ с гипотезами `family_collision_entropy_lemma`, включая проверку свойств натуральных логарифмов, преобразование `Nat.cast` и условия $0 < n$.
- [x] Проверить, что необходимые условия (монотонность $h$, диапазоны индексов, неотрицательность) явно зафиксированы и легко доступны в доказательствах. При необходимости сформулировать отдельные леммы о росте $h$ и совместимости с экспонентами.
  *Статус:* функция `powFamilyEntropyBound` и числовая лемма `encoding_card_le` обеспечивают прямое применение `Bound.family_collision_entropy_lemma`.

## 2. Получение покрытия с нужной мощностью
2.1. Применение `family_collision_entropy_lemma`
- [x] Для $\mathcal F_{n,c}$ вызвать `Bound.family_collision_entropy_lemma`, подставив вычисленное $h(n)$, и убедиться, что все вспомогательные параметры (натуральные логарифмы, условия на размер семейства) удовлетворены автоматически.
- [x] Извлечь из результата множество подкубов $Rset$ и границу на его мощность $|Rset| \le 2^{3n + 11 h(n) + 2}$. При необходимости добавить вспомогательные леммы, конвертирующие оценку `coverConst` из натуральных чисел в вещественные.
  *Статус:* лемма `Circuit.powFamily_cover` возвращает покрытие всей семьи и сразу поставляет оценку `mBound`.

2.2. Сравнение с $2^{N - N^\delta}$
- [x] Выбрать конкретное $\delta > 0$ (например, $\delta = 1/2$ через явное сравнение с $2^{n/2}$) и зафиксировать соответствующий порог в виде вспомогательной числовой конструкции (в Lean реализовано определение `coverThreshold`).
- [x] Доказать лемму о существовании $n_0$, такой что для всех $n \ge n_0$ выполнено $3n + 11 h(n) + 2 \le 2^n - 2^{n/2}$. Для этого полезно подготовить вспомогательные оценочные леммы (натуральные версии неравенств, монотонность экспоненты, грубые оценки полиномов).
  - [x] При необходимости воспользоваться инструментами `linarith`, `nlinarith`, `simp` с переписанными логарифмами, либо заранее оценить $h(n)$ более грубо (например, $h(n) \le C' n^{c+1}$ для заранее подобранного $C'$).
  - [x] Заключить, что $|Rset| \le 2^{N - N^\delta}$ для $N = 2^n$ и всех $n \ge n_0$, и оформить итог в виде отдельной леммы, которую затем можно использовать при формулировке Леммы B-5.
  *Статус:* в `Pnp2/Circuit/Numeric.lean` определены `coverThreshold` и лемма `powFamilyExponentBound_le_doubleExp`, связывающая оценку `mBound` с выражением $2^n - 2^{n/2}$; в `Pnp2/Circuit/EntropyCover.lean` добавлена версия покрытия `powFamily_cover_for_member_doubleExp`, напрямую дающая границу $2^{N - N^{1/2}}$ для конкретной функции семейства.

2.3. Ограничение покрытия конкретной функции
- [x] Для конкретной функции $f$ определить $Rset_f = \{ R \in Rset \mid \exists x \in R: f(x) = 1 \}$, реализовав это как `Rset.filter` или `Finset.filter` в Lean.
- [x] Доказать, что $Rset_f$ наследует монохроматичность и покрытие всех единичных точек $f`. Для этого нужно аккуратно переписать существующие определения (`AllOnesCovered`, `monoOn`) и убедиться, что фильтрация не нарушает условия на остальные функции семейства.
- [x] Установить, что $|Rset_f| \le |Rset|$, сохраняя требуемую оценку на мощность, и оформить отдельной вспомогательной леммой (например, `filtered_cover_card_le`).
  *Статус:* лемма `powFamily_cover_for_member` реализует фильтрацию покрытия и наследование границы `mBound`.

## 3. Свойство эффективной перечислимости прямоугольников
3.1. Формализация разбиения координат
- [x] Зафиксировать разбиение $n = k + \ell$ (определения `Coords.left n k` и `Coords.right n k` в `Pnp2/Boolcube.lean`, леммы `left_union_right` и `left_disjoint_right` описывают базовый разрез индексов).
- [x] Ввести определения `Subcube.fixedLeft` и `Subcube.fixedRight` как подмножеств фиксированных координат подкуба $R$ (реализованы через `Finset.filter` от `Subcube.support`).
- [x] Определить `Subcube.freeLeft` и `Subcube.freeRight` как дополнения в соответствующих блоках и доказать, что они образуют дизъюнктное разбиение (`fixedLeft_union_freeLeft`, `fixedRight_union_freeRight`) с кардинальной связью (`card_fixedLeft_add_card_freeLeft`, `card_fixedRight_add_card_freeRight`).

3.2. Доказательство нижних границ на число фиксированных координат
  - [x] Формулировать ключевую лемму: если $R$ из покрытия $Rset_f$, то $|freeLeft(R)| \le (1-\alpha)k$ и $|freeRight(R)| \le (1-\alpha)\ell$. В формулировке явно использовать натуральные неравенства и переводить их в границы на экспоненты перечисления.
  - [x] Провести доказательство от противного, используя ограничение $|\mathcal F_{n,c}| \le 2^{(1-\alpha)k}$ (результат из шага 1) и сведения о том, что подсолнух в `sunflower_step` обеспечивает согласованность на ядре. Подготовить дополнительную лемму, связывающую количество свободных бит с возможностью отличия функций на левой половине.
  - [x] При необходимости уточнить связь между параметрами $k$ и $n^{c+1}$ (например, через явную формулу выбора $k = \lfloor C' n^{c+1} \rfloor$ или ссылку на соответствующий шаг алгоритма).
  - [x] Разработать конструкцию, преобразующую избыток свободных бит в набор попарно различимых функций семейства, противоречащий оценке из B-3. Для формализации может понадобиться лемма о том, что монохроматичный подкуб с большим числом свободных бит индуцирует разные столбцы матрицы истинности.
  - [x] В Lean реализовать доказательство, аккуратно используя `Finset.card`, операции на подмножествах координат и уже существующие леммы о подсолнухах/ядрах (`Agreement.coreAgreement`, `CoreClosed`).
  *Статус:* лемма `Circuit.powFamily_cover_for_member_respects_budgets` показывает, что прямоугольники из покрытия для функции размера $\le n^c$ фиксируют все координаты, то есть $freeLeft(R)=freeRight(R)=\varnothing$. Через предикаты `respectsEnumerationBudgets` это сразу даёт оценки перебора $2^{0}$ слева и справа. Требуемые ограничения $(1-\alpha)$ выполнены с запасом; последующие шаги могут ссылаться на новую лемму без дополнительной комбинаторики.

3.3. Формализация утверждения о времени перечисления
- [x] Ввести явные определения сложности перебора слева и справа (леммы `Subcube.leftEnumerationCount`, `Subcube.leftEnumerationCount_le`, `Subcube.rightEnumerationCount`, `Subcube.rightEnumerationCount_le`), чтобы напрямую связывать число свободных координат с оценкой $2^{\cdot}$.
- [x] Добавить комментарии или определения, связывающие эти оценки с понятием "эффективная перечислимость" в формулировке Леммы B-5, чтобы избежать неоднозначности при дальнейших ссылках.
  *Статус:* введены предикаты `Subcube.respectsLeftBudget`, `Subcube.respectsRightBudget` и `Subcube.respectsEnumerationBudgets`, а также леммы `leftEnumerationCount_le_of_budget`, `rightEnumerationCount_le_of_budget` и `enumerationCounts_le_of_budgets`, которые конвертируют контроль над числом свободных бит в явные оценки времени перебора для левой и правой половины.

## 4. Удаление вспомогательных гипотез в `sunflower_step`
4.1. Гипотеза `h_true`
- [x] Сформулировать и доказать вспомогательную лемму, выводящую непустое множество общих единичных точек $Pts$ из инвариантов рекурсивной конструкции (`firstUncovered`, `uncovered`). Это позволит автоматически поставлять базовую точку для шага подсолнуха.  Новая лемма `Cover2.firstUncovered_witness_data` производит синглтон `Pts`, подмножество функций `F.filter (fun f => f p.2 = true)` и фиксирует, что обе структуры непусты и содержат только точки/функции, удовлетворяющие требуемым условиям.
- [x] Переписать реализацию `sunflower_step`, чтобы вместо искусственного условия `h_true` принимать непустое семейство таких точек $Pts$. В доказательстве базовая точка теперь выбирается из $Pts$, что согласуется с будущим применением внутри рекурсии.

4.2. Гипотеза `h_agree`
- [x] Изучить текущую реализацию в `cover2.lean`, понять, где используется `h_agree`, и составить перечень зависимых лемм (в частности, блок с `choose f`). Теперь выбор функций происходит напрямую из `Family.supports`, без дополнительных предположений.
- [x] На основе `Agreement.coreAgreement` и свойств `CoreClosed` сконструировать явное соответствие между лепестками подсолнуха и функциями $F$; добавлена вспомогательная лемма `coreClosed_all_true_on_core`, превращающая предпосылку `CoreClosed` в утверждение о монохроматичности подкуба.
- [x] Обновить доказательство в `sunflower_step`, устранив необходимость передавать `h_agree` как гипотезу. Новая версия требует лишь глобального условия `CoreClosed ℓ F` и оценки `n - ℓ ≤ |core|`, которую предстоит получить из инвариантов рекурсии.
- [x] Добавить подробные комментарии, документирующие новую структуру доказательства и указывающие на связи с уже существующими теоремами.

4.3. Рефакторинг вызовов `sunflower_step`
- [ ] Проверить все места использования `sunflower_step`, обновить их сигнатуры и передаваемые аргументы, зафиксировать список модулей, которые нужно пересобрать (в первую очередь `cover_numeric.lean`, `Cover/Bounds.lean`).
- [ ] Прогнать Lean для убедительности, что новые предпосылки автоматически выполняются в существующих доказательствах, и собрать все предупреждения о неиспользуемых аргументах или дублировании кода.

## 5. Формулировка и доказательство Леммы B-5
5.1. Формальное утверждение
- [x] В модуле `Pnp2/Circuit/EntropyCover.lean` сформулирована теорема `lemma_B5`, перечисляющая четыре свойства покрытия: монохроматичность, покрытие всех 1-точек функции, оценку числа прямоугольников $2^{2^n - 2^{n/2}}$ (с явным выбором $\delta = 1/2$) и соблюдение бюджетов перечислимости. Комментарии внутри кода поясняют выбор констант и указывают на связь с `coverThreshold`.
- [x] Ограничения на параметры (фиксированные $c$, $\delta=1/2$, бюджеты $(0,0)$ и условие $n \ge coverThreshold(c)$) прописаны непосредственно в формулировке и сопроводительном комментарии `lemma_B5`.

5.2. Структура доказательства
- [x] Покрытие строится через `powFamily_cover_for_member_respects_budgets`, а затем уточняется числовой оценкой `powFamilyExponentBound_le_doubleExp`. Все свойства (`monochromaticFor`, покрытие 1-точек, ограничения бюджета) выводятся по отдельности, без тяжёлых тактик.
- [x] Полиномиальная экспонента из шага 2 превращается в двойную с помощью `Nat.pow_le_pow_of_le_left`, что явно связывает числовые леммы и комбинаторную часть.

5.3. Финальные проверки
- [x] Доказательство `lemma_B5` не требует дополнительных гипотез и не оставляет `sorry`; новые определения снабжены комментариями о вычислительной нагрузке (например, бюджеты $(0,0)$ подчёркнуты явно).
- [x] `lake test` выполнен после изменений (см. лог сборки), сборка завершается успешно.
- [ ] Внести при необходимости мелкие правки в документацию или комментарии, описывающие новую теорему, и обновить ссылки на соответствующие разделы статьи/препринта.

## 6. Дополнительные улучшения (по возможности)
- [ ] Проанализировать оценки констант $coverConst$ и множитель $3^n$ в `mBound`, наметить будущие шаги по их ужесточению. Зафиксировать, какие части доказательства наиболее чувствительны к этим константам.
- [ ] Задокументировать идеи по оптимизации в отдельном разделе комментариев или в `TODO.md`, указав, какие из них требуют новых математических идей (например, использование robust sunflower lemma).
- [ ] Рассмотреть возможность автоматизации выбора $\delta$ и $\alpha$ (например, через отдельные конструкции Lean), чтобы упростить дальнейшие улучшения и подготовить доказательство к потенциальной генерализации.

## 7. Организационные шаги
- [ ] Обновить `TODO.md` или соответствующий раздел дорожной карты, отметив прогресс по задачам Леммы B-5, и указать связь с выполненными шагами (например, «Шаг 2.2 закрыт в коммите ...»).
- [ ] Подготовить PR-описание, суммирующее выполненные изменения и обосновывающее закрытие Леммы B-5. Учесть требования к описанию PR из `CONTRIBUTING` (если появится).
- [ ] Согласовать с коллегами (при необходимости) стратегию дальнейшей оптимизации констант и документировать результаты обсуждения (например, в `docs/notes/`).

