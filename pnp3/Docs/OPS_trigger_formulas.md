# FormulaLowerBoundHypothesis ⇒ NP \nsubseteq P/poly

Этот файл фиксирует подробное текстовое доказательство триггера `OPS_trigger_formulas`.
Мы документируем постановку задачи GapMCSP, формулируем гипотезу о нижней
границе для формул, перечисляем литературные результаты Oliveira–Pich–Santhanam
(OPS) и Chen–Jin–Williams (CJW), а затем излагаем аргумент, выводящий
`NP \nsubseteq P/poly` из гипотезы о сверхквадратичной формульной сложности
GapMCSP. Материал следует классическому феномену **hardness magnification** и
соответствует Corollary 6.4 в версии OPS 2020.

## Постановка GapMCSP

- Параметры: число входных переменных `n` и два порога размера схемы
  \(s_{YES} < s_{NO}\).
- Вход: таблица истинности функции \(f : {0,1}^n → {0,1}\) длины
  \(N = 2^n\).
- Решаемая задача:
  - **Yes**: у \(f\) есть схема размера \(≤ s_{YES}\).
  - **No**: любая схема для \(f\) имеет размер \(≥ s_{NO}\).
- Зазор \(s_{YES}+1 ≤ s_{NO}\) убирает пограничные случаи. При конструктивных
  порогах язык лежит в NP: сертификатом Yes-случая служит сама малая схема.

### FormulaLowerBoundHypothesis

> **Hypothesis.** Существует \(\delta > 0\) такое, что не существует
> \(AC^0\)-формулы размера \(O(N^{2+\delta})\), решающей GapMCSP (при фиксированных
> параметрах \(n, s_{YES}, s_{NO}\)).

Гипотеза утверждает отсутствие неглубокого решателя даже чуть больше квадрата
по размеру входа.

## Литературные триггеры магнификации

- **OPS (2019/2020).** Любая слегка сверхлинейная нижняя граница на GapMCSP в
  достаточно широком классе схем влечёт `NP \nsubseteq P/poly`. Специализированный
  формульный вариант: нижняя граница \(N^{2+\delta}\) для \(AC^0\)-формул даёт
  разделение NP и `P/poly`.
- **CJW (2019/2022).** Аналогичные триггеры для разреженных NP-языков и
  локальных схем с барьером \(N · (\log N)^\kappa\).

Эти результаты опубликованы (CCC’19, FOCS’19, JACM’22) и служат источниками для
триггеров `OPS_trigger_general`, `OPS_trigger_formulas`, `Locality_trigger` и
`CJW_sparse_trigger`.

## Доказательство импликации (эскиз от противного)

Ниже — детальная версия аргумента, реализующая триггер
`OPS_trigger_formulas` через общий результат OPS.

### Формулировка цели

- **Внешний результат.** Для фиксированных параметров GapMCSP и \(\delta>0\)
  требуется показать: если выполнена `FormulaLowerBoundHypothesis p δ`, то
  `NP \nsubseteq P/poly`.
- **Lean-версия.** В дереве `pnp3/` это утверждение реализовано как теорема
  `OPS_trigger_formulas : FormulaLowerBoundHypothesis p δ → NP_not_subset_Ppoly`,
  доказанная через подстановку `statement := ∀ solver, False` в общий триггер
  `OPS_trigger_general`. В шагах C уже доказана лемма `LB_Formulas_core`,
  предоставляющая отрицательный результат «нет малых AC⁰-солверов».

1. **Предположим противное:** `NP ⊆ P/poly`. Тогда для любого фиксированного
   GapMCSP-параметра существует семейство схем \(C_N\) размера \(O(N^c)\),
   корректно решающее задачу на всех входах длины \(N\).
2. **Балансировка и подготовка:** схему \(C_N\) можно сбалансировать до логарифмической
   глубины. Дальнейшее «раздувание» и дублирование подвыражений позволяют
   симулировать её формулой малой глубины, сохраняя полиномиальный размер.
3. **Анти-чекер OPS:** литературная конструкция показывает, что любая гипотетически
   малая \(AC^0\)-схема не различает большое семейство функций \(Y\), совпадающих
   на небольшом тестовом множестве \(T\). Эти функции служат «ядром» для
   магнификации сложности.
4. **Использование глубоких схем:** обладая \(C_N\), можно перебрать кандидатов на
   малые схемы, согласованные с входом на \(T\), и сравнить их значения на
   функциях из \(Y\). Такой перебор кодируется в неглубокую формулу
   (например, ДНФ) размера \(N^{2+\varepsilon}\) для произвольно малого \(\varepsilon>0\).
5. **Противоречие с гипотезой:** выбрав \(\varepsilon < \delta\), получаем явный
   \(AC^0\)-решатель GapMCSP размера \(N^{2+\varepsilon}\), что нарушает
   FormulaLowerBoundHypothesis. Следовательно, исходное предположение
   `NP ⊆ P/poly` ложно, и верно `NP \nsubseteq P/poly`.

### Количественные оценки, используемые в шаге 4

- **Перебор схем малой сложности.** Число булевых схем размера \(s\) с фиксированным
  числом входов \(n\) оценивается как \(2^{O(s \log s)}\). При
  \(s_{YES} = N^{1+α}\) это даёт \(2^{O(N^{1+α} \log N)}\), что заметно меньше
  \(2^{2n} = N^2\) при любом \(α < 1\).
- **Ограничение тестом \(T\).** Анти-чекер гарантирует \(|T| = poly(\log N)\).
  Фиксируя значения \(f\) на \(T\), мы уменьшаем число кандидатов в переборе в
  фактор \(2^{|T|}\) и допускаем дополнительное «расщепление» формулы на
  \(2^{|T|}\) конъюнктов. Итоговый размер формулы остаётся \(N^{2+\varepsilon}\)
  для любой \(\varepsilon>0\), если задать \(α < 1\) и \(|T|\) достаточно
  быстро растущим многочленом от \(\log N\).
- **Понижение глубины.** Балансировка (вариация леммы Спиры) превращает
  полиномиальную схему в формулу постоянной глубины с квадратичным blow-up;
  анти-чекер обеспечивает дополнительную экономию, позволяя удержать размер ниже
  порога \(N^{2+\delta}\).

### Связка с шагами Lean-пайплайна

- Шаг C (файл `pnp3/LowerBounds/AntiChecker.lean`) формализует существование
  анти-чекера и выводит `∀ solver, False` для малых формул — это лемма
  `LB_Formulas_core`.
- Шаг D (файл `pnp3/Magnification/Bridge_to_Magnification.lean`) использует
  мост `bridge_from_LB_Formulas`, который теперь вызывает доказанную теорему
  `OPS_trigger_formulas` и не опирается на аксиомы.
- Настоящий текст показывает, что формульный триггер реализуется из
  опубликованных результатов OPS/CJW посредством подстановки в общий триггер
  и связки с `LB_Formulas_core`.

## Итог

Гипотеза `FormulaLowerBoundHypothesis` (с любым \(\delta>0\)) запускает
формульный триггер OPS и даёт разделение классов: `NP \nsubseteq P/poly`. В
Lean этот триггер сводится к общему `OPS_trigger_general`, так что аргумент
реализован без дополнительных аксиом и согласован с проверенными результатами
OPS/CJW.
