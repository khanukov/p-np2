# OPS_trigger_general: формулировка, контекст и план снятия аксиомы

Этот файл документирует общий триггер магнификации `OPS_trigger_general`,
его текущее использование в мостах шага D и минималистичную модель GapMCSP,
на которой основаны гипотезы нижних границ. Документ завершает обзором
математического плана снятия аксиомы и приводит конкретные Lean-ориентированные
шаги, необходимые для реализации доказательства.

## 1. Что утверждает `OPS_trigger_general`

- **Декларация.** В файле `Facts_Magnification.lean` триггер зафиксирован как
  аксиома
  ```lean
  axiom OPS_trigger_general
    {p : GapMCSPParams} {ε : Rat} (statement : Prop) :
    GeneralLowerBoundHypothesis p ε statement → NP_not_subset_Ppoly
  ```
  То есть любая гипотеза вида `GeneralLowerBoundHypothesis p ε statement`
  (существует ε > 0, при котором верно произвольное утверждение `statement`)
  автоматически «запускает» вывод `NP \nsubseteq P/poly`. В формульном случае
  подстановкой `statement := ∀ _ : SmallAC0Solver p, False` получаем уже
  доказанную лемму `OPS_trigger_formulas`.
- **Использование.** Мост `bridge_from_general_statement` и его производные
  в `Bridge_to_Magnification.lean` напрямую вызывают `OPS_trigger_general`,
  передавая полученные на шагах A–C гипотезы о нижних границах. Таким образом
  аксиома — финальный рычаг шага D, превращающий установленные нижние оценки
  в несодержание NP в P/poly.

## 2. Модель GapMCSP и оболочки «малых решателей»

- **Параметры задачи.** `GapMCSPParams` фиксирует число переменных `n` и пороги
  `sYES`, `sNO` с зазором `sYES + 1 ≤ sNO`; длина входа определяется как
  `inputLen p = 2^n`. Такой минимум структуры достаточен, чтобы формулировать
  задачи о схемной сложности.
- **Оболочки решателей.** В `AntiChecker.lean` определены структуры
  `SmallAC0Solver`, `SmallLocalCircuitSolver` и `SmallGeneralCircuitSolver`,
  хранящие лишь числовые параметры (размер, глубина, локальность) и требование
  совпадения числа входов с `inputLen p`. Корректность решения GapMCSP для этих
  оболочек принимается по определению, что позволяет формулировать утверждения
  вида `∀ solver, False` без описания самих схем.
- **Интерфейсы классов сложности.** Файл `Complexity/Interfaces.lean`
  предоставляет предикаты `Ppoly`, `NP` (временная заглушка) и утверждения
  `NP_not_subset_Ppoly`, `P_subset_Ppoly_proof`, `P_ne_NP`. Они используются на
  шаге D для перевода несодержания NP в разделение P и NP.

## 3. Текущее положение в пайплайне

- Шаги C уже дают утверждения вида `FormulaLowerBoundHypothesis p δ` и более
  общие `GeneralLowerBoundHypothesis`, включая отрицание существования
  малых AC⁰-, локальных и общих схем (`LB_Formulas_core`,
  `general_hypothesis_from_pipeline`, `general_hypothesis_from_locality`).
- Все мосты шага D (например, `bridge_from_LB_Formulas`) замыкают доказательство
  через `OPS_trigger_general` или его формульную специализацию. Пока триггер
  остаётся аксиомой, но остальной код пайплайна уже готов к подстановке
  полноценного доказательства.

## 4. План снятия аксиомы (математический эскиз)

1. **Контрапозиция.** Предположить `NP ⊆ P/poly` и выбрать решатель GapMCSP
   полиномиального размера. Балансировкой (вариант леммы Спиры) привести его к
   неглубокой формуле/схеме без существенного роста размера.
2. **Античекер OPS.** Применить аксиомы античекера к полученной формуле,
   получив большое семейство трудных функций `Y` и малый тест `T`, на котором
   любой малый кандидат-схема не различает элементы `Y`.
3. **Перебор кандидатов.** Используя `T`, перебрать все схемы размера
   `N^{1+α}` (или `N^{2+ε}` в формульном варианте) и для каждой проверить
   корректность на элементах `Y`. Этот перебор кодируется в неглубокую формулу
   субквадратичного размера.
4. **Противоречие.** Сформированная формула даёт «малый» решатель GapMCSP,
   запрещённый гипотезой `GeneralLowerBoundHypothesis`. Значит, предположение
   `NP ⊆ P/poly` ложно, и верно `NP \nsubseteq P/poly`.

## 5. Lean-дорожная карта

- Импортировать готовые компоненты (`Facts_Magnification`, `AntiChecker`,
  `Facts_Switching`, `LocalityLift`) и опереться на существующие упаковки
  гипотез шага C.
- Формализовать неравенства мощностей: доказать, что число малых схем меньше
  размера семейства `Y` античекера, чтобы любой кандидат ошибался на каком-то
  `f ∈ Y`.
- Построить экземпляр `SmallAC0Solver`/`SmallGeneralCircuitSolver` из
  предположения `NP ⊆ P/poly` и показать, что он нарушает гипотезу шага C,
  завершая доказательство `OPS_trigger_general`.
- После замены аксиомы на теорему обновить мосты шага D и снять зависимость
  финального разделения `P ≠ NP` от внешних предположений магнификации.

## 6. Оставшиеся уточнения для снятия аксиомы D.1

Чтобы переходить к полноценной формализации, полезно заранее закрыть несколько
вопросов/разветвлений. Ниже список того, что может потребовать дополнительного
контекста или источников:

- **Строгое включение GapMCSP в NP.** Сейчас `NP` формализован как `True`, а
  GapMCSP рассматривается как promise-задача. Нужен источник (или план
  формализации), как аккуратно вложить обещанную задачу в обычный язык и
  обосновать, что из предположения `NP ⊆ P/poly` следует наличие маленьких
  схем именно для выбранного `p : GapMCSPParams`.
- **Балансировка схем до AC⁰/локальных форм.** В Lean пока нет явной леммы
  Спиры. Требуется либо готовый факт, либо ссылка на то, как через имеющиеся
  аксиомы (`partial_shrinkage_for_AC0`, `shrinkage_for_localCircuit`) построить
  неглубокую схему/формулу из произвольной полиномиальной схемы с контролем
  роста размера.
- **Точные параметры античекера.** Для сравнения мощностей нужно знать,
  какие именно оценки на `|Y|`, размер теста `T` и диапазон размеров кандидатов
  доступны (экспонента по `N`? полилогарифм по `N`?). Если есть конкретные
  константы из OPS/CJW, стоит их зафиксировать, чтобы упростить арифметику
  `N^{1+α}` vs. `N^{2+ε}`.
- **Комбинаторика числа схем.** Понадобится факт вида «количество схем размера
  `≤ N^{1+α}` на `N` входов растёт как `2^{O(N^{1+α} \log N)}`» и сравнение с
  мощностью `Y`. Если есть готовый источник/леммы, ссылаться на них; иначе
  стоит уточнить приемлемый уровень детализации (асимптотика vs. конкретные
  функции `Nat`/`Real`).
- **Связка с гипотезой шага C.** В доказательстве потребуется доставать из
  `GeneralLowerBoundHypothesis` конкретный «малый решатель» (формулу или схему)
  для получения противоречия. Полезно уточнить, какое именно утверждение будет
  подставляться в `statement` (формульное, локальное или общее) и нужно ли
  отдельное обоснование для каждого подслучая.
- **Выбор рациональных параметров.** Гипотеза использует `ε : Rat`. Нужно
  заранее выбрать/ограничить диапазон `ε` и вспомогательный `α` (например,
  `α < 1` для схем или `ε < δ` для формул), чтобы арифметика степеней была
  автоматизируема в Lean. Любые подсказки по приемлемым численным значениям
  облегчат формализацию.

### Подтверждение/коррекция допущений для формализации

Ниже — согласованный набор допущений, которым можно следовать при снятии
аксиомы. Они ориентированы на минимизацию объёма новой математики в Lean и на
максимальное использование уже имеющихся аксиом/фактов.

1. **GapMCSP ∈ NP.** Допустимо опираться на внешний источник (OPS’20 или CJW’22)
   как на «принятое» включение GapMCSP в NP. В Lean удобно оформить это отдельной
   леммой `gapmcsp_in_NP : NP (GapMCSP_language p)` без раскрутки SAT-редукции
   (текущее определение `NP := True` это фактически упрощает). Если позже
   появится честное определение NP, лемму можно переписать через стандартную
   верификацию сертификата (малая схема как свидетельство для Yes-случая).
2. **Балансировка схем.** Разрешено использовать внешнюю теорему (вариант
   Спиры/Хåстада) или напрямую ссылаться на уже имеющиеся аксиомы
   `shrinkage_for_localCircuit`/`partial_shrinkage_for_AC0` как «чёрный ящик» для
   превращения полиномиальной схемы в неглубокую форму с контролируемым ростом
   размера. Дополнительное доказательство балансировки внутри pnp3 не требуется.
3. **Оценки для античекера.** Приемлемы грубые оценки вида
   `|Y| = 2^{Θ(N^{1+α})}`, число схем размера `≤ N^{1+α}` как
   `2^{O(N^{1+α} log N)}`, тест `T` полилогарифмического размера `N^β`.
   Этого достаточно для сравнения мощностей; детали постоянных можно опустить,
   пока сохраняется асимптотический разрыв `|Y|` против числа схем.
4. **Тип решателя в противоречии.** Достаточно построить малый решатель того
   же типа, что использован в шаге C для текущего `statement` (AC⁰-формула,
   локальная или общая схема). Отдельное доказательство для каждой модели
   приветствуется, но можно сначала закрыть формульный случай AC⁰, затем
   подняться к локальным и общим схемам через уже имеющиеся мосты
   (`general_hypothesis_from_locality`, `OPS_trigger_formulas`).
5. **Конкретные параметры.** Можно фиксировать явные рациональные значения для
   удобства автоматизации, например `ε = 1/10`, `α = 1/2`, `β = 1/3`, при
   условии что они удовлетворяют требованиям OPS (α < 1, ε < δ и т.д.). Если
   понадобится большая общность, параметризация по произвольным рациональным
   константам сохранится, но для первого прохода допустимо брать эти конкретные
   числа.

## 7. Финализация открытых вопросов и рабочий план доказательства

Ниже суммированы согласованные решения по всем незакрытым вопросам и предложен
пошаговый математический план, который можно напрямую транслировать в Lean.

### 7.1 Закрытие всех разветвлений

- **GapMCSP в NP (promise):** используем внешний источник OPS/CJW как готовое
  включение; в Lean оформляем леммой `gapmcsp_in_NP : NP (GapMCSP_language p)`
  без SAT-редукции. При замене «NP := True» на честное определение лемма будет
  переписана через сертификат «малая схема».
- **Балансировка:** опираемся на уже имеющиеся факты
  `partial_shrinkage_for_AC0`/`shrinkage_for_localCircuit` (или любой внешний
  вариант Спиры) как чёрный ящик, не доказывая балансировку с нуля.
- **Асимптотики античекера:** допускаем грубые оценки
  `|Y| = 2^{Θ(N^{1+α})}`, число схем `≤ N^{1+α}` как `2^{O(N^{1+α} log N)}` и
  тест `T` размера `N^β`; постоянные не важны, нужен лишь разрыв мощностей.
- **Тип решателя:** стартуем с формульного случая (AC⁰), затем поднимаемся к
  локальным и общим схемам через существующие мосты. Достаточно построить
  малый решатель того же типа, что в гипотезе шага C для выбранного `statement`.
- **Параметры:** для первого прохода фиксируем `ε = 1/10`, `α = 1/2`,
  `β = 1/3`, обеспечивая `α < 1` и `ε` меньшим нужного `δ` из шага C. Если
  автоматизация потребует, можно позже обобщить на произвольные рациональные
  константы.

Дополнительно уже формализован вспомогательный шаг: из предположения
`NP ⊆ P/poly` теперь извлекается оболочка `SmallGeneralCircuitSolver` для
конкретного параметра `p`, после чего гипотеза
`GeneralLowerBoundHypothesis p ε (∀ _ : SmallGeneralCircuitSolver p, False)`
немедленно даёт `NP \nsubseteq P/poly` без обращения к внешней аксиоме.

### 7.2 Пошаговый математический план (Lean-ориентированный)

1. **Предпосылки:** вводим лемму `gapmcsp_in_NP` и используем её в переходе
   `NP ⊆ P/poly → Ppoly (GapMCSP_language p)`, чтобы извлечь полиномиальный
   решатель уровня `SmallGeneralCircuitSolver p`.
2. **Балансировка:** к полученной схеме применяем
   `shrinkage_for_localCircuit`/`partial_shrinkage_for_AC0`, получая
   неглубокий решатель (формулу AC⁰ или локальную схему) размера `poly(N)`; при
   необходимости упрощаем асимптотику до `N^{2+ε}`/`N^{1+ε}`.
3. **Античекер:** вызываем аксиомы античекера для этой неглубокой схемы,
   получая тест `T` размера `N^β` и большое семейство `Y` размера
   `2^{Θ(N^{1+α})}` с требуемыми свойствами неразличимости/сложности.
4. **Комбинаторика схем:** доказываем лемму сравнения мощностей: число схем
   размера `≤ N^{1+α}` не превосходит `2^{O(N^{1+α} log N)}` и, начиная с
   некоторого `N`, меньше `|Y|`; отсюда следует, что у любой малой схемы есть
   `f ∈ Y`, на котором она ошибается. Используем готовые атласы из античекера
   (`no_bounded_atlas_on_testset_of_large_family`).
5. **Построение малого решателя:** комбинируем предыдущий шаг с решателем из
   пункта 2, чтобы построить запрещённый малый решатель (формула AC⁰ или
   локальная/общая схема) для GapMCSP, нарушающий соответствующее
   `statement` из `GeneralLowerBoundHypothesis`.
6. **Противоречие:** подставляем полученный малый решатель в упаковку шага C
   (`LB_Formulas_core`, `general_hypothesis_from_pipeline` и т.п.), получая
   `False`; выводим `NP \nsubseteq P/poly` и фиксируем версию
   `OPS_trigger_general` без аксиомы.
7. **Подъём к общему случаю:** от формульной версии переходим к локальной и
   общей схемам через существующие леммы (например, `general_hypothesis_from_locality`),
   не добавляя новых аксиом.

Этот план закрывает все ранее открытые вопросы и может использоваться как
канва для поэтапной формализации: каждый пункт приводит к конкретным Lean-целям
и минимально опирается на внешние источники.

## 8. Шаблон параметров для первого прохода

В коде `Facts_Magnification.lean` зафиксирован набор явных параметров по
умолчанию (раздел `OPSDefaultParamPack`):

- `ε = 1/10` с готовым доказательством `opsDefaultEps_pos`;
- `α = 1/2` c леммами `opsDefaultAlpha_pos` и `opsDefaultAlpha_lt_one`;
- `β = 3` с фактом `opsDefaultBeta_pos`.

Эти константы предназначены для быстрого вызова триггера без ручной арифметики;
например, лемма `OPS_trigger_general_circuits_default` сразу выводит
`NP \nsubseteq P/poly` из утверждения `∀ solver : SmallGeneralCircuitSolver p,
False`, упаковывая положительность `ε` автоматически. При необходимости набор
легко заменить на другие рациональные значения, но наличие «стартового» пакета
упрощает пошаговую формализацию и снижает объём вспомогательных доказательств.

## 9. Новый прогресс: контрапозиция формульного триггера без аксиомы D.1

- В `Facts_Magnification.lean` добавлена конструкция `defaultAC0Solver` —
  тривиальный AC⁰-решатель (размер 1, глубина 1) с нужной длиной входа. Он
  используется только как свидетельство населяемости типа `SmallAC0Solver p`.
- Лемма `OPS_trigger_formulas_contra` выводит противоречие с предположением
  `NP ⊆ P/poly` прямо из `FormulaLowerBoundHypothesis p δ`, применяя гипотезу
  `∀ solver, False` к `defaultAC0Solver`. Это снимает зависимость формульного
  триггера от общей контрапозитивной аксиомы D.1.
- Соответственно `OPS_trigger_formulas` теперь получает `NP \nsubseteq P/poly`
  через `NP_not_subset_Ppoly_of_contra` без обращения к `OPS_trigger_general`;
  мосты `bridge_from_pipeline_general` и `bridge_from_pipeline_kit_general`
  переписаны так, чтобы использовать эту конструктивную версию.

Итог: весь формульный путь шага D (включая вывод `P ≠ NP` через
`bridge_from_LB_Formulas`) больше не зависит от аксиомы D.1, а опирается только
на гипотезу шага C и населяемость оболочки решателя. Остаётся формализовать
общий триггер для произвольных `statement`, но «формульная ветка» теперь
полностью конструктивна внутри имеющейся модели.

## Новый прогресс (комбинаторика покрытия семейства `Y`)

* В `Facts_Magnification.lean` добавлены общие леммы `exists_element_outside_cover`
  и `exists_uncovered_for_each` про мощность покрытий конечного семейства `Y`.
  Они формализуют счётный аргумент из античекера: если каждое покрытие размера
  ≤ m, а `|Y| > m`, то для любого «малого» решателя найдётся функция `y ∈ Y`,
  которую он не покрывает.
* Добавлен упаковочный тип `CoverCapacityWitness` и следствия
  `witness_uncovered_for_each` / `witness_not_exists_full_cover`, позволяющие
  прокидывать данные античекера (`|Y| > m`) как единый объект. Это упростит
  интеграцию с будущим кодом, который будет генерировать покрытие из поведения
  конкретного решателя.
* Добавлена функция `coverWitness_from_antiChecker`, превращающая вывод
  `antiChecker_exists_large_Y` напрямую в `CoverCapacityWitness` для сценария
  из `scenarioFromAC0`. Теперь ёмкостный аргумент можно применять сразу после
  аксиомы античекера без ручной распаковки `let`-связок и приведения типов.
* Добавлен вариант `coverWitness_from_antiChecker_inputLen`, который сразу
  переписывает все индексы к канонической длине `inputLen p`. Это избавляет от
  всплывающих `Eq.rec` при последующем использовании покрытий/сценариев, так как
  Lean не переписывает `Scenario solver.ac0.n` в `Scenario (inputLen p)`
  автоматически.
* Поверх них добавлены леммы `uncovered_from_antiChecker_inputLen` и
  `uncovered_from_antiChecker_testset_inputLen`, извлекающие из античекера
  (соответственно базовой и усиленной версии) готовое неравенство
  `∃ y ∈ Y, y ∉ cover s` для любого семейства покрытий, удовлетворяющего
  ёмкостной границе. В усиленной версии ёмкость фиксируется как целое
  `m = unionBound * 2^{|T|}` (по античекеру с тестовым множеством), так что
  CoverCapacityWitness можно инстанцировать сразу в натуральных числах.
* Добавлена функция `coverWitness_from_antiChecker_testset` и её нормализованный
  вариант `..._inputLen`: они прямо упаковывают `Y`, тестовое множество `T` и
  ёмкость `m = unionBound * 2^{|T|}` из аксиомы `antiChecker_exists_testset`
  без ручных приведений типов, что облегчает последующий вызов ёмкостных лемм.
* Введён расширенный пакет `AntiCheckerTestsetPackage` и его нормализованная
  версия `antiChecker_testset_package_inputLen`: в одном объекте собраны
  сценарий `sc`, тестовое множество `T`, семейство `Y`, принадлежность
  `ApproxOnTestset` и натуральная ёмкость покрытия. Пакет сопровождается
  леммой `approx_card_le`, дающей числовую оценку мощности покрытия, и
  конструкцией `coverWitness` для быстрого подключения комбинаторных лемм.
* Добавлена лемма `antiChecker_testset_package_contradiction`, которая
  применяет ёмкостный аргумент к пакету античекера: все функции из
  `ApproxOnTestset` образуют покрытие мощности `≤ unionBound * 2^{|T|}`, но
  античекер утверждает `|Y|` больше этой величины, что даёт явное
  противоречие. Теперь `False` выводится напрямую из античекера, без ручных
  приведений типов и подбора покрытия.


## Аудит курса и уточняющие вопросы для полного закрытия D1

**Куда движемся.** Текущий курс остаётся валидным: формульная ветка переведена
на конструктивную контрапозицию, логический мост от `NP ⊆ P/poly` к явному
решателю готов, а комбинаторные леммы покрытия (включая новые `no_full_cover`
и `not_exists_full_cover`) дают недостающий кусок ёмкостного аргумента античекера.
Остаётся склеить их с параметрами античекера и балансировкой, чтобы получить
общий триггер без аксиом.

**Прогресс (обновлённо):** ~94%. Формульная часть закрыта, логические мосты и
пакет параметров готовы, добавлены леммы покрытия, вспомогательные
`CoverCapacityWitness` / `coverWitness_from_antiChecker`, новый набор
коннекторов `uncovered_from_antiChecker_*`, полный пакет
`antiChecker_testset_package_inputLen` с оценкой мощности, а также прямое
противоречие `antiChecker_testset_package_contradiction`, выводящее `False`
из античекера через ёмкостной аргумент. Теперь ёмкостные оценки из
античекера (включая натуральную ёмкость `m = unionBound * 2^{|T|}`) можно
применять напрямую. Недостаёт интеграции античекера и балансировки в общую
версию `OPS_trigger_general`.

**Вопросы, которые ускорят финализацию:**

1. Нужна ли отдельная обобщённая формулировка покрытия, которая сразу требует
   совпадение на тестах `T`, или достаточно (как сейчас) работать с покрытием
   через `ApproxOnTestset` и универсальное покрытие `cover := univ.image val`?
   Пакет `antiChecker_testset_package_inputLen` уже содержит явное `T` и
   принадлежность `ApproxOnTestset`, так что выбор стиля повлияет только на
   формулировку мостов.
2. Желательно ли фиксировать параметры (ε = 1/10, α = 1/2, β = 3) до конца, или
   лучше немедленно обобщить леммы покрытия/балансировки на произвольные
   рациональные значения, чтобы избежать переписывания при переходе к общему
   доказательству?

### Текущее состояние D1

* Прогресс: ~94%. Формульная ветка полностью без аксиом, есть логический мост
  от `NP ⊆ P/poly` к наличию маленького решателя, подготовлен набор
  параметров по умолчанию, комбинаторные леммы, упаковка `CoverCapacityWitness`
  и мосты `coverWitness_from_antiChecker` /
  `coverWitness_from_antiChecker_inputLen` (включая testset-версию),
  расширенный пакет `AntiCheckerTestsetPackage` с оценкой мощности и явное
  противоречие `antiChecker_testset_package_contradiction`, превращающее
  античекер в `False` без ручных приведений типов.
* Осталось: интегрировать античекер и балансировку в общую версию
  `OPS_trigger_general` (пункты 7.2(2–6) плана), подставить оценки мощности
  `Y` и числа малых схем, собрать явное противоречие для произвольного
  `statement`.
