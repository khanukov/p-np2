import Mathlib.Data.Nat.Basic
import Mathlib.Data.Nat.Log
import Mathlib.Tactic

/-!
  pnp3/Models/Model_GapMCSP.lean

  На шаге C нам требуется лишь минималистичная модель параметров GapMCSP.
  Мы фиксируем число входных переменных `n` для функции, чью таблицу истинности
  длины `N = 2^n` рассматривает MCSP, а также два порога размеров схем —
  `sYES` и `sNO`, отвечающие за YES- и NO-слои gap-версии задачи.

  Эти данные будут использоваться в ядре нижней оценки: гипотеза о существовании
  «малого» решателя GapMCSP формулируется через такие параметры, а далее
  связывается с SAL и Covering-Power.
-/
namespace Pnp3
namespace Models

/--
  Параметры GapMCSP.  Нам достаточно знать количество переменных `n` и два
  порога размера схем `sYES < sNO`, задающих разрыв (gap) между YES- и NO-слоями.

  * `n` — число входных переменных функции. Таблица истинности имеет длину `2^n`.
  * `sYES` — верхняя граница на размер схемы, свидетельствующей ответ YES.
  * `sNO` — нижняя граница на размер схемы для NO-инстансов; по определению
    требуем `sYES + 1 ≤ sNO`, чтобы gap был ненулевым.
-/
structure GapMCSPParams where
  n : Nat
  sYES : Nat
  sNO : Nat
  gap_ok : sYES + 1 ≤ sNO
  /-- В дальнейших оценках предполагаем «достаточно большой» размер таблицы. -/
  n_large : 8 ≤ n
  deriving Repr

/-- Длина входа MCSP: `N = 2^n`. Это основная числовая характеристика задачи. -/
def inputLen (p : GapMCSPParams) : Nat := Nat.pow 2 p.n

/--
  Полилогарифмический бюджет, используемый в части C для ограничения размера
  тест-наборов античекера.  Определение выбрано произвольным, но удобным:
  четвёртая степень `log₂ (N + 1)`, увеличенная на единицу для избежания нулевых
  значений.  Такой бюджет достаточно мал (polylog `N`) и положителен для любых
  ненулевых `N`.
-/
def polylogBudget (N : Nat) : Nat :=
  (Nat.succ (Nat.log2 (Nat.succ N))) ^ 4

end Models
end Pnp3
