# MultiSwitching: оставшиеся пробелы для завершения индукции

## 1. Что уже построено

* Комбинированный осевой свидетель `CombinedAxisWitness` фиксирует общую ось и
  верхнюю границу ошибки для объединённого семейства формул. Это позволяет не
  возвращаться к `Classical.choose` и напрямую использовать одну и ту же ось на
  каждом шаге. 【F:pnp3/ThirdPartyFacts/MultiSwitching.lean†L3109-L3172】
* Структура `CombinedTailCertificate` собирает эту ось вместе с фактом, что
  любой объединённый селектор действительно встречается в листе хвостового
  дерева какого-то исходного пакета, и даёт удобные леммы вроде
  `selectors_mem_choose` и `pkg_epsilon_le`. 【F:pnp3/ThirdPartyFacts/MultiSwitching.lean†L3246-L3339】
* Для каждого пакетированного ввода глубины 1 уже подготовлены вспомогательные
  конструкции `packageTailCertificate`, `packageAxisWitness` и связанные леммы
  о селекторах, глубине и ошибках. Они позволяют растягивать хвосты на общий
  бюджет и гарантируют, что локальные хвосты согласованы с глобальной осью.
  【F:pnp3/ThirdPartyFacts/MultiSwitching.lean†L3458-L3666】【F:pnp3/ThirdPartyFacts/MultiSwitching.lean†L3687-L3798】

Эти компоненты покрывают почти все технические требования для шага
`d → d + 1`: ось зафиксирована, ошибки контролируются, локальные хвосты можно
поднимать до общего бюджета.

## 2. Ключевой недостающий элемент — сами хвосты

В `CombinedTailCertificate` **нет явного хранения хвостов**. Структура знает,
что любой селектор лежит в листьях подходящего хвоста (`selectors_mem`), но
не хранит соответствующие объекты `PDT`. Из-за этого невозможно восстановить
глобальный `PartialCertificate` напрямую из `CombinedTailCertificate`: у нас
нет данных, которые можно подать в `AxisWitness.toPartialCertificate...`.

*Проблема в коде.* `CombinedTailCertificate` содержит только поле `witness`
(которое само по себе не хранит хвосты) и доказательства о селекторах, но
отсутствует семейство хвостов `tails : Axis.Tails`. В идеальной реализации
нужно хранить явно функцию

```
tails : AxisLeaf C.witness.axis → PDT n
```

вместе с оценкой глубины каждого хвоста. Тогда `combinedTailSelectors` можно
будет переписать как `Axis.selectorsFromTails C.witness.axis tails`, а любая
глобальная конструкция (частичный сертификат, shrinkage) сможет работать с
этими данными напрямую. Сейчас же доказательства типа
`combinedTailSelectors_mem_exists` лишь свидетельствуют о существовании
подходящего хвоста внутри какого-то пакета, что недостаточно для конструкторов,
требующих настоящий `PDT`. 【F:pnp3/ThirdPartyFacts/MultiSwitching.lean†L3246-L3310】

*Что нужно сделать.*

1. Расширить контракт `CombinedTailCertificate`, добавив явное поле с глобальными
   хвостами `tails` (или эквивалентный набор данных), согласованное с осью из
   `CombinedAxisWitness`. Для каждого листа ствола нужно хранить конкретный `PDT`
   глубины `τ` на оставшихся координатах.
2. Обновить леммы `selectors_mem`, `selectors_mem_choose`, `err_le_fun` и
   т.п., чтобы они ссылались на новое поле `tails`. Доказательства почти не
   изменятся: текущие леммы уже показывают принадлежность селекторов к листьям
   локальных хвостов, остаётся только явно указать, из какого хвоста берётся
   лист.
3. Скорректировать конструктор `chooseCombinedTailCertificate`, чтобы он не
   только выбирал ось, но и возвращал соответствующее семейство хвостов. Сейчас
   он извлекает только `CombinedAxisWitness`; потребуется дополнительно собрать
   хвосты, которые раньше появлялись неявно при обращении к пакетам.

## 3. Где должен появиться глобальный `PartialCertificate`

Функция `Depth1WitnessInput.build`, которая должна упаковывать объединённые
хвосты в `AxisTailSystem.TailCertificate` для шага `d → d + 1`, пока вообще не
определена. По контракту структуры `Depth1WitnessInput` именно `build` выдаёт
частичный PDT, пригодный для передачи в модуль глубины 1. 【F:pnp3/ThirdPartyFacts/MultiSwitching.lean†L1169-L1287】

*Что нужно сделать после появления хвостов:*

1. Реализовать `build` через единый `PartialCertificate`, полученный из оси и
   хвостов `CombinedTailCertificate`. Ствол должен иметь длину `axisLength n M`,
   а хвосты — совпадать с глобальным семейством `tails`.
2. Определить селекторы как `Axis.selectorsFromTails` той же оси и тех же
   хвостов. В доказательстве `cover` использовать `mem_flattenedCNFs_iff`, чтобы
   перейти к конкретному пакету, и затем транспортировать локальное покрытие на
   глобальный `PartialDT` (воспользовавшись равенством селекторов и леммой о
   листах). Полезно заранее зафиксировать вспомогательную лемму уровня
   `transport_cover_via_selectors`, которая переносит покрытие с локального
   сертификата на глобальный при совпадении списков селекторов и знании, что
   каждый селектор является листом нового хвоста.
3. Обеспечить контроль глубины: сумма длины оси и уровня хвостов должна
   укладываться в `depthBudget M (d + 1)`. Это уже следует из имеющихся лемм о
   пакетах (`packageTailCertificate_depthBound`, `packageTailCertificate_depthLe`),
   но в реализации `build` нужно явно сослаться на неравенство
   `axisLength n M + τ ≤ τTotal`.

## 4. Финальный индуктивный шаг и демонтаж аксиомы

Даже после реализации `build` остаётся закрыть индуктивный переход в блоке
`Depth1WitnessInput.Budgeted` и переписать `Facts_Switching.lean`.

1. **Индуктивный переход.** Сейчас пакет `Budgeted` умеет поднимать хвосты на
   больший бюджет, но нет функции, которая из `CombinedTailCertificate` и списка
   пакетов строила бы новый пакет глубины `d + 1`. После появления глобального
   `build` нужно:
   * нормализовать индексы глубины (`normalizeDepthIndices` уже реализовано);
   * вызвать `build`, получить `TailCertificate` для объединённого семейства;
   * упаковать результат в `Depth1WitnessInput.Budgeted` с индексом `d + 1` и
     доказать стандартные свойства (`hτ`, `hlog`).
2. **Замена аксиомы.** Когда индукция соберёт частичный сертификат глубины `d`
   для каждой схемы `AC⁰`, можно переписать `Facts_Switching.lean`, заменив
   `partial_shrinkage_for_AC0` на теорему, использующую новый индуктивный шаг.
   Сейчас файл всё ещё содержит аксиому, а тесты опираются на неё напрямую.
   【F:pnp3/ThirdPartyFacts/Facts_Switching.lean†L37-L57】

## 5. Резюме

* В структуре `CombinedTailCertificate` уже добавлено поле `tails` с заглушкой,
  но без реальной реализации: необходимо предоставить конкретные PDT и оценки
  глубины вместо временных `sorry`.
* Без полноценного хранения хвостов в `CombinedTailCertificate` невозможно
  построить глобальный `PartialCertificate`, требуемый для
  `Depth1WitnessInput.build`.
* Реализация `build` должна опираться на глобальную ось и хвосты, а также
  переиспользовать локальные покрытия из пакетов.
* После появления `build` нужно завершить упаковку `Budgeted` и переписать
  `partial_shrinkage_for_AC0` как теорему.

Исправление этих трёх блоков закроет оставшиеся пробелы и позволит заменить
аксиому доказанным утверждением.
