# MultiSwitching: оставшиеся пробелы для завершения индукции

## 1. Что уже реализовано

* Комбинированный осевой свидетель `CombinedAxisWitness` фиксирует общую ось и
  верхнюю границу ошибки для объединённого семейства CNF. Это устраняет
  обращения к `Classical.choose` при повторном использовании оси. 【F:pnp3/ThirdPartyFacts/MultiSwitching.lean†L3124-L3208】
* Структура `CombinedTailCertificate` расширяет данные осевого свидетеля и уже
  хранит для каждого листа оси явный хвост `PDT`, контроль глубины и леммы о
  принадлежности селекторов. Она предоставляет вспомогательные результаты вроде
  `selectors_mem_choose` и `pkg_epsilon_le`. 【F:pnp3/ThirdPartyFacts/MultiSwitching.lean†L3246-L3438】
* Для каждого пакетированного ввода глубины 1 подготовлены конструкции
  `packageAxisWitness`, `packageTailCertificate` и их «бюджетные» версии,
  позволяющие автоматически поднимать локальные хвосты на общий бюджет глубины
  и связывать их с глобальной осью. 【F:pnp3/ThirdPartyFacts/MultiSwitching.lean†L3620-L4156】

Иными словами, почти вся инфраструктура для работы с хвостами глубины 1 уже
подготовлена.

## 2. Где остаются пробелы

1. **Конкретизация глобальных хвостов.** Хотя `CombinedTailCertificate` хранит
   поле `tails`, его конструктор `chooseCombinedTailCertificate` пока заполняет
   это поле через заглушки: доказательство `selectors_mem_global` остаётся с
   `sorry`. Следовательно, мы ещё не можем получить гарантированный `PartialDT`
   для объединённого семейства. 【F:pnp3/ThirdPartyFacts/MultiSwitching.lean†L3381-L3419】
2. **Глобальный частичный сертификат.** Функция
   `CombinedTailCertificate.partialCertificate`, а вместе с ней и
   `CombinedTailCertificate.tailCertificate`, тоже содержат `sorry`. Пока не
   доказано, что селекторы действительно лежат в листьях построенного дерева,
   и не показан перенос оценок ошибки. 【F:pnp3/ThirdPartyFacts/MultiSwitching.lean†L3505-L3577】
3. **Интеграция в шаг `d → d + 1`.** После появления полноценного хвостового
   сертификата нужно реализовать упаковку в `Depth1WitnessInput` и закончить
   индукцию. Пока соответствующие леммы не завершены, поэтому аксиома
   `partial_shrinkage_for_AC0` в `Facts_Switching.lean` остаётся невытесненной.

## 3. Ближайшие действия

1. **Закрыть `sorry` в `chooseCombinedTailCertificate`.** Нужно показать, что
   глобальные селекторы действительно лежат в листьях выбранных хвостов и что
   глубина хвостов ограничена `τ`. Для этого придётся объединить хвосты всех
   пакетов (вероятно, через аккуратную конструкцию `PDT.refine`).
2. **Построить частичный сертификат.** После того как поле `tails` будет
   корректным, необходимо завершить доказательства в
   `CombinedTailCertificate.partialCertificate` и `tailCertificate`, обеспечив
   контроль селекторов и ошибки.
3. **Индуктивная упаковка.** С готовым глобальным хвостовым сертификатом можно
   реализовать конструктор шага `d → d + 1` в разделе `Depth1WitnessInput` и
   перейти к демонтажу аксиомы `partial_shrinkage_for_AC0`.

Эти три пункта образуют минимальный маршрут к завершению multi-switching и
замене аксиомы shrinkage на доказанную теорему.
