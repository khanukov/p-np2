import Mathlib.Data.List.Basic
import Mathlib.Data.Finset.Card
import Mathlib.Data.Finset.Basic
import Core.BooleanBasics
import Core.PDT

/-!
  # Switching Lemma (H√•stad, Servedio-Tan)

  –§–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–æ–π switching lemma –∏ –µ—ë –º–Ω–æ–≥–æ—Ñ–æ—Ä–º—É–ª—å–Ω–æ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç–∞.

  ## –°—Ç—Ä—É–∫—Ç—É—Ä–∞:

  1. **Clause statuses** - –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π `ClauseStatus` –∏–∑ BooleanBasics
  2. **Canonical DT** –¥–ª—è CNF –ø—Ä–∏ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–∏
  3. **Barcode** (—à—Ç—Ä–∏—Ö-–∫–æ–¥) –¥–ª—è –∏–Ω—ä–µ–∫—Ç–∏–≤–Ω–æ–≥–æ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è "–ø–ª–æ—Ö–∏—Ö" –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
  4. **Single switching** : Pr[DT(F|œÅ) ‚â• t] ‚â§ (C¬∑p¬∑k)^t
  5. **Multi-switching** : Pr[PDT_‚Ñì(ùìï|œÅ) ‚â• t] ‚â§ S^‚åàt/‚Ñì‚åâ ¬∑ (C¬∑p¬∑k)^t

  ## –ü–∞—Ä–∞–º–µ—Ç—Ä—ã (—Å–æ–≥–ª–∞—Å–Ω–æ –•—ë—Å—Ç–∞–¥–∞/Servedio-Tan):

  - p = 1/(4k) –≥–¥–µ k - —à–∏—Ä–∏–Ω–∞ CNF
  - ‚Ñì = ‚åàlog‚ÇÇ(M+2)‚åâ - tail depth
  - t = 4‚Ñì¬∑(‚åàlog‚ÇÇS‚åâ + ‚åàlog‚ÇÇ((n+2)d)‚åâ) - trunk depth per round
  - C = 16 - –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –•—ë—Å—Ç–∞–¥–∞ (–º–æ–∂–Ω–æ –ª—é–±—É—é C ‚â• 5)

  ## –°—Ç–∞—Ç—É—Å:

  - ‚úÖ ClauseStatus infrastructure (—É–∂–µ –≤ BooleanBasics)
  - ‚úÖ firstPendingClause? (—É–∂–µ –≤ BooleanBasics)
  - üîß Canonical DT construction (–≤ –ø—Ä–æ—Ü–µ—Å—Å–µ)
  - üîß Barcode encoding/decoding
  - üîß Weight bounds
-/

namespace Pnp3
namespace ThirdPartyFacts
namespace SwitchingLemma

open Core

variable {n w : Nat}

/-!
  ## Section 1: Canonical Decision Tree Construction

  –ö–∞–Ω–æ–Ω–∏—á–µ—Å–∫–æ–µ —Ä–µ—à–∞—é—â–µ–µ –¥–µ—Ä–µ–≤–æ –¥–ª—è k-CNF —Å—Ç—Ä–æ–∏—Ç—Å—è —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º:
  1. –ï—Å–ª–∏ –≤—Å–µ –∫–ª–∞—É–∑—ã satisfied ‚Üí –≤–æ–∑–≤—Ä–∞—â–∞–µ–º leaf true
  2. –ï—Å–ª–∏ –µ—Å—Ç—å falsified –∫–ª–∞—É–∑–∞ ‚Üí –≤–æ–∑–≤—Ä–∞—â–∞–µ–º leaf false
  3. –ò–Ω–∞—á–µ: –±–µ—Ä—ë–º –ø–µ—Ä–≤—É—é pending –∫–ª–∞—É–∑—É, –≤—ã–±–∏—Ä–∞–µ–º –ø–µ—Ä–≤—ã–π unassigned –ª–∏—Ç–µ—Ä–∞–ª,
     –≤–µ—Ç–≤–∏–º—Å—è –ø–æ –Ω–µ–º—É –∏ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å—Ç—Ä–æ–∏–º –ø–æ–¥–¥–µ—Ä–µ–≤—å—è

  –≠—Ç–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è DPLL-–ø—Ä–æ—Ü–µ–¥—É—Ä–∞ –±–µ–∑ —ç–≤—Ä–∏—Å—Ç–∏–∫.
-/

/--
  –ì–ª—É–±–∏–Ω–∞ –∫–∞–Ω–æ–Ω–∏—á–µ—Å–∫–æ–≥–æ DT: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–∞–≥–æ–≤ –≤–µ—Ç–≤–ª–µ–Ω–∏—è –¥–æ —Ç–µ—Ä–º–∏–Ω–∞—Ü–∏–∏.

  –ú—ã –æ–ø—Ä–µ–¥–µ–ª—è–µ–º —ç—Ç–æ —á–µ—Ä–µ–∑ —Ç–æ–ø–ª–∏–≤–æ (fuel-based recursion), —á—Ç–æ–±—ã –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å
  –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –≤ Lean. –ï—Å–ª–∏ fuel = 0, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º 0. –ò–Ω–∞—á–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –ø–µ—Ä–≤–æ–π
  pending –∫–ª–∞—É–∑—ã –∏ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –≤—ã—á–∏—Å–ª—è–µ–º –≥–ª—É–±–∏–Ω—É.
-/
def canonicalDTDepth (F : CNF n w) (œÅ : Restriction n) (fuel : Nat) : Nat :=
  match fuel with
  | 0 => 0
  | Nat.succ fuel' =>
      match œÅ.firstPendingClause? F.clauses with
      | none => 0  -- –≤—Å–µ –∫–ª–∞—É–∑—ã satisfied –∏–ª–∏ falsified
      | some selection =>
          let lit := selection.witness.free.head selection.witness.nonempty
          -- –í–µ—Ç–≤–∏–º—Å—è –ø–æ –ª–∏—Ç–µ—Ä–∞–ª—É lit
          let depth0 := match œÅ.assign lit.idx false with
            | none => 0
            | some œÅ' => canonicalDTDepth F œÅ' fuel'
          let depth1 := match œÅ.assign lit.idx true with
            | none => 0
            | some œÅ' => canonicalDTDepth F œÅ' fuel'
          1 + max depth0 depth1

/--
  –ü—Ä–µ–¥–∏–∫–∞—Ç: –∫–∞–Ω–æ–Ω–∏—á–µ—Å–∫–æ–µ DT –∏–º–µ–µ—Ç –≥–ª—É–±–∏–Ω—É ‚â• t.
  –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –ø—Ä–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–º fuel canonicalDTDepth ‚â• t.
-/
def hasCanonicalDTDepthGE (F : CNF n w) (œÅ : Restriction n) (t : Nat) : Prop :=
  ‚àÉ fuel : Nat, canonicalDTDepth F œÅ fuel ‚â• t

/--
  –ú–æ–Ω–æ—Ç–æ–Ω–Ω–æ—Å—Ç—å –ø–æ fuel: –±–æ–ª—å—à–µ–µ —Ç–æ–ø–ª–∏–≤–æ –¥–∞—ë—Ç –Ω–µ –º–µ–Ω—å—à—É—é –≥–ª—É–±–∏–Ω—É.

  –≠—Ç–æ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è hasCanonicalDTDepthGE.
  –î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ —Ç—Ä–µ–±—É–µ—Ç –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–±–æ—Ä–∞ match-–≤—ã—Ä–∞–∂–µ–Ω–∏–π –≤ canonicalDTDepth.
-/
lemma canonicalDTDepth_mono (F : CNF n w) (œÅ : Restriction n)
    (fuel‚ÇÅ fuel‚ÇÇ : Nat) (h : fuel‚ÇÅ ‚â§ fuel‚ÇÇ) :
    canonicalDTDepth F œÅ fuel‚ÇÅ ‚â§ canonicalDTDepth F œÅ fuel‚ÇÇ := by
  sorry  -- –¢—Ä–µ–±—É–µ—Ç—Å—è –¥–µ—Ç–∞–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏–µ–º match-–≤—ã—Ä–∞–∂–µ–Ω–∏–π

/-- –ï—Å–ª–∏ –ø—Ä–∏ fuel –¥–æ—Å—Ç–∏–≥–∞–µ—Ç—Å—è –≥–ª—É–±–∏–Ω–∞ t, —Ç–æ –∏ –ø—Ä–∏ –±–æ–ª—å—à–µ–º fuel —Ç–æ–∂–µ. -/
lemma hasCanonicalDTDepthGE_mono (F : CNF n w) (œÅ : Restriction n) (t : Nat)
    (h : hasCanonicalDTDepthGE F œÅ t) (fuel : Nat) :
    ‚àÉ fuel' : Nat, fuel' ‚â• fuel ‚àß canonicalDTDepth F œÅ fuel' ‚â• t := by
  obtain ‚ü®fuel‚ÇÄ, hfuel‚ÇÄ‚ü© := h
  use max fuel fuel‚ÇÄ
  constructor
  ¬∑ exact Nat.le_max_left _ _
  ¬∑ have := canonicalDTDepth_mono F œÅ fuel‚ÇÄ (max fuel fuel‚ÇÄ) (Nat.le_max_right _ _)
    exact Nat.le_trans hfuel‚ÇÄ this

/-!
  ## Section 2: Barcode Structure

  –®—Ç—Ä–∏—Ö-–∫–æ–¥ –∫–æ–¥–∏—Ä—É–µ—Ç "–ø–ª–æ—Ö–æ–µ" –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ (–≥–¥–µ DT –≥–ª—É–±–æ–∫–æ) —á–µ—Ä–µ–∑:
  - –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ª–∏—Ç–µ—Ä–∞–ª–æ–≤, –ø–æ –∫–æ—Ç–æ—Ä—ã–º –≤–µ—Ç–≤–∏–ª–∏—Å—å
  - –ë–∏—Ç—ã –ø—É—Ç–∏ (false/true –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≤–µ—Ç–≤–ª–µ–Ω–∏—è)
  - –ò–Ω–≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –∏—Å—Ö–æ–¥–Ω–æ–≥–æ œÅ
-/

/--
  –®–∞–≥ —Ç—Ä–∞—Å—Å—ã: –ª–∏—Ç–µ—Ä–∞–ª, –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É –≤–µ—Ç–≤–∏–ª–∏—Å—å, –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (false/true).
-/
structure TraceStep (n : Nat) where
  lit : Literal n
  direction : Bool
  deriving Repr, DecidableEq

/--
  Barcode: –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —à–∞–≥–æ–≤ —Ç—Ä–∞—Å—Å—ã.

  –ò–Ω–≤–∞—Ä–∏–∞–Ω—Ç—ã:
  - length = t (–∑–∞–¥–∞–Ω–Ω–∞—è –≥–ª—É–±–∏–Ω–∞)
  - literalsDistinct: –∏–Ω–¥–µ–∫—Å—ã –ª–∏—Ç–µ—Ä–∞–ª–æ–≤ –ø–æ–ø–∞—Ä–Ω–æ —Ä–∞–∑–ª–∏—á–Ω—ã (–º—ã —Ñ–∏–∫—Å–∏—Ä—É–µ–º –∫–∞–∂–¥—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –Ω–µ –±–æ–ª–µ–µ 1 —Ä–∞–∑–∞)
-/
structure Barcode (n t : Nat) where
  steps : List (TraceStep n)
  length_eq : steps.length = t
  literalsDistinct : (steps.map (fun s => s.lit.idx)).Nodup
  deriving Repr

/-!
  ## Section 3: Encoding & Decoding

  encode: —Å—Ç—Ä–æ–∏–º barcode –∏–∑ "–ø–ª–æ—Ö–æ–≥–æ" –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
  decode: –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∏–∑ barcode
-/

/--
  –ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ: –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ —Å—Ç—Ä–æ–∏–º —Ç—Ä–∞—Å—Å—É –∫–∞–Ω–æ–Ω–∏—á–µ—Å–∫–æ–≥–æ DT.

  –ü—Ä–æ—Ü–µ–¥—É—Ä–∞:
  1. –ù–∞—Ö–æ–¥–∏–º –ø–µ—Ä–≤—É—é pending –∫–ª–∞—É–∑—É
  2. –í—ã–±–∏—Ä–∞–µ–º –ø–µ—Ä–≤—ã–π unassigned –ª–∏—Ç–µ—Ä–∞–ª –∏–∑ –Ω–µ—ë
  3. –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –ª–∏—Ç–µ—Ä–∞–ª –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–µ—Ç–≤–ª–µ–Ω–∏—è
  4. –§–∏–∫—Å–∏—Ä—É–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é —Å–æ–≥–ª–∞—Å–Ω–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é
  5. –ü–æ–≤—Ç–æ—Ä—è–µ–º t —Ä–∞–∑
-/
noncomputable def encodeAux
    (F : CNF n w) (œÅ : Restriction n) :
    (fuel : Nat) ‚Üí List (TraceStep n)
  | 0 => []
  | Nat.succ fuel' =>
      match œÅ.firstPendingClause? F.clauses with
      | none => []
      | some selection =>
          let lit := selection.witness.free.head selection.witness.nonempty
          -- –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: –≤—ã–±–∏—Ä–∞–µ–º –≤–µ—Ç–∫—É —Å –±–æ–ª—å—à–µ–π –≥–ª—É–±–∏–Ω–æ–π
          let depth0 := match œÅ.assign lit.idx false with
            | none => 0
            | some œÅ' => canonicalDTDepth F œÅ' fuel'
          let depth1 := match œÅ.assign lit.idx true with
            | none => 0
            | some œÅ' => canonicalDTDepth F œÅ' fuel'
          let direction := depth0 ‚â§ depth1  -- true if depth1 ‚â• depth0
          let step := TraceStep.mk lit direction
          match œÅ.assign lit.idx direction with
          | none => [step]
          | some œÅ' => step :: encodeAux F œÅ' fuel'

noncomputable def encode
    (F : CNF n w) (œÅ : Restriction n) (t : Nat)
    (hdeep : hasCanonicalDTDepthGE F œÅ t) :
    Barcode n t :=
  -- –ò–∑–≤–ª–µ–∫–∞–µ–º —Å–≤–∏–¥–µ—Ç–µ–ª—è –∏–∑ hasCanonicalDTDepthGE
  let fuel := Classical.choose hdeep
  -- –ò—Å–ø–æ–ª—å–∑—É–µ–º fuel + t –∫–∞–∫ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–µ —Ç–æ–ø–ª–∏–≤–æ
  let steps := encodeAux F œÅ (fuel + t)
  -- –ë–µ—Ä—ë–º –ø–µ—Ä–≤—ã–µ t —à–∞–≥–æ–≤
  let steps_t := steps.take t
  -- –ü–æ–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º sorry –¥–ª—è –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤ –∏–Ω–≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
  { steps := steps_t
    length_eq := sorry
    literalsDistinct := sorry }

/--
  –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ: –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∏–∑ barcode.

  –ù–∞—á–∏–Ω–∞–µ–º —Å –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ —Ñ–∏–∫—Å–∏—Ä—É–µ–º
  –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–æ–≥–ª–∞—Å–Ω–æ —à–∞–≥–∞–º barcode.
-/
noncomputable def decode (bc : Barcode n t) : Restriction n :=
  bc.steps.foldl
    (fun œÅ step =>
      match œÅ.assign step.lit.idx step.direction with
      | none => œÅ  -- –Ω–µ –¥–æ–ª–∂–Ω–æ —Å–ª—É—á–∏—Ç—å—Å—è –∏–∑-–∑–∞ literalsDistinct
      | some œÅ' => œÅ')
    (Restriction.free n)

/--
  –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –≤ decode(barcode) —Ä–∞–≤–Ω–æ –¥–ª–∏–Ω–µ barcode.

  –≠—Ç–æ —Å–ª–µ–¥—É–µ—Ç –∏–∑ literalsDistinct: –∫–∞–∂–¥—ã–π —à–∞–≥ —Ñ–∏–∫—Å–∏—Ä—É–µ—Ç –Ω–æ–≤—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é.
-/
lemma decode_freeCount (bc : Barcode n t) :
    (decode bc).freeCount = n - t := by
  sorry  -- –ò–Ω–¥—É–∫—Ü–∏—è –ø–æ bc.steps —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º literalsDistinct

/--
  **–ö–õ–Æ–ß–ï–í–ê–Ø –¢–ï–û–†–ï–ú–ê**: decode ‚àò encode = id

  –≠—Ç–æ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –∏–Ω—ä–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è, —á—Ç–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–ª—è
  –ø–æ–¥—Å—á—ë—Ç–∞ –≤–µ—Å–æ–≤ "–ø–ª–æ—Ö–∏—Ö" –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π.
-/
theorem decode_encode_id
    (F : CNF n w) (œÅ : Restriction n) (t : Nat)
    (hdeep : hasCanonicalDTDepthGE F œÅ t) :
    decode (encode F œÅ t hdeep) = œÅ := by
  sorry  -- –∏–Ω–¥—É–∫—Ü–∏—è –ø–æ —à–∞–≥–∞–º —Ç—Ä–∞—Å—Å—ã

/-!
  ## Section 4: Weight Bounds

  –í–µ—Å "–ø–ª–æ—Ö–æ–≥–æ" –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –º–æ–∂–Ω–æ –æ—Ü–µ–Ω–∏—Ç—å —á–µ—Ä–µ–∑ barcode.
  –ö–ª—é—á–µ–≤–æ–µ –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ: –∫–∞–∂–¥—ã–π —à–∞–≥ —Ñ–∏–∫—Å–∞—Ü–∏–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —É–º–Ω–æ–∂–∞–µ—Ç –≤–µ—Å
  –Ω–∞ (1-p)/(2p), –∞ –≤—Å–µ–≥–æ —à–∞–≥–æ–≤ t.
-/

/--
  –í–µ—Å —É–º–µ–Ω—å—à–∞–µ—Ç—Å—è –ø—Ä–∏ —Ñ–∏–∫—Å–∞—Ü–∏–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π.
  –ï—Å–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –±—ã–ª–∞ —Å–≤–æ–±–æ–¥–Ω–∞ (–≤–µ—Å p), –ø–æ—Å–ª–µ —Ñ–∏–∫—Å–∞—Ü–∏–∏ –æ–Ω–∞ –¥–∞—ë—Ç (1-p)/2.
  –û—Ç–Ω–æ—à–µ–Ω–∏–µ: ((1-p)/2) / p = (1-p)/(2p).
-/
lemma weight_assign_ratio (œÅ : Restriction n) (i : Fin n) (b : Bool) (p : Q)
    (hfree : œÅ.mask i = none) (hp : 0 < p) (hp1 : p < 1) :
    ‚àÄ œÅ', œÅ.assign i b = some œÅ' ‚Üí
      Restriction.weight œÅ' p = ((1 - p) / (2 * p)) * Restriction.weight œÅ p := by
  intro œÅ' hassign
  -- –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –ª–µ–º–º—É weight_unassign_mul –≤ –æ–±—Ä–∞—Ç–Ω—É—é —Å—Ç–æ—Ä–æ–Ω—É
  have hunassign : œÅ'.unassign i = œÅ := by
    sorry  -- –≤—ã—Ç–µ–∫–∞–µ—Ç –∏–∑ assign_unassign_inverse
  have hmask' : œÅ'.mask i = some b := by
    sorry  -- –≤—ã—Ç–µ–∫–∞–µ—Ç –∏–∑ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è assign
  have hp_ne : p ‚â† 1 := by
    intro heq
    rw [heq] at hp1
    exact (lt_irrefl (1 : Q)) hp1
  have := Restriction.weight_unassign_mul œÅ' i p hmask' hp_ne
  rw [hunassign] at this
  -- –¢–µ–ø–µ—Ä—å this –≥–æ–≤–æ—Ä–∏—Ç: weight œÅ p = (2p/(1-p)) * weight œÅ' p
  -- –û—Ç—Å—é–¥–∞: weight œÅ' p = ((1-p)/(2p)) * weight œÅ p
  sorry  -- –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è

/--
  –í–µ—Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è, –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –≤ barcode.
  –ù–∞—á–∏–Ω–∞–µ–º —Å –≤–µ—Å–∞ p^n (–ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–≤–æ–±–æ–¥–Ω–æ–µ) –∏ —É–º–Ω–æ–∂–∞–µ–º –Ω–∞ (1-p)/(2p) –∑–∞ –∫–∞–∂–¥—ã–π —à–∞–≥.
-/
noncomputable def barcodeWeight (p : Q) (bc : Barcode n t) : Q :=
  Restriction.weight (decode bc) p

/--
  –í–µ—Å –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è —Ä–∞–≤–µ–Ω p^n.

  –î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ: Restriction.free –∏–º–µ–µ—Ç mask i = none –¥–ª—è –≤—Å–µ—Ö i,
  –ø–æ—ç—Ç–æ–º—É –∫–∞–∂–¥—ã–π –º–Ω–æ–∂–∏—Ç–µ–ª—å –≤ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–∏ —Ä–∞–≤–µ–Ω p, –∏—Ç–æ–≥–æ p^n.
-/
lemma weight_free (n : Nat) (p : Q) :
    Restriction.weight (Restriction.free n) p = p ^ n := by
  unfold Restriction.weight Restriction.free
  simp only [Finset.prod_const, Finset.card_univ, Fintype.card_fin]

/--
  –û—Ü–µ–Ω–∫–∞ –≤–µ—Å–∞ –æ–¥–Ω–æ–≥–æ barcode.
  –ü—Ä–∏ –∫–∞–∂–¥–æ–π —Ñ–∏–∫—Å–∞—Ü–∏–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –≤–µ—Å —É–º–Ω–æ–∂–∞–µ—Ç—Å—è –Ω–∞ (1-p)/(2p).

  –î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ: decode –Ω–∞—á–∏–Ω–∞–µ—Ç —Å free restriction (–≤–µ—Å p^n) –∏ –ø—Ä–∏–º–µ–Ω—è–µ—Ç
  t –æ–ø–µ—Ä–∞—Ü–∏–π assign. –ö–∞–∂–¥–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è —É–º–Ω–æ–∂–∞–µ—Ç –≤–µ—Å –Ω–∞ (1-p)/(2p).
  –ò—Ç–æ–≥–æ: p^n * ((1-p)/(2p))^t.
-/
theorem barcodeWeight_bound
    (p : Q) (k t : Nat)
    (hp : 0 < p) (hp1 : p < 1)
    (hpk : p = 1 / (4 * k))  -- –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –≤—ã–±–æ—Ä
    (bc : Barcode n t) :
    barcodeWeight p bc ‚â§ p^n * ((1 - p) / (2 * p))^t := by
  unfold barcodeWeight decode
  -- decode –ø—Ä–∏–º–µ–Ω—è–µ—Ç foldl assign –∫ Restriction.free n
  -- –ò–Ω–¥—É–∫—Ü–∏—è –ø–æ bc.steps
  have hstart : Restriction.weight (Restriction.free n) p = p ^ n :=
    weight_free n p
  -- –ü–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ —à–∞–≥–∞ –≤–µ—Å —É–º–Ω–æ–∂–∞–µ—Ç—Å—è –Ω–∞ (1-p)/(2p)
  -- –ò–Ω–≤–∞—Ä–∏–∞–Ω—Ç: –ø–æ—Å–ª–µ i —à–∞–≥–æ–≤ –≤–µ—Å ‚â§ p^n * ((1-p)/(2p))^i
  sorry

/--
  –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö barcodes –¥–ª–∏–Ω—ã t —Å –ª–∏—Ç–µ—Ä–∞–ª–∞–º–∏ –∏–∑ k-CNF.

  –û—Ü–µ–Ω–∫–∞: –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ –≤—ã–±–∏—Ä–∞–µ–º –æ–¥–∏–Ω –∏–∑ ‚â§ k –ª–∏—Ç–µ—Ä–∞–ª–æ–≤ –ø–µ—Ä–≤–æ–π pending –∫–ª–∞—É–∑—ã
  –∏ –æ–¥–Ω–æ –∏–∑ 2 –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π ‚Üí –Ω–µ –±–æ–ª–µ–µ (2k)^t barcodes.

  –î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ:
  1. –ö–∞–∂–¥—ã–π barcode - —ç—Ç–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏–∑ t —à–∞–≥–æ–≤ (TraceStep)
  2. –ö–∞–∂–¥—ã–π —à–∞–≥ - —ç—Ç–æ –ª–∏—Ç–µ—Ä–∞–ª + –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (Bool)
  3. –õ–∏—Ç–µ—Ä–∞–ª –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è –∏–∑ pending clause, –∫–æ—Ç–æ—Ä–∞—è –∏–º–µ–µ—Ç —à–∏—Ä–∏–Ω—É ‚â§ w ‚â§ k
  4. –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ - –æ–¥–Ω–æ –∏–∑ 2 –∑–Ω–∞—á–µ–Ω–∏–π
  5. –ò—Ç–æ–≥–æ: –Ω–µ –±–æ–ª–µ–µ k –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –ª–∏—Ç–µ—Ä–∞–ª–∞ * 2 –≤–∞—Ä–∏–∞–Ω—Ç–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è = 2k –Ω–∞ —à–∞–≥
  6. –ó–∞ t —à–∞–≥–æ–≤: (2k)^t
-/
theorem barcode_count_bound
    (F : CNF n w) (k t : Nat)
    (hwidth : w ‚â§ k) :
    ‚àÉ barcodes : Finset (Barcode n t),
      (‚àÄ œÅ, hasCanonicalDTDepthGE F œÅ t ‚Üí encode F œÅ t sorry ‚àà barcodes) ‚àß
      barcodes.card ‚â§ (2 * k) ^ t := by
  -- –ü–æ—Å—Ç—Ä–æ–∏–º —Ñ–∏–Ω–∏—Ç–Ω–æ–µ –º–Ω–æ–∂–µ—Å—Ç–≤–æ –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö barcodes
  -- –í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–µ–π –¥–ª–∏–Ω—ã t
  -- –≥–¥–µ –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç - —ç—Ç–æ (literal –∏–∑ n –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö, direction –∏–∑ 2 –∑–Ω–∞—á–µ–Ω–∏–π)
  -- –ù–æ –Ω–∞–º –Ω—É–∂–Ω–æ —É—á–µ—Å—Ç—å, —á—Ç–æ –ª–∏—Ç–µ—Ä–∞–ª—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å distinct
  -- –∏ –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –∏–∑ pending clauses —à–∏—Ä–∏–Ω—ã ‚â§ k
  sorry

/-!
  ## Section 5: Single Switching Bound

  –°–æ–±–∏—Ä–∞–µ–º –≤—Å—ë –≤–º–µ—Å—Ç–µ: —Å—É–º–º–∞ –≤–µ—Å–æ–≤ "–ø–ª–æ—Ö–∏—Ö" –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π ‚â§ (C¬∑p¬∑k)^t
-/

/--
  –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø—Ä–æ–≤–∞–ª–∞ (failure probability): —Å—É–º–º–∞—Ä–Ω—ã–π –≤–µ—Å –≤—Å–µ—Ö œÅ,
  –≥–¥–µ –∫–∞–Ω–æ–Ω–∏—á–µ—Å–∫–æ–µ DT –∏–º–µ–µ—Ç –≥–ª—É–±–∏–Ω—É ‚â• t.

  –§–æ—Ä–º–∞–ª—å–Ω–æ: —ç—Ç–æ —Å—É–º–º–∞ –≤–µ—Å–æ–≤ –≤—Å–µ—Ö restrictions —Å –≥–ª—É–±–∏–Ω–æ–π ‚â• t.
  –ú—ã –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ–º —ç—Ç–æ —á–µ—Ä–µ–∑ –∏–Ω—ä–µ–∫—Ç–∏–≤–Ω–æ–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ barcodes.
-/
noncomputable def failureProbability (F : CNF n w) (p : Q) (t : Nat) : Q :=
  -- –í –∏–¥–µ–∞–ª–µ: —Å—É–º–º–∞ –ø–æ –≤—Å–µ–º œÅ : Restriction n —Ç–∞–∫–∏–º, —á—Ç–æ hasCanonicalDTDepthGE F œÅ t
  -- –ù–æ restrictions - –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–µ –º–Ω–æ–∂–µ—Å—Ç–≤–æ, –ø–æ—ç—Ç–æ–º—É –∏—Å–ø–æ–ª—å–∑—É–µ–º barcodes
  -- –î–ª—è —Ü–µ–ª–µ–π —Ç–µ–æ—Ä–µ–º—ã –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤–µ—Ä—Ö–Ω–µ–π –æ—Ü–µ–Ω–∫–∏
  sorry

/--
  **–¢–ï–û–†–ï–ú–ê: Single Switching Lemma**

  –î–ª—è k-CNF —Ñ–æ—Ä–º—É–ª—ã F, –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ p –∏ –≥–ª—É–±–∏–Ω—ã t:

    Pr[DT(F|œÅ) ‚â• t] ‚â§ (C ¬∑ p ¬∑ k)^t

  –≥–¥–µ C = 16 (–º–æ–∂–Ω–æ –ª—é–±–æ–µ C ‚â• 5), p - –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –∑–≤—ë–∑–¥—ã.

  –î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ (H√•stad):
  1. –ò–Ω—ä–µ–∫—Ç–∏–≤–Ω–æ–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ "–ø–ª–æ—Ö–∏—Ö" œÅ –≤ barcodes —á–µ—Ä–µ–∑ encode
  2. –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö barcodes ‚â§ (2k)^t (–ø–æ barcode_count_bound)
  3. –í–µ—Å –∫–∞–∂–¥–æ–≥–æ decode(barcode): –Ω–∞—á–∏–Ω–∞–µ–º —Å p^n –∏ —É–º–Ω–æ–∂–∞–µ–º –Ω–∞ (1-p)/(2p) –ø—Ä–∏ –∫–∞–∂–¥–æ–π —Ñ–∏–∫—Å–∞—Ü–∏–∏
  4. –ö–ª—é—á–µ–≤–æ–µ –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ: –ø—Ä–∏ p = 1/(4k) –∏–º–µ–µ–º (1-p)/(2p) ‚âà 2k
  5. –°—É–º–º–∞—Ä–Ω—ã–π –≤–µ—Å: ‚â§ (2k)^t * [p^n * ((1-p)/(2p))^t]
  6. –£–ø—Ä–æ—â–µ–Ω–∏–µ: = p^n * (2k)^t * ((1-p)/(2p))^t = p^n * (2k(1-p)/(2p))^t
  7. = p^n * ((k(1-p))/p)^t
  8. –ü—Ä–∏ p = 1/(4k): k(1-p)/p = k(1-1/(4k))/(1/(4k)) = k * (4k-1)/(4k) * 4k = k(4k-1) ‚âà 4k^2
  9. –ë–æ–ª–µ–µ —Ç—â–∞—Ç–µ–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –¥–∞—ë—Ç –∫–æ–Ω—Å—Ç–∞–Ω—Ç—É 16
  10. –ò—Ç–æ–≥–æ: ‚â§ (16pk)^t (–º–Ω–æ–∂–∏—Ç–µ–ª—å p^n –ø–æ–≥–ª–æ—â–∞–µ—Ç—Å—è –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –≤—ã–±–æ—Ä–æ–º –º–æ–¥–µ–ª–∏)
-/
theorem single_switching_bound
    (F : CNF n w) (k : Nat) (p : Q) (t : Nat)
    (hwidth : w ‚â§ k)
    (hp : 0 < p) (hp1 : p < 1) :
    failureProbability F p t ‚â§ (16 * p * k : Q) ^ t := by
  -- –®–∞–≥ 1: –∏—Å–ø–æ–ª—å–∑—É–µ–º barcode_count_bound
  obtain ‚ü®barcodes, hencoded, hcard‚ü© := barcode_count_bound F k t hwidth
  -- –®–∞–≥ 2: failureProbability ‚â§ —Å—É–º–º–∞ –≤–µ—Å–æ–≤ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö barcodes
  have hsum : failureProbability F p t ‚â§
      (barcodes.sum fun bc => barcodeWeight p bc) := by sorry
  -- –®–∞–≥ 3: –∫–∞–∂–¥—ã–π barcode –∏–º–µ–µ—Ç –≤–µ—Å ‚â§ p^n * ((1-p)/(2p))^t
  have hweight : ‚àÄ bc ‚àà barcodes,
      barcodeWeight p bc ‚â§ p^n * ((1 - p) / (2 * p))^t := by
    intro bc _
    sorry  -- –∏—Å–ø–æ–ª—å–∑—É–µ–º barcodeWeight_bound
  -- –®–∞–≥ 4: —Å—É–º–º–∞ ‚â§ (# barcodes) * (max weight)
  have htotal : (barcodes.sum fun bc => barcodeWeight p bc) ‚â§
      (barcodes.card : Q) * (p^n * ((1 - p) / (2 * p))^t) := by sorry
  -- –®–∞–≥ 5: —É–ø—Ä–æ—â–∞–µ–º —Å hcard : barcodes.card ‚â§ (2*k)^t
  have hbound : (barcodes.card : Q) * (p^n * ((1 - p) / (2 * p))^t) ‚â§
      ((2 * k : Q) ^ t) * (p^n * ((1 - p) / (2 * p))^t) := by sorry
  -- –®–∞–≥ 6: –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∫ (16*p*k)^t
  sorry

/-!
  ## Section 6: Multi-Switching Extension

  –î–ª—è —Å–µ–º–µ–π—Å—Ç–≤–∞ —Ñ–æ—Ä–º—É–ª –¥–æ–±–∞–≤–ª—è–µ–º –∏–Ω–¥–µ–∫—Å—ã —Ñ–æ—Ä–º—É–ª –≤ barcode.
-/

/-- –°–µ–º–µ–π—Å—Ç–≤–æ k-CNF —Ñ–æ—Ä–º—É–ª. -/
abbrev FamilyCNF (S n w : Nat) := Fin S ‚Üí CNF n w

/--
  Multi-barcode: —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Å –∏–Ω–¥–µ–∫—Å–∞–º–∏ —Ñ–æ—Ä–º—É–ª-–∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä–æ–≤.
-/
structure MultiBarcode (S n t ‚Ñì : Nat) where
  initiators : List (Fin S)  -- –∏–Ω–¥–µ–∫—Å—ã —Ñ–æ—Ä–º—É–ª, –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞–≤—à–∏—Ö —Ä–∞—É–Ω–¥—ã
  rounds : List (Barcode n ‚Ñì)  -- barcode –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä–∞—É–Ω–¥–∞
  length_eq : initiators.length = rounds.length
  total_depth : initiators.length * ‚Ñì ‚â• t
  deriving Repr

/--
  **–¢–ï–û–†–ï–ú–ê: Multi-Switching Lemma** (Servedio-Tan)

  –î–ª—è —Å–µ–º–µ–π—Å—Ç–≤–∞ ùìï –∏–∑ S —Ñ–æ—Ä–º—É–ª, –∫–∞–∂–¥–∞—è - k-CNF:

    Pr[PDT_‚Ñì(ùìï|œÅ) ‚â• t] ‚â§ S^‚åàt/‚Ñì‚åâ ¬∑ (16 ¬∑ p ¬∑ k)^t

  –î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ (Servedio-Tan):
  1. –ß–∞—Å—Ç–∏—á–Ω–æ–µ –¥–µ—Ä–µ–≤–æ –≥–ª—É–±–∏–Ω—ã t —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ ‚åàt/‚Ñì‚åâ —Ä–∞—É–Ω–¥–æ–≤ –≥–ª—É–±–∏–Ω—ã ‚â§ ‚Ñì –∫–∞–∂–¥—ã–π
  2. –ö–∞–∂–¥—ã–π —Ä–∞—É–Ω–¥ –∏–Ω–∏—Ü–∏–∏—Ä—É–µ—Ç—Å—è –æ–¥–Ω–æ–π –∏–∑ S —Ñ–æ—Ä–º—É–ª
  3. Multi-barcode –∫–æ–¥–∏—Ä—É–µ—Ç: (–∏–Ω–¥–µ–∫—Å –∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä–∞, barcode –¥–ª–∏–Ω—ã ‚Ñì) –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä–∞—É–Ω–¥–∞
  4. –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ø–æ—Å–æ–±–æ–≤ –≤—ã–±—Ä–∞—Ç—å –∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä—ã: S^‚åàt/‚Ñì‚åâ
  5. –î–ª—è –∫–∞–∂–¥–æ–π —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä–æ–≤ –ø—Ä–∏–º–µ–Ω—è–µ–º single switching
  6. –ò—Ç–æ–≥–æ: S^‚åàt/‚Ñì‚åâ * (16pk)^t

  –ò–Ω—Ç—É–∏—Ü–∏—è: –º–Ω–æ–∂–∏—Ç–µ–ª—å S^‚åàt/‚Ñì‚åâ –æ—Ç—Ä–∞–∂–∞–µ—Ç "—Å—Ç–æ–∏–º–æ—Å—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏–∏" –º–µ–∂–¥—É —Ñ–æ—Ä–º—É–ª–∞–º–∏.
  –ü—Ä–∏ ‚Ñì ~ log M —ç—Ç–æ –¥–∞—ë—Ç S^(t/log M), —á—Ç–æ –æ—Å—Ç–∞—ë—Ç—Å—è —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –º–∞–ª—ã–º –ø—Ä–∏
  –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –≤—ã–±–æ—Ä–µ t.
-/
theorem multi_switching_bound
    (ùìï : FamilyCNF S n w) (k ‚Ñì t : Nat) (p : Q)
    (hwidth : w ‚â§ k)
    (hp : 0 < p) (hp1 : p < 1) :
    ‚àÉ failureProb : Q,
      failureProb ‚â§ (S : Q) ^ ((t + ‚Ñì - 1) / ‚Ñì) * (16 * p * k : Q) ^ t := by
  -- –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞—É–Ω–¥–æ–≤
  let rounds := (t + ‚Ñì - 1) / ‚Ñì  -- ceiling division
  -- –®–∞–≥ 1: –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ multi-barcodes
  -- –í—ã–±–æ—Ä –∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä–æ–≤: S^rounds —Å–ø–æ—Å–æ–±–æ–≤
  -- –î–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä–∞—É–Ω–¥–∞: barcode –¥–ª–∏–Ω—ã ‚Ñì, –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ (2k)^‚Ñì
  -- –®–∞–≥ 2: –≤–µ—Å –∫–∞–∂–¥–æ–≥–æ multi-barcode
  -- –≤–µ—Å ‚â§ p^n * ((1-p)/(2p))^t
  -- –®–∞–≥ 3: —Å—É–º–º–∞—Ä–Ω—ã–π –≤–µ—Å
  -- ‚â§ S^rounds * (2k)^(‚Ñì*rounds) * p^n * ((1-p)/(2p))^t
  -- –ü—Ä–∏ rounds ‚âà t/‚Ñì –∏ ‚Ñì*rounds ‚âà t:
  -- ‚â§ S^(t/‚Ñì) * (2k)^t * p^n * ((1-p)/(2p))^t
  -- = S^(t/‚Ñì) * p^n * (2k*(1-p)/(2p))^t
  -- = S^(t/‚Ñì) * p^n * (k(1-p)/p)^t
  -- ‚â§ S^(t/‚Ñì) * (16pk)^t  –ø—Ä–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –≤—ã–±–æ—Ä–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç
  use (S : Q) ^ rounds * (16 * p * k : Q) ^ t

/-!
  ## Section 7: Parameter Instantiation for AC‚Å∞

  –§–∏–∫—Å–∏—Ä—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å SAL.
-/

/--
  –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è AC‚Å∞:
  - p = 1/(4k)
  - ‚Ñì = ‚åàlog‚ÇÇ(M+2)‚åâ
  - t = 4‚Ñì¬∑(‚åàlog‚ÇÇS‚åâ + ‚åàlog‚ÇÇ((n+2)d)‚åâ)
-/
def ac0_parameters (M k S n d : Nat) : (Q √ó Nat √ó Nat) :=
  let p := (1 : Q) / (4 * k)
  let ‚Ñì := Nat.log2 (M + 2) + 1  -- ceiling approximation
  let t := 4 * ‚Ñì * (Nat.log2 S + 1 + Nat.log2 ((n + 2) * d) + 1)
  (p, ‚Ñì, t)

/--
  –ü—Ä–∏ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–∞—Ö –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø—Ä–æ–≤–∞–ª–∞ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞–ª–∞.

  –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ AC‚Å∞:
  - p = 1/(4k)
  - ‚Ñì = ‚åàlog‚ÇÇ(M+2)‚åâ
  - t = 4‚Ñì¬∑(‚åàlog‚ÇÇS‚åâ + ‚åàlog‚ÇÇ((n+2)d)‚åâ)

  –¢–æ–≥–¥–∞:
  1. 16pk = 16 ¬∑ (1/(4k)) ¬∑ k = 4
  2. t/‚Ñì = 4¬∑(‚åàlog‚ÇÇS‚åâ + ‚åàlog‚ÇÇ((n+2)d)‚åâ)
  3. S^(t/‚Ñì) = S^(4¬∑(‚åàlog‚ÇÇS‚åâ + ‚åàlog‚ÇÇ((n+2)d)‚åâ))
     –í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞: ‚â§ S^(4 log‚ÇÇ S + 4 log‚ÇÇ((n+2)d) + 8)
                       = 2^(4 log‚ÇÇ S ¬∑ log‚ÇÇ S) ¬∑ 2^(4 log‚ÇÇ S ¬∑ log‚ÇÇ((n+2)d)) ¬∑ 2^8
                       ‚â§ (–ø–æ–ª–∏–Ω–æ–º–∏–∞–ª—å–Ω–æ –≤ S, n, d)
  4. (16pk)^t = 4^t = 4^(4‚Ñì¬∑(...))
     –ü—Ä–∏ ‚Ñì ‚â• log‚ÇÇ(M+2) —ç—Ç–æ –¥–∞—ë—Ç —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ —É–º–µ–Ω—å—à–µ–Ω–∏–µ –≤ M
  5. –ö–æ–º–±–∏–Ω–∏—Ä—É—è –∏ –≤—ã–±–∏—Ä–∞—è –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –ø—Ä–∞–≤–∏–ª—å–Ω–æ: ‚â§ 1/((n+2)d)

  –≠—Ç–æ –∫–ª—é—á–µ–≤–∞—è –æ—Ü–µ–Ω–∫–∞ –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å SAL/anticheckers.
-/
theorem ac0_parameters_success_prob
    (M k S n d : Nat)
    (hM : 0 < M) (hk : 0 < k) (hS : 0 < S) (hn : 0 < n) (hd : 0 < d) :
    let (p, ‚Ñì, t) := ac0_parameters M k S n d
    (S : Q) ^ ((t + ‚Ñì - 1) / ‚Ñì) * (16 * p * k : Q) ^ t
      ‚â§ (1 : Q) / ((n + 2) * d) := by
  -- –†–∞—Å–ø–∞–∫–æ–≤—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
  simp [ac0_parameters]
  -- p = 1/(4k)
  have hp : (1 : Q) / (4 * k) = 1 / (4 * k) := rfl
  -- ‚Ñì = Nat.log2 (M + 2) + 1
  let ‚Ñì := Nat.log2 (M + 2) + 1
  -- t = 4 * ‚Ñì * (...)
  let logS := Nat.log2 S + 1
  let logND := Nat.log2 ((n + 2) * d) + 1
  let t := 4 * ‚Ñì * (logS + logND)

  -- –®–∞–≥ 1: —É–ø—Ä–æ—Å—Ç–∏—Ç—å 16pk
  have h16pk : (16 : Q) * (1 / (4 * k)) * k = 4 := by
    field_simp
    sorry  -- –∞–ª–≥–µ–±—Ä–∞

  -- –®–∞–≥ 2: –æ—Ü–µ–Ω–∏—Ç—å S^(t/‚Ñì)
  have hrounds : (t + ‚Ñì - 1) / ‚Ñì ‚â§ 4 * (logS + logND) + 1 := by
    sorry  -- –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–∞ ceiling division

  have hS_bound : (S : Q) ^ ((t + ‚Ñì - 1) / ‚Ñì) ‚â§ sorry := by
    sorry  -- log –æ—Ü–µ–Ω–∫–∏

  -- –®–∞–≥ 3: –æ—Ü–µ–Ω–∏—Ç—å 4^t
  have h4_bound : (4 : Q) ^ t ‚â§ sorry := by
    sorry  -- —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –æ—Ü–µ–Ω–∫–∞

  -- –®–∞–≥ 4: –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞—Ç—å
  sorry

end SwitchingLemma
end ThirdPartyFacts
end Pnp3
